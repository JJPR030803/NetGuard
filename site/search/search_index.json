{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Network Security Suite Documentation","text":"<p>Welcome to the comprehensive documentation for the Network Security Suite - an enterprise-level network security monitoring and analysis platform with machine learning capabilities.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Network Security Suite is a complete security monitoring solution that combines real-time packet capture, advanced analysis, and machine learning-based threat detection. This documentation provides detailed information about all components of the suite.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Real-time Network Monitoring: Capture and analyze network traffic in real-time using advanced packet sniffing capabilities</li> <li>Machine Learning Analysis: Leverage ML models for anomaly detection and threat identification</li> <li>Flexible Architecture: Modular design allowing easy extension and customization</li> <li>Performance Optimized: Efficient packet processing with Parquet-based storage</li> <li>Comprehensive Logging: Detailed logging system for debugging and auditing</li> <li>REST API: FastAPI-based API for integration with other tools</li> </ul>"},{"location":"#components","title":"Components","text":"<p>The suite consists of several main modules:</p>"},{"location":"#sniffer-module","title":"Sniffer Module","text":"<p>Network packet capture and processing engine. Handles real-time packet sniffing, filtering, and storage.</p> <p>Key Features: - Multi-interface support - Customizable packet filtering - Parquet-based storage for efficient analysis - Real-time packet processing</p>"},{"location":"#ml-module","title":"ML Module","text":"<p>Machine learning and network traffic analysis components for advanced threat detection.</p> <p>Key Features: - Protocol-specific analyzers (TCP, UDP, DNS, etc.) - Anomaly detection - IP reputation analysis - Flow analysis</p>"},{"location":"#models-module","title":"Models Module","text":"<p>Data structures and database schemas for packet and network data representation.</p> <p>Key Features: - Pydantic-based data models - Type-safe data structures - Database schema definitions</p>"},{"location":"#utils-module","title":"Utils Module","text":"<p>Shared utilities and helper functions used across the suite.</p> <p>Key Features: - Advanced logging system - Performance metrics tracking - Configuration management</p>"},{"location":"#api-module","title":"API Module","text":"<p>REST API for interacting with the network security suite.</p> <p>Key Features: - FastAPI-based endpoints - OpenAPI documentation - Authentication and authorization</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/yourusername/netguard\ncd netguard\n\n# Install dependencies with uv\nuv sync\n\n# Or with poetry\npoetry install\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\nfrom network_security_suite.ml.preprocessing import NetworkParquetAnalysis\n\n# Start packet capture\ncapture = PacketCapture(interface=\"eth0\")\ncapture.start()\n\n# Analyze captured data\nanalyzer = NetworkParquetAnalysis(\"captured_data.parquet\")\nresults = analyzer.tcp.analyze_connection_patterns()\n</code></pre>"},{"location":"#development","title":"Development","text":""},{"location":"#setting-up-development-environment","title":"Setting Up Development Environment","text":"<pre><code># Install development dependencies\nuv sync --dev\n\n# Run tests\nuv run pytest\n\n# Format code\nuv run ruff format\n\n# Lint code\nuv run ruff check\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the Development Guide for more information.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>User Guides: Step-by-step instructions for common tasks</li> <li>API Reference: Detailed API documentation for all modules</li> <li>Examples: Practical examples and use cases</li> <li>Development: Information for contributors and developers</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For questions, issues, or contributions:</p> <ul> <li>GitHub Issues: Report a bug or request a feature</li> <li>Discussions: Join the community</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p> <p>Note: This is a thesis project focused on network security monitoring and analysis. Use responsibly and only on networks you have permission to monitor.</p>"},{"location":"api/","title":"API Module","text":"<p>The API module provides REST API endpoints for interacting with the Network Security Suite.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The API module is built with FastAPI and provides programmatic access to network monitoring, packet capture, and analysis capabilities.</p>"},{"location":"api/#key-features","title":"Key Features","text":"<ul> <li>RESTful API: Clean REST API design</li> <li>OpenAPI Documentation: Automatic API documentation</li> <li>Authentication: Secure API access</li> <li>Real-time Updates: WebSocket support for live data</li> <li>JSON Responses: Standard JSON response format</li> </ul>"},{"location":"api/#quick-start","title":"Quick Start","text":""},{"location":"api/#starting-the-api-server","title":"Starting the API Server","text":"<pre><code># Using uvicorn\nuvicorn network_security_suite.api.main:app --reload\n\n# Or with custom host/port\nuvicorn network_security_suite.api.main:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"api/#api-documentation","title":"API Documentation","text":"<p>Once the server is running, visit: - Swagger UI: http://localhost:8000/docs - ReDoc: http://localhost:8000/redoc - OpenAPI JSON: http://localhost:8000/openapi.json</p>"},{"location":"api/#basic-usage","title":"Basic Usage","text":""},{"location":"api/#using-python-requests","title":"Using Python Requests","text":"<pre><code>import requests\n\n# Get system status\nresponse = requests.get(\"http://localhost:8000/api/status\")\nstatus = response.json()\nprint(status)\n\n# Start packet capture\ncapture_config = {\n    \"interface\": \"eth0\",\n    \"packet_count\": 1000,\n    \"filter\": \"tcp port 80\"\n}\nresponse = requests.post(\"http://localhost:8000/api/capture/start\", json=capture_config)\nprint(response.json())\n</code></pre>"},{"location":"api/#using-curl","title":"Using cURL","text":"<pre><code># Get status\ncurl http://localhost:8000/api/status\n\n# Start capture\ncurl -X POST http://localhost:8000/api/capture/start \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"interface\": \"eth0\", \"packet_count\": 1000}'\n</code></pre>"},{"location":"api/#api-endpoints","title":"API Endpoints","text":""},{"location":"api/#status-endpoints","title":"Status Endpoints","text":"<ul> <li><code>GET /api/status</code> - Get API status</li> <li><code>GET /api/health</code> - Health check</li> </ul>"},{"location":"api/#capture-endpoints","title":"Capture Endpoints","text":"<ul> <li><code>POST /api/capture/start</code> - Start packet capture</li> <li><code>POST /api/capture/stop</code> - Stop packet capture</li> <li><code>GET /api/capture/status</code> - Get capture status</li> <li><code>GET /api/capture/statistics</code> - Get capture statistics</li> </ul>"},{"location":"api/#analysis-endpoints","title":"Analysis Endpoints","text":"<ul> <li><code>POST /api/analysis/run</code> - Run analysis on captured data</li> <li><code>GET /api/analysis/results/{id}</code> - Get analysis results</li> <li><code>GET /api/analysis/list</code> - List all analyses</li> </ul>"},{"location":"api/#data-endpoints","title":"Data Endpoints","text":"<ul> <li><code>GET /api/packets</code> - Get captured packets</li> <li><code>GET /api/packets/{id}</code> - Get specific packet</li> <li><code>GET /api/flows</code> - Get network flows</li> </ul>"},{"location":"api/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Client] --&gt; B[FastAPI]\n    B --&gt; C{Router}\n    C --&gt;|/capture| D[Capture Endpoints]\n    C --&gt;|/analysis| E[Analysis Endpoints]\n    C --&gt;|/data| F[Data Endpoints]\n    D --&gt; G[PacketCapture]\n    E --&gt; H[ML Analysis]\n    F --&gt; I[Database]</code></pre>"},{"location":"api/#authentication","title":"Authentication","text":""},{"location":"api/#api-key-authentication","title":"API Key Authentication","text":"<pre><code>import requests\n\nheaders = {\n    \"X-API-Key\": \"your-api-key-here\"\n}\n\nresponse = requests.get(\n    \"http://localhost:8000/api/capture/status\",\n    headers=headers\n)\n</code></pre>"},{"location":"api/#oauth2-coming-soon","title":"OAuth2 (Coming Soon)","text":"<p>OAuth2 authentication support is planned for future releases.</p>"},{"location":"api/#websocket-support","title":"WebSocket Support","text":""},{"location":"api/#real-time-packet-stream","title":"Real-time Packet Stream","text":"<pre><code>import asyncio\nimport websockets\n\nasync def packet_stream():\n    uri = \"ws://localhost:8000/ws/packets\"\n    async with websockets.connect(uri) as websocket:\n        while True:\n            packet = await websocket.recv()\n            print(f\"Received: {packet}\")\n\nasyncio.run(packet_stream())\n</code></pre>"},{"location":"api/#real-time-alerts","title":"Real-time Alerts","text":"<pre><code>async def alert_stream():\n    uri = \"ws://localhost:8000/ws/alerts\"\n    async with websockets.connect(uri) as websocket:\n        while True:\n            alert = await websocket.recv()\n            print(f\"Alert: {alert}\")\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#api-configuration","title":"API Configuration","text":"<pre><code># config.yaml\napi:\n  host: \"0.0.0.0\"\n  port: 8000\n  debug: false\n  reload: false\n\n  cors:\n    enabled: true\n    origins:\n      - \"http://localhost:3000\"\n      - \"http://localhost:8080\"\n\n  auth:\n    enabled: true\n    api_key_header: \"X-API-Key\"\n    valid_api_keys:\n      - \"key1\"\n      - \"key2\"\n\n  rate_limit:\n    enabled: true\n    requests_per_minute: 60\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":""},{"location":"api/#standard-error-response","title":"Standard Error Response","text":"<pre><code>{\n  \"error\": {\n    \"code\": \"CAPTURE_FAILED\",\n    \"message\": \"Failed to start packet capture\",\n    \"details\": {\n      \"interface\": \"eth0\",\n      \"reason\": \"Permission denied\"\n    }\n  }\n}\n</code></pre>"},{"location":"api/#http-status-codes","title":"HTTP Status Codes","text":"Code Description 200 Success 201 Created 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 429 Too Many Requests 500 Internal Server Error"},{"location":"api/#best-practices","title":"Best Practices","text":""},{"location":"api/#1-use-api-keys","title":"1. Use API Keys","text":"<p>Always use API keys in production:</p> <pre><code>headers = {\"X-API-Key\": os.getenv(\"API_KEY\")}\nresponse = requests.get(url, headers=headers)\n</code></pre>"},{"location":"api/#2-handle-errors","title":"2. Handle Errors","text":"<p>Always handle API errors:</p> <pre><code>try:\n    response = requests.post(url, json=data)\n    response.raise_for_status()\n    return response.json()\nexcept requests.exceptions.HTTPError as e:\n    logger.error(f\"API error: {e}\")\n    return None\n</code></pre>"},{"location":"api/#3-use-pagination","title":"3. Use Pagination","text":"<p>For large result sets, use pagination:</p> <pre><code>response = requests.get(\n    \"http://localhost:8000/api/packets\",\n    params={\"limit\": 100, \"offset\": 0}\n)\n</code></pre>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide: Step-by-step API tutorial</li> <li>Endpoints Reference: Complete endpoint documentation</li> <li>Examples: API usage examples</li> </ul>"},{"location":"api/endpoints/","title":"API Endpoints Reference","text":"<p>Complete reference for all API endpoints.</p>"},{"location":"api/endpoints/#status-endpoints","title":"Status Endpoints","text":""},{"location":"api/endpoints/#get-apistatus","title":"GET /api/status","text":"<p>Get API server status.</p> <p>Response: <pre><code>{\n  \"status\": \"online\",\n  \"version\": \"1.0.0\",\n  \"uptime\": 3600\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apihealth","title":"GET /api/health","text":"<p>Health check endpoint.</p> <p>Response: <pre><code>{\n  \"healthy\": true\n}\n</code></pre></p>"},{"location":"api/endpoints/#capture-endpoints","title":"Capture Endpoints","text":""},{"location":"api/endpoints/#post-apicapturestart","title":"POST /api/capture/start","text":"<p>Start a new packet capture.</p> <p>Request: <pre><code>{\n  \"interface\": \"eth0\",\n  \"packet_count\": 1000,\n  \"filter\": \"tcp port 80\",\n  \"output_file\": \"capture.parquet\"\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"capture_id\": \"abc123\",\n  \"status\": \"started\"\n}\n</code></pre></p>"},{"location":"api/endpoints/#post-apicapturestopcapture_id","title":"POST /api/capture/stop/{capture_id}","text":"<p>Stop an active capture.</p> <p>Response: <pre><code>{\n  \"capture_id\": \"abc123\",\n  \"status\": \"stopped\",\n  \"packets_captured\": 856\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apicapturestatuscapture_id","title":"GET /api/capture/status/{capture_id}","text":"<p>Get capture status.</p> <p>Response: <pre><code>{\n  \"capture_id\": \"abc123\",\n  \"state\": \"running\",\n  \"packets_captured\": 500,\n  \"start_time\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apicapturestatisticscapture_id","title":"GET /api/capture/statistics/{capture_id}","text":"<p>Get detailed capture statistics.</p> <p>Response: <pre><code>{\n  \"capture_id\": \"abc123\",\n  \"packets_captured\": 1000,\n  \"packets_dropped\": 5,\n  \"bytes_captured\": 500000,\n  \"protocols\": {\n    \"TCP\": 800,\n    \"UDP\": 150,\n    \"ICMP\": 50\n  }\n}\n</code></pre></p>"},{"location":"api/endpoints/#packet-endpoints","title":"Packet Endpoints","text":""},{"location":"api/endpoints/#get-apipackets","title":"GET /api/packets","text":"<p>Get captured packets with pagination.</p> <p>Query Parameters: - <code>limit</code>: Number of packets (default: 100) - <code>offset</code>: Offset for pagination (default: 0) - <code>protocol</code>: Filter by protocol - <code>src_ip</code>: Filter by source IP - <code>dst_ip</code>: Filter by destination IP</p> <p>Response: <pre><code>{\n  \"packets\": [...],\n  \"total\": 1000,\n  \"limit\": 100,\n  \"offset\": 0\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apipacketspacket_id","title":"GET /api/packets/{packet_id}","text":"<p>Get specific packet details.</p> <p>Response: <pre><code>{\n  \"id\": \"pkt_123\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"src_ip\": \"192.168.1.100\",\n  \"dst_ip\": \"10.0.0.1\",\n  \"protocol\": \"TCP\",\n  \"length\": 1500\n}\n</code></pre></p>"},{"location":"api/endpoints/#analysis-endpoints","title":"Analysis Endpoints","text":""},{"location":"api/endpoints/#post-apianalysisrun","title":"POST /api/analysis/run","text":"<p>Run analysis on captured data.</p> <p>Request: <pre><code>{\n  \"capture_id\": \"abc123\",\n  \"analysis_type\": \"threat_detection\",\n  \"parameters\": {\n    \"threshold\": 0.8\n  }\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"analysis_id\": \"analysis_456\",\n  \"status\": \"queued\"\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apianalysisresultsanalysis_id","title":"GET /api/analysis/results/{analysis_id}","text":"<p>Get analysis results.</p> <p>Response: <pre><code>{\n  \"analysis_id\": \"analysis_456\",\n  \"status\": \"completed\",\n  \"results\": {\n    \"threats_detected\": 3,\n    \"anomalies\": 5\n  }\n}\n</code></pre></p>"},{"location":"api/endpoints/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>API Overview</li> </ul>"},{"location":"api/getting-started/","title":"API Getting Started","text":"<p>This guide will help you get started with the Network Security Suite API.</p>"},{"location":"api/getting-started/#installation","title":"Installation","text":"<p>The API is included with the Network Security Suite:</p> <pre><code># Install with API dependencies\nuv sync --extras api\n\n# Or with poetry\npoetry install --extras api\n</code></pre>"},{"location":"api/getting-started/#starting-the-server","title":"Starting the Server","text":""},{"location":"api/getting-started/#development-mode","title":"Development Mode","text":"<pre><code># Start with auto-reload\nuvicorn network_security_suite.api.main:app --reload\n\n# With custom port\nuvicorn network_security_suite.api.main:app --reload --port 8080\n</code></pre>"},{"location":"api/getting-started/#production-mode","title":"Production Mode","text":"<pre><code># Production server with Gunicorn\ngunicorn network_security_suite.api.main:app \\\n  -w 4 \\\n  -k uvicorn.workers.UvicornWorker \\\n  --bind 0.0.0.0:8000\n</code></pre>"},{"location":"api/getting-started/#first-api-call","title":"First API Call","text":""},{"location":"api/getting-started/#get-api-status","title":"Get API Status","text":"<pre><code>import requests\n\n# Get status\nresponse = requests.get(\"http://localhost:8000/api/status\")\nprint(response.json())\n</code></pre> <p>Expected response: <pre><code>{\n  \"status\": \"online\",\n  \"version\": \"1.0.0\",\n  \"uptime\": 3600\n}\n</code></pre></p>"},{"location":"api/getting-started/#check-api-health","title":"Check API Health","text":"<pre><code>curl http://localhost:8000/api/health\n</code></pre>"},{"location":"api/getting-started/#authentication","title":"Authentication","text":""},{"location":"api/getting-started/#using-api-key","title":"Using API Key","text":"<pre><code>import requests\nimport os\n\nAPI_KEY = os.getenv(\"NETGUARD_API_KEY\")\nheaders = {\"X-API-Key\": API_KEY}\n\nresponse = requests.get(\n    \"http://localhost:8000/api/capture/status\",\n    headers=headers\n)\n</code></pre>"},{"location":"api/getting-started/#environment-variables","title":"Environment Variables","text":"<pre><code>export NETGUARD_API_KEY=\"your-api-key-here\"\n</code></pre>"},{"location":"api/getting-started/#common-operations","title":"Common Operations","text":""},{"location":"api/getting-started/#start-packet-capture","title":"Start Packet Capture","text":"<pre><code>import requests\n\n# Configure capture\nconfig = {\n    \"interface\": \"eth0\",\n    \"packet_count\": 1000,\n    \"filter\": \"tcp port 80\",\n    \"output_file\": \"capture.parquet\"\n}\n\n# Start capture\nresponse = requests.post(\n    \"http://localhost:8000/api/capture/start\",\n    json=config\n)\n\ncapture_id = response.json()[\"capture_id\"]\nprint(f\"Capture started: {capture_id}\")\n</code></pre>"},{"location":"api/getting-started/#check-capture-status","title":"Check Capture Status","text":"<pre><code># Get status\nresponse = requests.get(\n    f\"http://localhost:8000/api/capture/status/{capture_id}\"\n)\n\nstatus = response.json()\nprint(f\"Status: {status['state']}\")\nprint(f\"Packets: {status['packets_captured']}\")\n</code></pre>"},{"location":"api/getting-started/#stop-capture","title":"Stop Capture","text":"<pre><code># Stop capture\nresponse = requests.post(\n    f\"http://localhost:8000/api/capture/stop/{capture_id}\"\n)\n\nprint(response.json())\n</code></pre>"},{"location":"api/getting-started/#get-captured-packets","title":"Get Captured Packets","text":"<pre><code># Get packets\nresponse = requests.get(\n    \"http://localhost:8000/api/packets\",\n    params={\"limit\": 10}\n)\n\npackets = response.json()[\"packets\"]\nfor packet in packets:\n    print(f\"{packet['src_ip']} -&gt; {packet['dst_ip']}\")\n</code></pre>"},{"location":"api/getting-started/#error-handling","title":"Error Handling","text":""},{"location":"api/getting-started/#handle-http-errors","title":"Handle HTTP Errors","text":"<pre><code>import requests\n\ntry:\n    response = requests.post(url, json=data)\n    response.raise_for_status()\n    result = response.json()\nexcept requests.exceptions.HTTPError as e:\n    print(f\"HTTP error: {e}\")\nexcept requests.exceptions.ConnectionError:\n    print(\"Connection failed\")\nexcept requests.exceptions.Timeout:\n    print(\"Request timeout\")\n</code></pre>"},{"location":"api/getting-started/#check-response-status","title":"Check Response Status","text":"<pre><code>response = requests.get(url)\n\nif response.status_code == 200:\n    data = response.json()\nelif response.status_code == 404:\n    print(\"Resource not found\")\nelif response.status_code == 401:\n    print(\"Unauthorized\")\nelse:\n    print(f\"Error: {response.status_code}\")\n</code></pre>"},{"location":"api/getting-started/#interactive-api-documentation","title":"Interactive API Documentation","text":"<p>Visit the interactive API documentation:</p> <ul> <li>Swagger UI: http://localhost:8000/docs</li> <li>ReDoc: http://localhost:8000/redoc</li> </ul> <p>These provide: - Complete API reference - Try it out functionality - Request/response examples - Schema definitions</p>"},{"location":"api/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore API endpoints</li> <li>See more examples</li> <li>Read the API reference</li> </ul>"},{"location":"ml/","title":"ML Network Analysis Module","text":"<p>Welcome to the ML Network Analysis Module documentation. This module provides comprehensive tools for analyzing network traffic, detecting security threats, and extracting features for machine learning models.</p>"},{"location":"ml/#what-does-this-module-do","title":"What Does This Module Do?","text":"<p>The ML Network Analysis Module analyzes network packet captures (stored in Parquet format) to:</p> <ul> <li>Detect Security Threats: Port scans, SYN floods, DNS tunneling, data exfiltration, and more</li> <li>Analyze Traffic Patterns: Flow analysis, behavioral profiling, and anomaly detection</li> <li>Extract ML Features: Generate training data for machine learning models</li> <li>Investigate Incidents: Deep dive into specific IPs or time windows</li> <li>Generate Reports: Automated security audit reports with severity ratings</li> </ul>"},{"location":"ml/#key-features","title":"Key Features","text":""},{"location":"ml/#high-level-workflows","title":"\ud83c\udfaf High-Level Workflows","text":"<p>Three simple workflows cover 90% of use cases:</p> <ul> <li>Daily Security Audit: Automated security checks with color-coded reports</li> <li>IP Investigation: Deep dive into specific IP behavior</li> <li>Threat Hunting: Proactive hunting for C2, data theft, and lateral movement</li> </ul>"},{"location":"ml/#8-specialized-analyzers","title":"\ud83d\udd2c 8 Specialized Analyzers","text":"<p>Each analyzer is an expert in a specific protocol or analysis type:</p> Analyzer Purpose Key Features TCP TCP traffic analysis Connection tracking, flag analysis, retransmissions UDP UDP traffic analysis Flow stats, flood detection, amplification attacks DNS DNS analysis Tunneling detection, DGA identification, query analysis IP IP-level analysis Top talkers, hub detection, fragmentation analysis Flow Flow-based analysis 5-tuple flows, beaconing detection, long-lived connections ARP ARP traffic analysis Spoofing detection, ARP table reconstruction ICMP ICMP analysis Ping analysis, tunneling detection, flood detection Anomaly Cross-protocol threats Port/host scanning, attacks, behavioral anomalies"},{"location":"ml/#comprehensive-analysis","title":"\ud83d\udcca Comprehensive Analysis","text":"<ul> <li>15+ Attack Detection Methods: Port scans, floods, tunneling, spoofing, and more</li> <li>Behavioral Analysis: Traffic profiling for ML feature extraction</li> <li>Protocol Deep-Dive: Protocol-specific analysis with 200+ methods</li> <li>Flexible Reporting: JSON, CSV, Parquet exports</li> </ul>"},{"location":"ml/#quick-example","title":"Quick Example","text":"Daily Audit (CLI)Daily Audit (Python)IP InvestigationLow-Level Analysis <pre><code># Run automated security audit\nuv run python -m preprocessing.main daily-audit capture.parquet\n</code></pre> <pre><code>from network_security_suite.ml.preprocessing.workflows import DailyAudit\n\n# Run audit\naudit = DailyAudit(\"capture.parquet\")\nreport = audit.run()\n\n# Show results\nprint(report.summary())\n\n# Check severity\nif report.severity_counts[\"critical\"] &gt; 0:\n    send_alert(\"Critical findings detected!\")\n</code></pre> <pre><code>from network_security_suite.ml.preprocessing.workflows import IPInvestigation\n\n# Investigate suspicious IP\ninv = IPInvestigation(\"capture.parquet\", ip=\"192.168.1.100\")\nreport = inv.run()\n\nprint(report.summary())\n</code></pre> <pre><code>from network_security_suite.ml.preprocessing.parquet_analysis import NetworkParquetAnalysis\n\n# Load data\nanalysis = NetworkParquetAnalysis(\"capture.parquet\")\n\n# Protocol-specific analysis\ntop_ports = analysis.tcp.get_most_used_ports(n=10)\ndns_tunneling = analysis.dns.detect_dns_tunneling(length_threshold=100)\nport_scans = analysis.anomaly.detect_port_scanning(threshold=100, time_window=\"1m\")\n\n# IP analysis\ntop_ips = analysis.ip.get_most_active_ips(n=10, by=\"bytes\")\nhubs = analysis.ip.detect_hub_ips(threshold=50)\n</code></pre>"},{"location":"ml/#architecture","title":"Architecture","text":"<pre><code>graph TB\n    subgraph \"Input\"\n        A[Parquet Files&lt;br/&gt;Network Captures]\n    end\n\n    subgraph \"Core\"\n        B[NetworkParquetAnalysis&lt;br/&gt;Base Class]\n    end\n\n    subgraph \"High-Level Interface\"\n        W1[DailyAudit&lt;br/&gt;Workflow]\n        W2[IPInvestigation&lt;br/&gt;Workflow]\n        W3[ThreatHunting&lt;br/&gt;Workflow]\n    end\n\n    subgraph \"Analyzers\"\n        C1[TCP Analyzer]\n        C2[UDP Analyzer]\n        C3[DNS Analyzer]\n        C4[IP Analyzer]\n        C5[Flow Analyzer]\n        C6[ARP Analyzer]\n        C7[ICMP Analyzer]\n        C8[Anomaly Analyzer]\n    end\n\n    subgraph \"Output\"\n        D1[Reports&lt;br/&gt;JSON/Console]\n        D2[ML Features&lt;br/&gt;Parquet]\n        D3[Alerts&lt;br/&gt;Critical Findings]\n    end\n\n    A --&gt; B\n    B --&gt; W1 &amp; W2 &amp; W3\n    B --&gt; C1 &amp; C2 &amp; C3 &amp; C4 &amp; C5 &amp; C6 &amp; C7 &amp; C8\n    W1 &amp; W2 &amp; W3 --&gt; D1 &amp; D3\n    C1 &amp; C2 &amp; C3 &amp; C4 &amp; C5 --&gt; D2</code></pre>"},{"location":"ml/#getting-started","title":"Getting Started","text":"<ol> <li>Installation: Set up the module</li> <li>Quick Start: Run your first analysis in 5 minutes</li> <li>Workflows Guide: Learn the three main workflows</li> <li>CLI Reference: Command-line interface documentation</li> </ol>"},{"location":"ml/#use-cases","title":"Use Cases","text":""},{"location":"ml/#security-operations","title":"Security Operations","text":"<ul> <li>Daily Monitoring: Automated security audits with alert integration</li> <li>Incident Response: Investigate suspicious IPs and behaviors</li> <li>Threat Hunting: Proactively search for advanced threats</li> <li>Compliance: Generate audit reports and evidence</li> </ul>"},{"location":"ml/#machine-learning","title":"Machine Learning","text":"<ul> <li>Feature Engineering: Extract behavioral features from network traffic</li> <li>Training Data: Generate labeled datasets for ML models</li> <li>Anomaly Detection: Feed data to ML-based anomaly detectors</li> <li>Behavioral Profiling: Create baseline profiles for normal behavior</li> </ul>"},{"location":"ml/#network-analysis","title":"Network Analysis","text":"<ul> <li>Performance Monitoring: Identify bandwidth hogs and bottlenecks</li> <li>Protocol Analysis: Understand traffic composition</li> <li>Connection Tracking: Monitor TCP connection states</li> <li>DNS Analysis: Track DNS queries and responses</li> </ul>"},{"location":"ml/#project-status","title":"Project Status","text":"<p>Current Status</p> <ul> <li>\u2705 8 Analyzers: All completed and tested</li> <li>\u2705 3 Workflows: Daily Audit, IP Investigation, Threat Hunting</li> <li>\u2705 CLI Interface: Full command-line support</li> <li>\ud83d\udea7 Testing: Unit tests in progress</li> <li>\ud83d\udcdd Documentation: This documentation site</li> </ul> <p>See Changelog for recent updates.</p>"},{"location":"ml/#support","title":"Support","text":"<ul> <li>Issues: Report bugs or request features on GitHub</li> <li>Discussions: Ask questions and share ideas</li> <li>Contributing: See Contributing Guide</li> </ul>"},{"location":"ml/#license","title":"License","text":"<p>[Add your license information here]</p>"},{"location":"ml/architecture/","title":"Architecture","text":"<p>This document explains the design and architecture of the ML Network Analysis Module.</p>"},{"location":"ml/architecture/#overview","title":"Overview","text":"<p>The module follows a layered architecture with clear separation of concerns:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              High-Level Workflows                   \u2502\n\u2502    (DailyAudit, IPInvestigation, ThreatHunting)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         NetworkParquetAnalysis (Core)               \u2502\n\u2502      (Base class, data loading, basic queries)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Specialized Analyzers                  \u2502\n\u2502  TCP \u2502 UDP \u2502 DNS \u2502 IP \u2502 Flow \u2502 ARP \u2502 ICMP \u2502 Anomaly \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Data Layer (Polars DataFrames)            \u2502\n\u2502             (Parquet files, efficient queries)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ml/architecture/#design-principles","title":"Design Principles","text":""},{"location":"ml/architecture/#1-modularity","title":"1. Modularity","text":"<p>Each analyzer is independent and focuses on a single protocol or analysis type:</p> <pre><code># Each analyzer has a single responsibility\ntcp_analyzer = TCPAnalyzer(df)\ndns_analyzer = DNSAnalyzer(df)\n</code></pre>"},{"location":"ml/architecture/#2-composition-over-inheritance","title":"2. Composition Over Inheritance","text":"<p>The base <code>NetworkParquetAnalysis</code> class composes analyzers rather than inheriting from them:</p> <pre><code>class NetworkParquetAnalysis:\n    def __init__(self, parquet_file):\n        self.df = pl.read_parquet(parquet_file)\n\n        # Composition: create analyzer instances\n        self.tcp = TCPAnalyzer(self.df.filter(pl.col(\"protocol\") == \"TCP\"))\n        self.dns = DNSAnalyzer(self.df.filter(pl.col(\"protocol\") == \"DNS\"))\n        # ... etc\n</code></pre>"},{"location":"ml/architecture/#3-lazy-evaluation","title":"3. Lazy Evaluation","text":"<p>Analyzers can be initialized lazily to save memory:</p> <pre><code># Only create analyzers when accessed\nanalysis = NetworkParquetAnalysis(\"large.parquet\", lazy_load=True)\n\n# TCP analyzer created on first access\ntcp_stats = analysis.tcp.get_most_used_ports(n=10)\n</code></pre>"},{"location":"ml/architecture/#4-polars-first","title":"4. Polars-First","text":"<p>All data operations use Polars for performance:</p> <ul> <li>Lazy evaluation support</li> <li>Efficient columnar operations</li> <li>Native Parquet support</li> <li>Fast aggregations and groupby</li> </ul> <pre><code># Polars DataFrame operations are fast and expressive\nresult = df.group_by(\"source_ip\").agg([\n    pl.count().alias(\"packet_count\"),\n    pl.sum(\"bytes\").alias(\"total_bytes\")\n]).sort(\"packet_count\", descending=True)\n</code></pre>"},{"location":"ml/architecture/#core-components","title":"Core Components","text":""},{"location":"ml/architecture/#networkparquetanalysis-base-class","title":"NetworkParquetAnalysis (Base Class)","text":"<p>Responsibilities:</p> <ul> <li>Load Parquet files</li> <li>Provide basic queries (filter by protocol, IP, timestamp)</li> <li>Initialize and manage analyzers</li> <li>Generate summary reports</li> </ul> <p>Key Methods:</p> <pre><code>class NetworkParquetAnalysis:\n    def __init__(self, parquet_file, lazy_load=False)\n    def get_by_protocol(self, protocol: str)\n    def find_ip_information(self, ip_address: str)\n    def get_timestamps(self)\n    def get_packet_count(self)\n    def generate_network_summary(self)\n</code></pre> <p>File: <code>preprocessing/parquet_analysis.py</code></p>"},{"location":"ml/architecture/#analyzers","title":"Analyzers","text":"<p>Each analyzer inherits from a base class and implements protocol-specific analysis.</p>"},{"location":"ml/architecture/#base-analyzer-pattern","title":"Base Analyzer Pattern","text":"<pre><code>class BaseAnalyzer:\n    def __init__(self, df: pl.DataFrame):\n        self.df = df\n        self.logger = get_logger()\n\n    def _validate_dataframe(self):\n        \"\"\"Ensure required columns exist\"\"\"\n        required = self._get_required_columns()\n        missing = [col for col in required if col not in self.df.columns]\n        if missing:\n            raise MissingColumnError(f\"Missing columns: {missing}\")\n</code></pre>"},{"location":"ml/architecture/#specialized-analyzers","title":"Specialized Analyzers","text":"Analyzer Inherits From Data Source Key Methods TCPAnalyzer BaseAnalyzer TCP packets Connection analysis, flag distribution UDPAnalyzer BaseAnalyzer UDP packets Flow stats, flood detection DNSAnalyzer BaseAnalyzer DNS packets Query analysis, tunneling detection IPAnalyzer BaseAnalyzer All packets Top talkers, hub detection FlowAnalyzer BaseAnalyzer All packets Flow creation, beaconing ARPAnalyzer BaseAnalyzer ARP packets Spoofing detection ICMPAnalyzer BaseAnalyzer ICMP packets Ping analysis, tunneling AnomalyAnalyzer BaseAnalyzer All packets Cross-protocol attack detection <p>Files: <code>preprocessing/analyzers/</code></p>"},{"location":"ml/architecture/#workflows","title":"Workflows","text":"<p>High-level workflows simplify common tasks by orchestrating multiple analyzers.</p> <pre><code>class DailyAudit:\n    def __init__(self, parquet_file):\n        self.analysis = NetworkParquetAnalysis(parquet_file)\n\n    def run(self):\n        report = WorkflowReport(\"Daily Audit\")\n\n        # Orchestrate multiple analyzers\n        self._check_port_scans(report)       # Uses anomaly analyzer\n        self._check_dns_threats(report)      # Uses DNS analyzer\n        self._check_top_talkers(report)      # Uses IP analyzer\n\n        return report\n</code></pre> <p>Advantages:</p> <ul> <li>Simplifies 90% of use cases</li> <li>Consistent report format</li> <li>Easy to extend with new checks</li> </ul> <p>Files: <code>preprocessing/workflows.py</code></p>"},{"location":"ml/architecture/#data-flow","title":"Data Flow","text":""},{"location":"ml/architecture/#1-loading-data","title":"1. Loading Data","text":"<pre><code>graph LR\n    A[Parquet File] --&gt;|pl.read_parquet| B[Polars DataFrame]\n    B --&gt;|Filter by protocol| C1[TCP DataFrame]\n    B --&gt;|Filter by protocol| C2[DNS DataFrame]\n    B --&gt;|Filter by protocol| C3[UDP DataFrame]\n    C1 --&gt; D1[TCPAnalyzer]\n    C2 --&gt; D2[DNSAnalyzer]\n    C3 --&gt; D3[UDPAnalyzer]</code></pre>"},{"location":"ml/architecture/#2-analysis-pipeline","title":"2. Analysis Pipeline","text":"<pre><code>graph TB\n    A[User Request] --&gt;|CLI or Python API| B{Workflow or Analyzer?}\n\n    B --&gt;|Workflow| C[Workflow Class]\n    B --&gt;|Analyzer| D[Specific Analyzer]\n\n    C --&gt;|Uses| E1[Multiple Analyzers]\n    E1 --&gt;|Aggregates| F[WorkflowReport]\n\n    D --&gt;|Returns| G[Polars DataFrame]\n\n    F --&gt; H[Output: Console/JSON]\n    G --&gt; H</code></pre>"},{"location":"ml/architecture/#3-lazy-loading","title":"3. Lazy Loading","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Analysis\n    participant Analyzer\n\n    User-&gt;&gt;Analysis: NetworkParquetAnalysis(file, lazy_load=True)\n    Analysis-&gt;&gt;Analysis: Load Parquet file\n    Note over Analysis: Analyzers NOT created yet\n\n    User-&gt;&gt;Analysis: analysis.tcp\n    Analysis-&gt;&gt;Analyzer: Create TCPAnalyzer(tcp_df)\n    Analyzer--&gt;&gt;Analysis: Return analyzer\n    Analysis--&gt;&gt;User: Return analyzer\n\n    User-&gt;&gt;Analyzer: analyzer.get_most_used_ports()\n    Analyzer--&gt;&gt;User: Return results</code></pre>"},{"location":"ml/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"ml/architecture/#1-strategy-pattern-analyzers","title":"1. Strategy Pattern (Analyzers)","text":"<p>Each analyzer implements a different strategy for analyzing the same data:</p> <pre><code># Different strategies for analysis\ntcp_strategy = TCPAnalyzer(df)\ndns_strategy = DNSAnalyzer(df)\n\n# Use interchangeably\nanalyzers = [tcp_strategy, dns_strategy]\nfor analyzer in analyzers:\n    analyzer.run_analysis()\n</code></pre>"},{"location":"ml/architecture/#2-facade-pattern-workflows","title":"2. Facade Pattern (Workflows)","text":"<p>Workflows provide a simplified interface to complex analyzer interactions:</p> <pre><code># Complex: Use multiple analyzers manually\ntcp = analysis.tcp\ndns = analysis.dns\nanomaly = analysis.anomaly\n\ntcp_issues = tcp.detect_incomplete_connections()\ndns_issues = dns.detect_dns_tunneling()\nport_scans = anomaly.detect_port_scanning()\n\n# Simple: Use workflow facade\naudit = DailyAudit(\"capture.parquet\")\nreport = audit.run()  # Handles all the above automatically\n</code></pre>"},{"location":"ml/architecture/#3-template-method-pattern-base-analyzer","title":"3. Template Method Pattern (Base Analyzer)","text":"<p>Base analyzer defines the analysis template, subclasses fill in details:</p> <pre><code>class BaseAnalyzer:\n    def run_analysis(self):\n        self._validate_dataframe()  # Template method\n        self._preprocess()           # Template method\n        results = self._analyze()    # Template method (subclass implements)\n        self._postprocess(results)   # Template method\n        return results\n\nclass TCPAnalyzer(BaseAnalyzer):\n    def _analyze(self):\n        # Subclass-specific implementation\n        return self.df.group_by(\"flags\").count()\n</code></pre>"},{"location":"ml/architecture/#error-handling","title":"Error Handling","text":""},{"location":"ml/architecture/#custom-exceptions","title":"Custom Exceptions","text":"<pre><code>class ParquetAnalysisError(Exception):\n    \"\"\"Base exception for analysis errors\"\"\"\n\nclass MissingColumnError(ParquetAnalysisError):\n    \"\"\"Raised when required columns are missing\"\"\"\n\nclass InvalidProtocolError(ParquetAnalysisError):\n    \"\"\"Raised when protocol is not recognized\"\"\"\n</code></pre> <p>File: <code>preprocessing/errors.py</code></p>"},{"location":"ml/architecture/#error-handling-strategy","title":"Error Handling Strategy","text":"<pre><code>try:\n    analysis = NetworkParquetAnalysis(\"capture.parquet\")\n    report = DailyAudit(analysis).run()\nexcept MissingColumnError as e:\n    logger.error(f\"Data format issue: {e}\")\nexcept ParquetAnalysisError as e:\n    logger.error(f\"Analysis failed: {e}\")\nexcept Exception as e:\n    logger.error(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"ml/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"ml/architecture/#1-memory-efficiency","title":"1. Memory Efficiency","text":"<ul> <li>Lazy loading: Only create analyzers when needed</li> <li>Lazy evaluation: Use <code>pl.scan_parquet()</code> for very large files</li> <li>Column selection: Read only required columns</li> </ul> <pre><code># Memory efficient: Only load needed columns\ndf = pl.scan_parquet(\"large.parquet\").select([\n    \"timestamp\", \"source_ip\", \"destination_ip\", \"protocol\"\n]).collect()\n</code></pre>"},{"location":"ml/architecture/#2-computation-efficiency","title":"2. Computation Efficiency","text":"<ul> <li>Polars operations: Vectorized, parallel by default</li> <li>Caching: Memoize expensive computations</li> <li>Early filtering: Filter data as early as possible</li> </ul> <pre><code># Efficient: Filter before analysis\ntcp_df = df.filter(pl.col(\"protocol\") == \"TCP\")\ntcp_analyzer = TCPAnalyzer(tcp_df)  # Works with smaller dataset\n</code></pre>"},{"location":"ml/architecture/#3-scalability","title":"3. Scalability","text":"<p>For very large datasets (&gt;10M packets):</p> <ol> <li>Chunked processing: Process in batches</li> <li>Streaming: Use lazy evaluation</li> <li>Sampling: Analyze representative sample first</li> <li>Distributed: Use Dask or Ray (future)</li> </ol>"},{"location":"ml/architecture/#extension-points","title":"Extension Points","text":""},{"location":"ml/architecture/#adding-a-new-analyzer","title":"Adding a New Analyzer","text":"<pre><code># 1. Create analyzer class\nclass HTTPAnalyzer(BaseAnalyzer):\n    def _get_required_columns(self):\n        return [\"http_method\", \"http_status\", \"url\"]\n\n    def get_top_urls(self, n=10):\n        return self.df.group_by(\"url\").count().head(n)\n\n# 2. Add to NetworkParquetAnalysis\nclass NetworkParquetAnalysis:\n    def __init__(self, parquet_file):\n        # ... existing code ...\n        self.http = HTTPAnalyzer(self.get_by_protocol(\"HTTP\"))\n</code></pre>"},{"location":"ml/architecture/#adding-a-new-workflow","title":"Adding a New Workflow","text":"<pre><code># 1. Create workflow class\nclass ComplianceAudit:\n    def __init__(self, parquet_file):\n        self.analysis = NetworkParquetAnalysis(parquet_file)\n\n    def run(self):\n        report = WorkflowReport(\"Compliance Audit\")\n        # Add compliance checks\n        return report\n\n# 2. Add to CLI\nparser.add_subparsers().add_parser(\"compliance-audit\")\n</code></pre>"},{"location":"ml/architecture/#testing-strategy","title":"Testing Strategy","text":""},{"location":"ml/architecture/#unit-tests","title":"Unit Tests","text":"<p>Test each analyzer independently:</p> <pre><code>def test_tcp_analyzer_flag_distribution():\n    # Create test data\n    df = create_test_tcp_dataframe()\n\n    # Test analyzer\n    analyzer = TCPAnalyzer(df)\n    result = analyzer.get_flag_distribution()\n\n    # Assert expected behavior\n    assert \"SYN\" in result[\"flag\"].to_list()\n</code></pre>"},{"location":"ml/architecture/#integration-tests","title":"Integration Tests","text":"<p>Test workflows end-to-end:</p> <pre><code>def test_daily_audit_workflow():\n    # Use real capture file\n    audit = DailyAudit(\"tests/fixtures/sample_capture.parquet\")\n    report = audit.run()\n\n    # Verify report structure\n    assert isinstance(report, WorkflowReport)\n    assert len(report.findings) &gt;= 0\n</code></pre> <p>Files: <code>tests/ml/preprocessing/</code></p>"},{"location":"ml/architecture/#future-architecture","title":"Future Architecture","text":"<p>Planned enhancements:</p> <ol> <li>Plugin System: Dynamic analyzer loading</li> <li>ML Integration: Native model training/inference</li> <li>Real-time Processing: Stream processing support</li> <li>Distributed Analysis: Spark/Dask integration</li> <li>REST API: HTTP API for remote analysis</li> </ol>"},{"location":"ml/architecture/#code-organization","title":"Code Organization","text":"<pre><code>ml/preprocessing/\n\u251c\u2500\u2500 parquet_analysis.py      # Core base class\n\u251c\u2500\u2500 workflows.py             # High-level workflows\n\u251c\u2500\u2500 analyzers/               # Protocol analyzers\n\u2502   \u251c\u2500\u2500 tcp_analyzer.py\n\u2502   \u251c\u2500\u2500 dns_analyzer.py\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 logger.py                # Logging utilities\n\u251c\u2500\u2500 errors.py                # Custom exceptions\n\u251c\u2500\u2500 utils.py                 # Helper functions\n\u251c\u2500\u2500 main.py                  # CLI entry point\n\u2514\u2500\u2500 examples/                # Usage examples\n</code></pre>"},{"location":"ml/architecture/#dependencies","title":"Dependencies","text":"<ul> <li>polars: Fast DataFrame operations</li> <li>pyarrow: Parquet file support</li> <li>Python 3.10+: For modern type hints and features</li> </ul> <p>Minimal dependencies by design for easier maintenance.</p>"},{"location":"ml/installation/","title":"Installation","text":"<p>This guide walks you through installing and setting up the ML Network Analysis Module.</p>"},{"location":"ml/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.10 or higher</li> <li>UV: Package manager (recommended) or pip</li> <li>System: Linux, macOS, or Windows (WSL recommended)</li> </ul>"},{"location":"ml/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"ml/installation/#method-1-using-uv-recommended","title":"Method 1: Using UV (Recommended)","text":"<p>UV is a fast Python package manager that handles dependencies efficiently.</p> <pre><code># Navigate to project root\ncd /path/to/netguard\n\n# Sync dependencies (installs everything from pyproject.toml)\nuv sync\n\n# Verify installation\nuv run python -m preprocessing.main --help\n</code></pre>"},{"location":"ml/installation/#method-2-using-pip","title":"Method 2: Using pip","text":"<pre><code># Navigate to project root\ncd /path/to/netguard\n\n# Install in editable mode\npip install -e .\n\n# Verify installation\npython -m src.network_security_suite.ml.preprocessing.main --help\n</code></pre>"},{"location":"ml/installation/#dependencies","title":"Dependencies","text":"<p>The module requires the following key dependencies (automatically installed):</p>"},{"location":"ml/installation/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>polars (&gt;=0.20.0): Fast DataFrame library for data processing</li> <li>pyarrow (&gt;=14.0.0): Parquet file support</li> <li>numpy (&gt;=1.24.0): Numerical computing</li> </ul>"},{"location":"ml/installation/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>pandas (for compatibility with existing tools)</li> <li>scikit-learn (for ML feature extraction)</li> </ul>"},{"location":"ml/installation/#documentation-dependencies","title":"Documentation Dependencies","text":"<ul> <li>mkdocs-material: Documentation framework (for building docs)</li> <li>mkdocstrings[python]: API documentation generation</li> </ul> <p>All dependencies are defined in <code>pyproject.toml</code>.</p>"},{"location":"ml/installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"ml/installation/#1-check-module-import","title":"1. Check Module Import","text":"<pre><code># Test imports\npython -c \"from network_security_suite.ml.preprocessing.parquet_analysis import NetworkParquetAnalysis; print('\u2713 Import successful')\"\n</code></pre>"},{"location":"ml/installation/#2-check-cli","title":"2. Check CLI","text":"<pre><code># Should show help text\nuv run python -m preprocessing.main --help\n</code></pre> <p>Expected output: <pre><code>usage: main.py [-h] [-v] [-q] {analyze,info,schema,daily-audit,investigate-ip,threat-hunt} ...\n\nNetwork Traffic Parquet Analysis Tool\n\npositional arguments:\n  {analyze,info,schema,daily-audit,investigate-ip,threat-hunt}\n    analyze             Analyze a parquet file\n    info                Display basic file information\n    schema              Display parquet file schema\n    daily-audit         Run automated daily security audit\n    investigate-ip      Investigate specific IP address\n    threat-hunt         Proactive threat hunting\n...\n</code></pre></p>"},{"location":"ml/installation/#3-run-test-analysis","title":"3. Run Test Analysis","text":"<p>Create a test script to verify everything works:</p> <pre><code># test_install.py\nfrom network_security_suite.ml.preprocessing.workflows import DailyAudit\n\nprint(\"\u2713 Imports successful\")\nprint(\"\u2713 Installation complete!\")\n</code></pre> <pre><code>uv run python test_install.py\n</code></pre>"},{"location":"ml/installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> <pre><code># Clone repository\ngit clone https://github.com/yourusername/netguard.git\ncd netguard\n\n# Install with dev dependencies\nuv sync --dev\n\n# Install pre-commit hooks (optional)\npre-commit install\n\n# Run tests\nuv run pytest tests/\n</code></pre>"},{"location":"ml/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ml/installation/#importerror-no-module-named-polars","title":"ImportError: No module named 'polars'","text":"<p>Solution: Dependencies not installed</p> <pre><code># With UV\nuv sync\n\n# With pip\npip install -e .\n</code></pre>"},{"location":"ml/installation/#modulenotfounderror-no-module-named-network_security_suite","title":"ModuleNotFoundError: No module named 'network_security_suite'","text":"<p>Solution: Not running from correct directory or package not installed</p> <pre><code># Make sure you're in the project root\ncd /path/to/netguard\n\n# Install in editable mode\npip install -e .\n</code></pre>"},{"location":"ml/installation/#unicodedecodeerror-when-running","title":"UnicodeDecodeError when running","text":"<p>Solution: This was fixed in the logger.py file (replaced invalid character)</p> <pre><code># Pull latest changes\ngit pull\n\n# Or manually verify logger.py line 113 has proper \u00d7 character\n</code></pre>"},{"location":"ml/installation/#file-not-found-when-running-cli","title":"\"File not found\" when running CLI","text":"<p>Solution: Provide full path to parquet file</p> <pre><code># Use absolute path\nuv run python -m preprocessing.main daily-audit /full/path/to/capture.parquet\n</code></pre>"},{"location":"ml/installation/#memory-errors-with-large-files","title":"Memory errors with large files","text":"<p>Solution: Use lazy loading</p> <pre><code># Add --lazy flag\nuv run python -m preprocessing.main daily-audit large_file.parquet --lazy\n</code></pre>"},{"location":"ml/installation/#configuration","title":"Configuration","text":""},{"location":"ml/installation/#environment-variables","title":"Environment Variables","text":"<p>You can set these environment variables for customization:</p> <pre><code># Set custom log level\nexport NETGUARD_LOG_LEVEL=DEBUG\n\n# Set custom output directory\nexport NETGUARD_OUTPUT_DIR=/path/to/reports\n</code></pre>"},{"location":"ml/installation/#config-file-future","title":"Config File (Future)","text":"<p>Configuration file support is planned for <code>config.yaml</code>:</p> <pre><code># .netguard/config.yaml (planned)\nbusiness_hours:\n  start: \"09:00\"\n  end: \"17:00\"\n\nthresholds:\n  port_scan: 100\n  syn_flood: 1000\n  dns_tunneling: 100\n\noutput:\n  format: json\n  directory: ./reports\n</code></pre>"},{"location":"ml/installation/#next-steps","title":"Next Steps","text":"<ol> <li>Quick Start: Run your first analysis</li> <li>User Guide: Learn the workflows</li> <li>CLI Reference: Explore all commands</li> <li>Examples: See real-world usage</li> </ol>"},{"location":"ml/installation/#updating","title":"Updating","text":""},{"location":"ml/installation/#update-with-uv","title":"Update with UV","text":"<pre><code># Pull latest changes\ngit pull\n\n# Update dependencies\nuv sync\n</code></pre>"},{"location":"ml/installation/#update-with-pip","title":"Update with pip","text":"<pre><code># Pull latest changes\ngit pull\n\n# Reinstall\npip install -e . --upgrade\n</code></pre>"},{"location":"ml/installation/#uninstalling","title":"Uninstalling","text":"<pre><code># With pip\npip uninstall network-security-suite\n\n# With UV (remove from project)\nuv remove network-security-suite\n</code></pre>"},{"location":"ml/installation/#docker-installation-optional","title":"Docker Installation (Optional)","text":"<p>For isolated environments:</p> <pre><code># Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install UV\nRUN pip install uv\n\n# Copy project files\nCOPY . .\n\n# Install dependencies\nRUN uv sync\n\n# Run analysis\nENTRYPOINT [\"uv\", \"run\", \"python\", \"-m\", \"preprocessing.main\"]\n</code></pre> <p>Build and run:</p> <pre><code># Build image\ndocker build -t netguard-ml .\n\n# Run analysis\ndocker run -v $(pwd)/data:/data netguard-ml daily-audit /data/capture.parquet\n</code></pre>"},{"location":"ml/quickstart/","title":"Quick Start Guide - Network Analysis Workflows","text":"<p>This guide shows you the simplest ways to use the network analysis toolkit.</p>"},{"location":"ml/quickstart/#what-problem-does-this-solve","title":"What Problem Does This Solve?","text":"<p>You capture network packets \u2192 You need to know if there are threats \u2192 This analyzes automatically</p>"},{"location":"ml/quickstart/#the-3-main-workflows","title":"The 3 Main Workflows","text":""},{"location":"ml/quickstart/#1-daily-security-audit-most-common","title":"1. Daily Security Audit (Most Common)","text":"<p>What it does: Runs 15+ security checks automatically and gives you a report</p> <p>When to use: Every day, or after capturing traffic you want to check for threats</p> <pre><code># Run from the ml/preprocessing directory\nuv run python -m preprocessing.main daily-audit /path/to/capture.parquet\n</code></pre> <p>What you get: <pre><code>================================================================================\n  Daily Security Audit Report\n  Generated: 2025-10-15 14:30:00\n================================================================================\n\nFINDINGS SUMMARY:\n  \ud83d\udd34 Critical: 1\n  \ud83d\udfe0 High:     3\n  \ud83d\udfe1 Medium:   5\n  \ud83d\udd35 Low:      2\n\nDETAILED FINDINGS:\n\ud83d\udd34 [CRITICAL] SYN Flood\n   Detected 5 potential SYN flood attacks\n\n\ud83d\udfe0 [HIGH] Port Scan\n   Detected 12 potential port scanning sources\n\n[... more findings ...]\n</code></pre></p> <p>Example with options: <pre><code># Custom business hours and export to file\nuv run python -m preprocessing.main daily-audit capture.parquet \\\n  --business-hours 8-18 \\\n  --export daily_report.json\n</code></pre></p>"},{"location":"ml/quickstart/#2-investigate-specific-ip","title":"2. Investigate Specific IP","text":"<p>What it does: Shows everything a specific IP did in your network</p> <p>When to use: You found a suspicious IP and want to know what it's doing</p> <pre><code>uv run python -m preprocessing.main investigate-ip capture.parquet 192.168.1.100\n</code></pre> <p>What you get: - All packets sent/received - Who it communicated with - Protocol breakdown - Attack patterns (if any) - Threat indicators</p>"},{"location":"ml/quickstart/#3-threat-hunting","title":"3. Threat Hunting","text":"<p>What it does: Proactively searches for specific attack patterns</p> <p>When to use: You suspect an attack but don't know where to look</p> <pre><code># Hunt for C2 (Command &amp; Control) communication\nuv run python -m preprocessing.main threat-hunt capture.parquet --type c2\n\n# Hunt for data theft\nuv run python -m preprocessing.main threat-hunt capture.parquet --type data-theft\n\n# Hunt for lateral movement\nuv run python -m preprocessing.main threat-hunt capture.parquet --type lateral\n\n# Run all hunts\nuv run python -m preprocessing.main threat-hunt capture.parquet --type all\n</code></pre>"},{"location":"ml/quickstart/#python-api-for-scripts","title":"Python API (For Scripts)","text":"<p>If you want to integrate into your own scripts:</p>"},{"location":"ml/quickstart/#daily-audit-in-python","title":"Daily Audit in Python","text":"<pre><code>from network_security_suite.ml.preprocessing.workflows import DailyAudit\n\n# Run audit\naudit = DailyAudit(\"capture.parquet\")\nreport = audit.run()\n\n# Show summary\nprint(report.summary())\n\n# Save to file\nreport.to_json(\"report.json\")\n\n# Check severity programmatically\nif report.severity_counts[\"critical\"] &gt; 0:\n    send_alert(\"Critical security findings!\")\n</code></pre>"},{"location":"ml/quickstart/#ip-investigation-in-python","title":"IP Investigation in Python","text":"<pre><code>from network_security_suite.ml.preprocessing.workflows import IPInvestigation\n\n# Investigate IP\ninv = IPInvestigation(\"capture.parquet\", ip=\"192.168.1.100\")\nreport = inv.run()\n\nprint(report.summary())\n</code></pre>"},{"location":"ml/quickstart/#threat-hunting-in-python","title":"Threat Hunting in Python","text":"<pre><code>from network_security_suite.ml.preprocessing.workflows import ThreatHunting\n\nhunter = ThreatHunting(\"capture.parquet\")\n\n# Hunt for C2\nc2_report = hunter.hunt_for_c2()\nprint(c2_report.summary())\n\n# Hunt for data theft\ntheft_report = hunter.hunt_for_data_theft()\nprint(theft_report.summary())\n\n# Hunt for lateral movement\nlateral_report = hunter.hunt_for_lateral_movement()\nprint(lateral_report.summary())\n</code></pre>"},{"location":"ml/quickstart/#common-questions","title":"Common Questions","text":""},{"location":"ml/quickstart/#q-what-checks-does-daily-audit-run","title":"Q: What checks does Daily Audit run?","text":"<p>A: It checks for: - \u2705 Port scanning - \u2705 SYN flood attacks - \u2705 UDP flood attacks - \u2705 DNS tunneling - \u2705 DGA domains (malware communication) - \u2705 ARP spoofing - \u2705 ICMP attacks - \u2705 Beaconing (C2 communication) - \u2705 Data exfiltration - \u2705 Off-hours activity - \u2705 Failed connections - \u2705 Suspicious IP behavior - \u2705 Top bandwidth consumers - \u2705 And more...</p>"},{"location":"ml/quickstart/#q-how-long-does-it-take","title":"Q: How long does it take?","text":"<p>A: Depends on file size: - Small file (&lt; 100K packets): ~5 seconds - Medium file (1M packets): ~30 seconds - Large file (10M+ packets): ~2-5 minutes</p> <p>Use <code>--lazy</code> flag for faster processing on large files.</p>"},{"location":"ml/quickstart/#q-what-format-should-my-parquet-file-be","title":"Q: What format should my parquet file be?","text":"<p>A: It should be the output from your network sniffer with columns like: - <code>timestamp</code> - <code>source_ip</code>, <code>destination_ip</code> - <code>source_port</code>, <code>destination_port</code> - <code>protocol</code> - Other packet metadata</p>"},{"location":"ml/quickstart/#q-can-i-automate-this","title":"Q: Can I automate this?","text":"<p>A: Yes! Add to cron:</p> <pre><code># Run daily audit every day at 2 AM\n0 2 * * * cd /path/to/project &amp;&amp; uv run python -m preprocessing.main daily-audit /data/daily_capture.parquet --export /reports/daily_$(date +\\%Y\\%m\\%d).json\n</code></pre>"},{"location":"ml/quickstart/#q-what-if-i-get-errors","title":"Q: What if I get errors?","text":"<p>A: Common fixes:</p> <ol> <li>\"Module not found\" \u2192 Run <code>uv sync</code> first</li> <li>\"File not found\" \u2192 Check your parquet file path</li> <li>\"Memory error\" \u2192 Add <code>--lazy</code> flag</li> <li>\"Empty dataframe\" \u2192 Your parquet file might not have traffic data</li> </ol>"},{"location":"ml/quickstart/#integration-with-your-workflow","title":"Integration with Your Workflow","text":""},{"location":"ml/quickstart/#after-sniffer-captures-data","title":"After Sniffer Captures Data","text":"<pre><code># In your sniffer script, after saving to parquet:\nfrom network_security_suite.ml.preprocessing.workflows import DailyAudit\n\n# Analyze what was just captured\naudit = DailyAudit(\"latest_capture.parquet\", lazy_load=True)\nreport = audit.run()\n\n# Alert on critical findings\nif report.severity_counts[\"critical\"] &gt; 0:\n    send_alert_email(report.summary())\n\n# Save for historical analysis\nreport.to_json(f\"reports/{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\")\n</code></pre>"},{"location":"ml/quickstart/#next-steps","title":"Next Steps","text":"<p>Once you're comfortable with workflows, you can:</p> <ol> <li>Use the CLI for detailed analysis - See <code>USAGE.md</code></li> <li>Build custom workflows - See <code>examples/</code> directory</li> <li>Access individual analyzers - See <code>TODO.md</code> for all available methods</li> </ol>"},{"location":"ml/quickstart/#real-world-example","title":"Real-World Example","text":"<p>Scenario: You run a small network and want to check for attacks daily.</p> <p>Solution:</p> <ol> <li> <p>Your sniffer captures traffic all day \u2192 saves to <code>capture_20251015.parquet</code></p> </li> <li> <p>At night, run:    <pre><code>uv run python -m preprocessing.main daily-audit capture_20251015.parquet \\\n  --export reports/audit_20251015.json\n</code></pre></p> </li> <li> <p>Next morning, check the report:    <pre><code>cat reports/audit_20251015.json | jq '.severity_counts'\n</code></pre></p> </li> <li> <p>If there are critical findings, investigate:    <pre><code># Check which IP is problematic (from the report)\nuv run python -m preprocessing.main investigate-ip capture_20251015.parquet 10.0.0.50\n</code></pre></p> </li> <li> <p>Done! You now know if your network was attacked and by whom.</p> </li> </ol>"},{"location":"ml/quickstart/#summary","title":"Summary","text":"<p>For daily security checks: Use <code>daily-audit</code> For investigating specific IPs: Use <code>investigate-ip</code> For hunting specific threats: Use <code>threat-hunt</code></p> <p>All workflows automatically generate reports and can export to JSON for further processing.</p>"},{"location":"ml/api/","title":"API Reference","text":"<p>Complete API reference for the ML Network Analysis Module.</p>"},{"location":"ml/api/#core-classes","title":"Core Classes","text":""},{"location":"ml/api/#networkparquetanalysis","title":"NetworkParquetAnalysis","text":"<p>Main entry point for all analysis operations.</p> <p> Full Reference</p>"},{"location":"ml/api/#workflows","title":"Workflows","text":"<p>High-level workflow classes for common tasks.</p> <p> Workflows API</p>"},{"location":"ml/api/#analyzers","title":"Analyzers","text":"<p>Protocol-specific analyzers:</p> <ul> <li>TCP Analyzer - TCP connection and flag analysis</li> <li>UDP Analyzer - UDP flow and flood detection  </li> <li>DNS Analyzer - DNS query and threat detection</li> <li>IP Analyzer - IP-level traffic analysis</li> <li>Flow Analyzer - Flow-based behavioral analysis</li> <li>ARP Analyzer - ARP spoofing detection</li> <li>ICMP Analyzer - ICMP ping and tunneling</li> <li>Anomaly Analyzer - Cross-protocol attack detection</li> </ul>"},{"location":"ml/api/#utilities","title":"Utilities","text":"<ul> <li>Utils - Helper functions</li> <li>Errors - Custom exceptions</li> </ul>"},{"location":"ml/api/#quick-links","title":"Quick Links","text":"<ul> <li>Architecture</li> <li>User Guide</li> <li>Examples</li> </ul>"},{"location":"ml/development/changelog/","title":"Changelog","text":"<p>All notable changes to the ML Network Analysis Module.</p>"},{"location":"ml/development/changelog/#current-2025-10-15","title":"[Current] - 2025-10-15","text":""},{"location":"ml/development/changelog/#added","title":"Added","text":"<ul> <li>\u2728 Workflows Module: High-level workflows for common tasks</li> <li><code>DailyAudit</code>: Automated security audit with 15+ checks</li> <li><code>IPInvestigation</code>: Deep dive into specific IP behavior</li> <li><code>ThreatHunting</code>: Proactive threat hunting (C2, data theft, lateral movement)</li> <li> <p><code>WorkflowReport</code>: Unified reporting with severity ratings</p> </li> <li> <p>\ud83d\udcda Documentation: Complete MkDocs Material documentation</p> </li> <li>Architecture guide</li> <li>User guide with workflows</li> <li>API reference</li> <li> <p>Examples and tutorials</p> </li> <li> <p>\ud83d\udee0\ufe0f CLI Enhancements: New commands</p> </li> <li><code>daily-audit</code>: Run automated security audit</li> <li><code>investigate-ip</code>: Investigate specific IP</li> <li><code>threat-hunt</code>: Hunt for specific threats</li> </ul>"},{"location":"ml/development/changelog/#improved","title":"Improved","text":"<ul> <li>\ud83d\udcdd Better error messages and logging</li> <li>\ud83c\udfa8 Human-readable report formatting with emoji severity indicators</li> <li>\ud83d\udc1b Fixed Unicode encoding issue in logger.py</li> </ul>"},{"location":"ml/development/changelog/#previous-2025-10-14","title":"[Previous] - 2025-10-14","text":""},{"location":"ml/development/changelog/#added_1","title":"Added","text":"<ul> <li>\u2705 8 Specialized Analyzers: All completed (~2,400 lines)</li> <li>TCPAnalyzer (387 lines)</li> <li>UDPAnalyzer (205 lines)</li> <li>DNSAnalyzer (282 lines)</li> <li>ARPAnalyzer (225 lines)</li> <li>ICMPAnalyzer (243 lines)</li> <li>FlowAnalyzer (357 lines)</li> <li>IPAnalyzer (412 lines)</li> <li> <p>AnomalyAnalyzer (336 lines)</p> </li> <li> <p>\ud83d\udcca NetworkParquetAnalysis: Base class with core functionality</p> </li> <li>Protocol filtering</li> <li>IP information lookup</li> <li>Timestamp queries</li> <li>Behavioral summaries</li> </ul>"},{"location":"ml/development/changelog/#changed","title":"Changed","text":"<ul> <li>\ud83c\udfd7\ufe0f Reorganized ML module structure</li> <li>\ud83d\udce6 Migrated to <code>uv</code> for dependency management</li> <li>\ud83d\udd27 Enhanced sniffer configuration system</li> </ul>"},{"location":"ml/development/changelog/#roadmap","title":"Roadmap","text":""},{"location":"ml/development/changelog/#planned-features","title":"Planned Features","text":""},{"location":"ml/development/changelog/#short-term-next-2-weeks","title":"Short-term (Next 2 weeks)","text":"<ul> <li> Unit tests for all analyzers</li> <li> Integration tests with real data</li> <li> Performance benchmarking</li> <li> Utility functions (utils.py)</li> </ul>"},{"location":"ml/development/changelog/#medium-term-next-month","title":"Medium-term (Next month)","text":"<ul> <li> ML model integration</li> <li> Real-time analysis capabilities</li> <li> Advanced visualization tools</li> <li> Configuration file support (config.yaml)</li> </ul>"},{"location":"ml/development/changelog/#long-term-future","title":"Long-term (Future)","text":"<ul> <li> Streaming analysis</li> <li> Distributed processing (Spark/Dask)</li> <li> REST API</li> <li> Web dashboard</li> <li> Threat intelligence integration</li> </ul>"},{"location":"ml/development/changelog/#breaking-changes","title":"Breaking Changes","text":"<p>None yet - initial release</p>"},{"location":"ml/development/changelog/#migration-guide","title":"Migration Guide","text":""},{"location":"ml/development/changelog/#from-old-analysis-code","title":"From Old Analysis Code","text":"<p>If you were using individual analyzers:</p> <p>Old way: <pre><code>analysis = NetworkParquetAnalysis(\"capture.parquet\")\nport_scans = analysis.anomaly.detect_port_scanning(...)\nsyn_floods = analysis.anomaly.detect_syn_flood(...)\n# ... many more calls\n</code></pre></p> <p>New way (recommended): <pre><code>audit = DailyAudit(\"capture.parquet\")\nreport = audit.run()  # Automatically runs all checks\n</code></pre></p> <p>Low-level analyzer access still works the same way.</p>"},{"location":"ml/user-guide/getting-started/","title":"Getting Started","text":"<p>This guide will get you from zero to analyzing network traffic in 5 minutes.</p>"},{"location":"ml/user-guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>Network capture in Parquet format</li> <li>UV or pip installed</li> </ul>"},{"location":"ml/user-guide/getting-started/#installation","title":"Installation","text":"<pre><code># Navigate to project\ncd /path/to/netguard\n\n# Install dependencies\nuv sync\n</code></pre> <p>See full installation guide \u2192</p>"},{"location":"ml/user-guide/getting-started/#your-first-analysis","title":"Your First Analysis","text":""},{"location":"ml/user-guide/getting-started/#step-1-prepare-your-data","title":"Step 1: Prepare Your Data","text":"<p>You need a Parquet file containing network captures. This typically comes from your packet sniffer.</p> <p>Expected columns: - <code>timestamp</code> - <code>source_ip</code>, <code>destination_ip</code> - <code>source_port</code>, <code>destination_port</code> - <code>protocol</code> - Other packet metadata</p>"},{"location":"ml/user-guide/getting-started/#step-2-run-daily-audit","title":"Step 2: Run Daily Audit","text":"<pre><code>uv run python -m preprocessing.main daily-audit your_capture.parquet\n</code></pre> <p>You'll see a report like:</p> <pre><code>==============================================================================\n  Daily Security Audit Report\n================================================================================\n\nFINDINGS SUMMARY:\n  \ud83d\udd34 Critical: 0\n  \ud83d\udfe0 High:     2\n  \ud83d\udfe1 Medium:   5\n  \ud83d\udd35 Low:      3\n  \u26aa Info:     8\n\n\u2713 Analysis complete\n</code></pre>"},{"location":"ml/user-guide/getting-started/#step-3-investigate-findings","title":"Step 3: Investigate Findings","text":"<p>If the audit found something suspicious, investigate:</p> <pre><code># Investigate a specific IP from the report\nuv run python -m preprocessing.main investigate-ip your_capture.parquet 192.168.1.100\n</code></pre>"},{"location":"ml/user-guide/getting-started/#whats-next","title":"What's Next?","text":"<ul> <li>Learn the workflows: Understand the three main workflows</li> <li>CLI Reference: Explore all commands</li> <li>Examples: See real-world usage</li> </ul>"},{"location":"ml/user-guide/getting-started/#common-workflows","title":"Common Workflows","text":""},{"location":"ml/user-guide/getting-started/#daily-security-monitoring","title":"Daily Security Monitoring","text":"<pre><code># 1. Your sniffer captures traffic \u2192 saves to daily_capture.parquet\n# 2. Run audit\nuv run python -m preprocessing.main daily-audit daily_capture.parquet --export daily_report.json\n\n# 3. Check for critical findings\ncat daily_report.json | jq '.severity_counts.critical'\n</code></pre>"},{"location":"ml/user-guide/getting-started/#incident-investigation","title":"Incident Investigation","text":"<pre><code># 1. Find suspicious IP from alerts\n# 2. Deep dive investigation\nuv run python -m preprocessing.main investigate-ip capture.parquet 10.0.0.50\n\n# 3. Hunt for related threats\nuv run python -m preprocessing.main threat-hunt capture.parquet --type lateral\n</code></pre>"},{"location":"ml/user-guide/getting-started/#ml-feature-extraction","title":"ML Feature Extraction","text":"<pre><code>from network_security_suite.ml.preprocessing.parquet_analysis import NetworkParquetAnalysis\n\n# Load data\nanalysis = NetworkParquetAnalysis(\"capture.parquet\")\n\n# Extract behavioral features\nfeatures = analysis.behavioral_summary(\n    time_window=\"1m\",\n    group_by_col=\"source_ip\"\n)\n\n# Export for ML training\nfeatures.write_parquet(\"ml_features.parquet\")\n</code></pre>"},{"location":"ml/user-guide/workflows/","title":"Workflows Overview","text":"<p>Workflows are high-level interfaces that simplify common network analysis tasks. Instead of manually calling individual analyzer methods, workflows orchestrate multiple analyzers to solve specific problems.</p>"},{"location":"ml/user-guide/workflows/#the-three-main-workflows","title":"The Three Main Workflows","text":""},{"location":"ml/user-guide/workflows/#1-daily-security-audit","title":"1. Daily Security Audit","text":"<p>Purpose: Automated comprehensive security check</p> <p>Use When: - Running daily/periodic security scans - After capturing network traffic - Monitoring for threats automatically</p> <p>What It Does: - Runs 15+ security checks automatically - Detects port scans, floods, tunneling, spoofing - Generates severity-rated reports (Critical/High/Medium/Low) - Returns exit codes for automation</p> <p>Learn more \u2192</p>"},{"location":"ml/user-guide/workflows/#2-ip-investigation","title":"2. IP Investigation","text":"<p>Purpose: Deep dive into specific IP behavior</p> <p>Use When: - Investigating suspicious IP addresses - Incident response - Understanding what a host is doing</p> <p>What It Does: - Shows all activity for an IP - Analyzes traffic patterns - Checks for attack indicators - Generates investigation report</p> <p>Learn more \u2192</p>"},{"location":"ml/user-guide/workflows/#3-threat-hunting","title":"3. Threat Hunting","text":"<p>Purpose: Proactive threat detection</p> <p>Use When: - Searching for advanced threats - Looking for C2 communication - Detecting data exfiltration - Finding lateral movement</p> <p>What It Does: - Hunts for C2 beaconing - Detects data theft patterns - Finds lateral movement indicators - Targeted threat searches</p> <p>Learn more \u2192</p>"},{"location":"ml/user-guide/workflows/#why-use-workflows","title":"Why Use Workflows?","text":""},{"location":"ml/user-guide/workflows/#without-workflows-complex","title":"Without Workflows (Complex)","text":"<pre><code># Manual approach - lots of boilerplate\nanalysis = NetworkParquetAnalysis(\"capture.parquet\")\n\n# Port scanning\nport_scans = analysis.anomaly.detect_port_scanning(threshold=100, time_window=\"1m\")\n\n# SYN floods\nsyn_floods = analysis.anomaly.detect_syn_flood(threshold=1000, time_window=\"1m\")\n\n# DNS tunneling\ndns_tunneling = analysis.dns.detect_dns_tunneling(length_threshold=100)\n\n# DGA domains\ndga = analysis.dns.identify_dga_domains()\n\n# ... 10+ more checks ...\n\n# Manually aggregate results\nfindings = []\nif len(port_scans) &gt; 0:\n    findings.append({\"severity\": \"high\", \"type\": \"port_scan\", \"count\": len(port_scans)})\n# ... etc for each check\n\n# Format report manually\nprint(json.dumps(findings, indent=2))\n</code></pre>"},{"location":"ml/user-guide/workflows/#with-workflows-simple","title":"With Workflows (Simple)","text":"<pre><code># Workflow approach - handles everything\naudit = DailyAudit(\"capture.parquet\")\nreport = audit.run()\n\n# Human-readable report\nprint(report.summary())\n\n# Or export to JSON\nreport.to_json(\"audit.json\")\n</code></pre>"},{"location":"ml/user-guide/workflows/#workflow-vs-analyzer","title":"Workflow vs Analyzer","text":"Aspect Workflows Analyzers Level High-level Low-level Purpose Solve complete tasks Provide specific analysis Complexity Simple to use More control, more complex Use Case 90% of tasks Custom/advanced analysis Output Formatted reports Raw DataFrames Examples DailyAudit, IPInvestigation TCPAnalyzer, DNSAnalyzer"},{"location":"ml/user-guide/workflows/#when-to-use-each","title":"When to Use Each","text":""},{"location":"ml/user-guide/workflows/#use-workflows-when","title":"Use Workflows When:","text":"<ul> <li>\u2705 You want quick results</li> <li>\u2705 Running routine checks</li> <li>\u2705 Automating security audits</li> <li>\u2705 You need formatted reports</li> <li>\u2705 Investigating common scenarios</li> </ul>"},{"location":"ml/user-guide/workflows/#use-analyzers-when","title":"Use Analyzers When:","text":"<ul> <li>\u2705 Building custom analysis</li> <li>\u2705 Need fine-grained control</li> <li>\u2705 Researching specific protocols</li> <li>\u2705 Creating new workflows</li> <li>\u2705 ML feature extraction</li> </ul>"},{"location":"ml/user-guide/workflows/#creating-custom-workflows","title":"Creating Custom Workflows","text":"<p>You can create your own workflows by extending the base pattern:</p> <pre><code>from network_security_suite.ml.preprocessing.workflows import WorkflowReport\nfrom network_security_suite.ml.preprocessing.parquet_analysis import NetworkParquetAnalysis\n\nclass ComplianceAudit:\n    \"\"\"Custom workflow for compliance checking.\"\"\"\n\n    def __init__(self, parquet_file):\n        self.analysis = NetworkParquetAnalysis(parquet_file)\n        self.logger = get_logger()\n\n    def run(self):\n        report = WorkflowReport(\"Compliance Audit Report\")\n\n        # Your custom checks\n        self._check_encryption(report)\n        self._check_allowed_protocols(report)\n        self._check_authorized_ips(report)\n\n        return report\n\n    def _check_encryption(self, report):\n        # Find unencrypted traffic\n        unencrypted = self.analysis.df.filter(\n            pl.col(\"port\").is_in([80, 21, 23])  # HTTP, FTP, Telnet\n        )\n\n        if len(unencrypted) &gt; 0:\n            report.add_finding(\n                severity=\"high\",\n                category=\"Unencrypted Traffic\",\n                description=f\"Found {len(unencrypted)} unencrypted packets\"\n            )\n\n    # ... more methods ...\n</code></pre> <p>See examples \u2192</p>"},{"location":"ml/user-guide/workflows/#cli-vs-python-api","title":"CLI vs Python API","text":"<p>All workflows can be used via CLI or Python API:</p> CLIPython API <pre><code># Daily audit\nuv run python -m preprocessing.main daily-audit capture.parquet\n\n# IP investigation\nuv run python -m preprocessing.main investigate-ip capture.parquet 192.168.1.100\n\n# Threat hunting\nuv run python -m preprocessing.main threat-hunt capture.parquet --type c2\n</code></pre> <pre><code>from network_security_suite.ml.preprocessing.workflows import (\n    DailyAudit,\n    IPInvestigation,\n    ThreatHunting\n)\n\n# Daily audit\naudit = DailyAudit(\"capture.parquet\")\nreport = audit.run()\n\n# IP investigation\ninv = IPInvestigation(\"capture.parquet\", ip=\"192.168.1.100\")\nreport = inv.run()\n\n# Threat hunting\nhunter = ThreatHunting(\"capture.parquet\")\nreport = hunter.hunt_for_c2()\n</code></pre>"},{"location":"ml/user-guide/workflows/#report-format","title":"Report Format","text":"<p>All workflows return <code>WorkflowReport</code> objects with:</p> <ul> <li>Title: Report name</li> <li>Timestamp: When generated</li> <li>Findings: List of security findings with severity</li> <li>Sections: Additional data sections</li> <li>Severity Counts: Count by severity level</li> </ul>"},{"location":"ml/user-guide/workflows/#example-report-structure","title":"Example Report Structure","text":"<pre><code>{\n  \"title\": \"Daily Security Audit Report\",\n  \"timestamp\": \"2025-10-15T14:30:00\",\n  \"severity_counts\": {\n    \"critical\": 1,\n    \"high\": 3,\n    \"medium\": 5,\n    \"low\": 2,\n    \"info\": 10\n  },\n  \"findings\": [\n    {\n      \"severity\": \"critical\",\n      \"category\": \"SYN Flood\",\n      \"description\": \"Detected 5 potential SYN flood attacks\",\n      \"details\": \"Affected targets: 5\",\n      \"timestamp\": \"2025-10-15T14:30:01\"\n    }\n  ]\n}\n</code></pre>"},{"location":"ml/user-guide/workflows/#next-steps","title":"Next Steps","text":"<ul> <li>Daily Security Audit \u2192</li> <li>IP Investigation \u2192</li> <li>Threat Hunting \u2192</li> <li>Custom Workflows \u2192</li> </ul>"},{"location":"models/","title":"Models Module","text":"<p>The Models module provides data structures and database schemas for packet and network data representation throughout the Network Security Suite.</p>"},{"location":"models/#overview","title":"Overview","text":"<p>This module contains Pydantic-based data models that ensure type safety and validation for all network data. It provides structured representations of network packets, protocols, and database schemas.</p>"},{"location":"models/#key-features","title":"Key Features","text":"<ul> <li>Type-Safe Data Structures: Pydantic models with full type validation</li> <li>Protocol Support: Models for various network protocols (ARP, STP, Ethernet, IP, TCP, UDP, etc.)</li> <li>Database Integration: SQLAlchemy-compatible schemas</li> <li>Serialization: Easy JSON/dict conversion</li> <li>Validation: Automatic data validation and error handling</li> </ul>"},{"location":"models/#components","title":"Components","text":""},{"location":"models/#packet-data-structures","title":"Packet Data Structures","text":"<p>The packet data structures module provides Pydantic models for different network protocols:</p> <ul> <li>EthernetPacket: Ethernet frame representation</li> <li>ARPPacket: ARP protocol packets</li> <li>STPPacket: Spanning Tree Protocol packets</li> <li>IPPacket: IP layer packets</li> <li>TCPPacket: TCP protocol packets</li> <li>UDPPacket: UDP protocol packets</li> <li>ICMPPacket: ICMP protocol packets</li> <li>DNSPacket: DNS protocol packets</li> </ul> <p>See Packet Data Structures API for details.</p>"},{"location":"models/#database-schemas","title":"Database Schemas","text":"<p>Database schema definitions for storing network data:</p> <ul> <li>PacketRecord: Base packet record schema</li> <li>FlowRecord: Network flow record schema</li> <li>AlertRecord: Security alert schema</li> </ul> <p>See Database Schemas API for details.</p>"},{"location":"models/#quick-start","title":"Quick Start","text":""},{"location":"models/#using-packet-models","title":"Using Packet Models","text":"<pre><code>from network_security_suite.models import ARPPacket, EthernetPacket\n\n# Create an ARP packet\narp_packet = ARPPacket(\n    operation=1,  # ARP Request\n    sender_mac=\"00:11:22:33:44:55\",\n    sender_ip=\"192.168.1.100\",\n    target_mac=\"00:00:00:00:00:00\",\n    target_ip=\"192.168.1.1\"\n)\n\n# Access fields\nprint(f\"Sender: {arp_packet.sender_ip}\")\nprint(f\"Target: {arp_packet.target_ip}\")\n\n# Serialize to dict\narp_dict = arp_packet.model_dump()\n\n# Serialize to JSON\narp_json = arp_packet.model_dump_json()\n</code></pre>"},{"location":"models/#creating-from-raw-data","title":"Creating from Raw Data","text":"<pre><code>from network_security_suite.models import TCPPacket\n\n# Create from dictionary\ntcp_data = {\n    \"src_port\": 443,\n    \"dst_port\": 54321,\n    \"seq\": 1000,\n    \"ack\": 2000,\n    \"flags\": \"SA\",\n    \"window\": 65535\n}\n\ntcp_packet = TCPPacket(**tcp_data)\n</code></pre>"},{"location":"models/#validation","title":"Validation","text":"<p>Models automatically validate data:</p> <pre><code>from network_security_suite.models import IPPacket\nfrom pydantic import ValidationError\n\ntry:\n    # Invalid IP address\n    ip_packet = IPPacket(\n        src_ip=\"999.999.999.999\",\n        dst_ip=\"192.168.1.1\"\n    )\nexcept ValidationError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"models/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Raw Packet Data] --&gt; B[Packet Models]\n    B --&gt; C{Protocol Type}\n    C --&gt;|Layer 2| D[EthernetPacket, ARPPacket, STPPacket]\n    C --&gt;|Layer 3| E[IPPacket, ICMPPacket]\n    C --&gt;|Layer 4| F[TCPPacket, UDPPacket]\n    C --&gt;|Application| G[DNSPacket, HTTPPacket]\n    B --&gt; H[Database Schemas]\n    H --&gt; I[Storage/Retrieval]</code></pre>"},{"location":"models/#use-cases","title":"Use Cases","text":""},{"location":"models/#data-validation","title":"Data Validation","text":"<p>Ensure all network data conforms to expected schemas:</p> <pre><code>from network_security_suite.models import TCPPacket\n\ndef process_tcp_packet(packet_data):\n    try:\n        packet = TCPPacket(**packet_data)\n        # Process validated packet\n        return packet\n    except ValidationError as e:\n        # Handle invalid data\n        log_error(f\"Invalid packet: {e}\")\n        return None\n</code></pre>"},{"location":"models/#database-storage","title":"Database Storage","text":"<p>Store packets in database with proper schemas:</p> <pre><code>from network_security_suite.models import PacketRecord\nfrom sqlalchemy.orm import Session\n\ndef save_packet(session: Session, packet: EthernetPacket):\n    record = PacketRecord(\n        timestamp=packet.timestamp,\n        src_mac=packet.src_mac,\n        dst_mac=packet.dst_mac,\n        protocol=packet.protocol\n    )\n    session.add(record)\n    session.commit()\n</code></pre>"},{"location":"models/#api-serialization","title":"API Serialization","text":"<p>Easy serialization for API responses:</p> <pre><code>from network_security_suite.models import ARPPacket\n\narp_packet = ARPPacket(...)\n\n# Convert to JSON for API response\nreturn arp_packet.model_dump_json()\n</code></pre>"},{"location":"models/#model-hierarchy","title":"Model Hierarchy","text":""},{"location":"models/#base-models","title":"Base Models","text":"<p>All packet models inherit from base classes:</p> <pre><code>NetworkPacket (Base)\n\u251c\u2500\u2500 Layer2Packet\n\u2502   \u251c\u2500\u2500 EthernetPacket\n\u2502   \u251c\u2500\u2500 ARPPacket\n\u2502   \u2514\u2500\u2500 STPPacket\n\u251c\u2500\u2500 Layer3Packet\n\u2502   \u251c\u2500\u2500 IPPacket\n\u2502   \u2514\u2500\u2500 ICMPPacket\n\u2514\u2500\u2500 Layer4Packet\n    \u251c\u2500\u2500 TCPPacket\n    \u2514\u2500\u2500 UDPPacket\n</code></pre>"},{"location":"models/#best-practices","title":"Best Practices","text":""},{"location":"models/#1-always-validate-input","title":"1. Always Validate Input","text":"<pre><code>def process_packet(raw_data: dict):\n    try:\n        packet = EthernetPacket(**raw_data)\n        # Process packet\n    except ValidationError:\n        # Handle invalid data\n        pass\n</code></pre>"},{"location":"models/#2-use-type-hints","title":"2. Use Type Hints","text":"<pre><code>from network_security_suite.models import TCPPacket\n\ndef analyze_tcp(packet: TCPPacket) -&gt; dict:\n    \"\"\"Type hints ensure correct usage\"\"\"\n    return {\n        \"syn\": \"S\" in packet.flags,\n        \"ack\": \"A\" in packet.flags\n    }\n</code></pre>"},{"location":"models/#3-leverage-pydantic-features","title":"3. Leverage Pydantic Features","text":"<pre><code>from network_security_suite.models import IPPacket\n\n# Use validators\npacket = IPPacket(\n    src_ip=\"192.168.1.1\",\n    dst_ip=\"10.0.0.1\"\n)\n\n# Access validated data\nprint(packet.model_dump())\n</code></pre>"},{"location":"models/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Validation Overhead: Pydantic validation has minimal overhead</li> <li>Serialization: Use <code>model_dump()</code> for dicts, <code>model_dump_json()</code> for JSON</li> <li>Memory: Models are lightweight and memory-efficient</li> <li>Caching: Consider caching validated models for frequently used data</li> </ul>"},{"location":"models/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide: Step-by-step tutorial</li> <li>Data Structures Guide: Detailed model documentation</li> <li>API Reference: Complete API documentation</li> </ul>"},{"location":"models/data-structures/","title":"Data Structures Guide","text":"<p>Detailed guide to the data structures used in the Network Security Suite.</p>"},{"location":"models/data-structures/#model-hierarchy","title":"Model Hierarchy","text":"<pre><code>NetworkPacket (Base)\n\u251c\u2500\u2500 Layer2Packet\n\u2502   \u251c\u2500\u2500 EthernetPacket\n\u2502   \u251c\u2500\u2500 ARPPacket\n\u2502   \u2514\u2500\u2500 STPPacket\n\u251c\u2500\u2500 Layer3Packet\n\u2502   \u251c\u2500\u2500 IPPacket\n\u2502   \u2514\u2500\u2500 ICMPPacket\n\u2514\u2500\u2500 Layer4Packet\n    \u251c\u2500\u2500 TCPPacket\n    \u2514\u2500\u2500 UDPPacket\n</code></pre>"},{"location":"models/data-structures/#layer-2-models","title":"Layer 2 Models","text":""},{"location":"models/data-structures/#ethernetpacket","title":"EthernetPacket","text":"<p>Represents an Ethernet frame (Layer 2).</p> <p>Fields: - <code>src_mac</code>: Source MAC address - <code>dst_mac</code>: Destination MAC address - <code>ethertype</code>: EtherType (e.g., 0x0800 for IPv4) - <code>payload</code>: Frame payload - <code>timestamp</code>: Capture timestamp</p> <p>Example: <pre><code>from network_security_suite.models import EthernetPacket\n\nethernet = EthernetPacket(\n    src_mac=\"00:11:22:33:44:55\",\n    dst_mac=\"66:77:88:99:aa:bb\",\n    ethertype=0x0800\n)\n</code></pre></p>"},{"location":"models/data-structures/#arppacket","title":"ARPPacket","text":"<p>Represents an ARP (Address Resolution Protocol) packet.</p> <p>Fields: - <code>operation</code>: 1 (request) or 2 (reply) - <code>sender_mac</code>: Sender hardware address - <code>sender_ip</code>: Sender protocol address - <code>target_mac</code>: Target hardware address - <code>target_ip</code>: Target protocol address</p> <p>Example: <pre><code>from network_security_suite.models import ARPPacket\n\narp = ARPPacket(\n    operation=1,\n    sender_mac=\"00:11:22:33:44:55\",\n    sender_ip=\"192.168.1.100\",\n    target_mac=\"00:00:00:00:00:00\",\n    target_ip=\"192.168.1.1\"\n)\n</code></pre></p>"},{"location":"models/data-structures/#stppacket","title":"STPPacket","text":"<p>Represents a Spanning Tree Protocol packet.</p> <p>Fields: - <code>protocol_id</code>: Protocol identifier - <code>version</code>: STP version - <code>message_type</code>: BPDU type - <code>flags</code>: STP flags - <code>root_id</code>: Root bridge ID - <code>bridge_id</code>: Bridge ID - <code>port_id</code>: Port identifier</p>"},{"location":"models/data-structures/#layer-3-models","title":"Layer 3 Models","text":""},{"location":"models/data-structures/#ippacket","title":"IPPacket","text":"<p>Represents an IP packet (Layer 3).</p> <p>Fields: - <code>version</code>: IP version (4 or 6) - <code>src_ip</code>: Source IP address - <code>dst_ip</code>: Destination IP address - <code>protocol</code>: Protocol number (6=TCP, 17=UDP) - <code>ttl</code>: Time to live - <code>length</code>: Packet length</p> <p>Example: <pre><code>from network_security_suite.models import IPPacket\n\nip = IPPacket(\n    version=4,\n    src_ip=\"192.168.1.100\",\n    dst_ip=\"10.0.0.1\",\n    protocol=6,  # TCP\n    ttl=64\n)\n</code></pre></p>"},{"location":"models/data-structures/#icmppacket","title":"ICMPPacket","text":"<p>Represents an ICMP packet.</p> <p>Fields: - <code>type</code>: ICMP type (e.g., 8=echo request, 0=echo reply) - <code>code</code>: ICMP code - <code>checksum</code>: Checksum - <code>identifier</code>: Identifier (for echo) - <code>sequence</code>: Sequence number</p>"},{"location":"models/data-structures/#layer-4-models","title":"Layer 4 Models","text":""},{"location":"models/data-structures/#tcppacket","title":"TCPPacket","text":"<p>Represents a TCP packet (Layer 4).</p> <p>Fields: - <code>src_port</code>: Source port - <code>dst_port</code>: Destination port - <code>seq</code>: Sequence number - <code>ack</code>: Acknowledgment number - <code>flags</code>: TCP flags (S, A, F, R, P, U) - <code>window</code>: Window size - <code>checksum</code>: Checksum - <code>urgent_ptr</code>: Urgent pointer</p> <p>Example: <pre><code>from network_security_suite.models import TCPPacket\n\ntcp = TCPPacket(\n    src_port=443,\n    dst_port=54321,\n    seq=1000,\n    ack=2000,\n    flags=\"SA\",  # SYN-ACK\n    window=65535\n)\n</code></pre></p> <p>TCP Flags: - <code>S</code>: SYN (Synchronize) - <code>A</code>: ACK (Acknowledgment) - <code>F</code>: FIN (Finish) - <code>R</code>: RST (Reset) - <code>P</code>: PSH (Push) - <code>U</code>: URG (Urgent)</p>"},{"location":"models/data-structures/#udppacket","title":"UDPPacket","text":"<p>Represents a UDP packet.</p> <p>Fields: - <code>src_port</code>: Source port - <code>dst_port</code>: Destination port - <code>length</code>: Length - <code>checksum</code>: Checksum - <code>payload</code>: Data payload</p> <p>Example: <pre><code>from network_security_suite.models import UDPPacket\n\nudp = UDPPacket(\n    src_port=53,\n    dst_port=12345,\n    length=100,\n    payload=b\"DNS data\"\n)\n</code></pre></p>"},{"location":"models/data-structures/#application-layer-models","title":"Application Layer Models","text":""},{"location":"models/data-structures/#dnspacket","title":"DNSPacket","text":"<p>Represents a DNS packet.</p> <p>Fields: - <code>transaction_id</code>: Transaction ID - <code>flags</code>: DNS flags - <code>questions</code>: DNS questions - <code>answers</code>: DNS answers - <code>authority</code>: Authority records - <code>additional</code>: Additional records</p>"},{"location":"models/data-structures/#database-models","title":"Database Models","text":""},{"location":"models/data-structures/#packetrecord","title":"PacketRecord","text":"<p>Database schema for storing packet records.</p> <p>Fields: - <code>id</code>: Primary key - <code>timestamp</code>: Capture timestamp - <code>src_mac</code>: Source MAC - <code>dst_mac</code>: Destination MAC - <code>src_ip</code>: Source IP - <code>dst_ip</code>: Destination IP - <code>protocol</code>: Protocol - <code>length</code>: Packet length - <code>raw_data</code>: Raw packet data</p>"},{"location":"models/data-structures/#flowrecord","title":"FlowRecord","text":"<p>Database schema for network flows.</p> <p>Fields: - <code>id</code>: Primary key - <code>start_time</code>: Flow start time - <code>end_time</code>: Flow end time - <code>src_ip</code>: Source IP - <code>dst_ip</code>: Destination IP - <code>src_port</code>: Source port - <code>dst_port</code>: Destination port - <code>protocol</code>: Protocol - <code>packet_count</code>: Number of packets - <code>byte_count</code>: Total bytes</p>"},{"location":"models/data-structures/#model-features","title":"Model Features","text":""},{"location":"models/data-structures/#serialization","title":"Serialization","text":"<p>All models support serialization to dict and JSON:</p> <pre><code># To dictionary\npacket_dict = packet.model_dump()\n\n# To JSON\npacket_json = packet.model_dump_json()\n\n# To JSON with formatting\npacket_json = packet.model_dump_json(indent=2)\n</code></pre>"},{"location":"models/data-structures/#validation","title":"Validation","text":"<p>All models include automatic validation:</p> <pre><code>from pydantic import ValidationError\n\ntry:\n    packet = TCPPacket(src_port=999999)  # Invalid port\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"models/data-structures/#immutability-optional","title":"Immutability (Optional)","text":"<p>Models can be made immutable using Pydantic's frozen feature:</p> <pre><code>from pydantic import BaseModel\n\nclass ImmutablePacket(BaseModel):\n    model_config = {\"frozen\": True}\n\n# packet.src_port = 80  # Raises error\n</code></pre>"},{"location":"models/data-structures/#best-practices","title":"Best Practices","text":""},{"location":"models/data-structures/#use-appropriate-models","title":"Use Appropriate Models","text":"<p>Choose the right model for your data layer:</p> <pre><code># Layer 2 analysis\nethernet = EthernetPacket(...)\n\n# Layer 3 analysis\nip = IPPacket(...)\n\n# Layer 4 analysis\ntcp = TCPPacket(...)\n</code></pre>"},{"location":"models/data-structures/#validate-early","title":"Validate Early","text":"<p>Validate data as soon as possible:</p> <pre><code>def process_raw_packet(raw_data: dict):\n    try:\n        packet = TCPPacket(**raw_data)\n        return process_validated_packet(packet)\n    except ValidationError:\n        return handle_invalid_packet(raw_data)\n</code></pre>"},{"location":"models/data-structures/#use-type-hints","title":"Use Type Hints","text":"<p>Always use type hints for better code quality:</p> <pre><code>from network_security_suite.models import TCPPacket\n\ndef analyze(packet: TCPPacket) -&gt; dict:\n    return {\"port\": packet.src_port}\n</code></pre>"},{"location":"models/data-structures/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>API Reference</li> <li>Database Schemas</li> </ul>"},{"location":"models/getting-started/","title":"Getting Started with Models","text":"<p>This guide will help you understand and use the data models in the Network Security Suite.</p>"},{"location":"models/getting-started/#overview","title":"Overview","text":"<p>The models module provides Pydantic-based data structures for representing network packets and related data. These models ensure type safety, validation, and easy serialization.</p>"},{"location":"models/getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"models/getting-started/#creating-a-packet-model","title":"Creating a Packet Model","text":"<pre><code>from network_security_suite.models import ARPPacket\n\n# Create an ARP packet\npacket = ARPPacket(\n    operation=1,  # ARP Request\n    sender_mac=\"00:11:22:33:44:55\",\n    sender_ip=\"192.168.1.100\",\n    target_mac=\"00:00:00:00:00:00\",\n    target_ip=\"192.168.1.1\"\n)\n\nprint(f\"ARP Request from {packet.sender_ip} to {packet.target_ip}\")\n</code></pre>"},{"location":"models/getting-started/#accessing-fields","title":"Accessing Fields","text":"<pre><code># Access individual fields\nprint(packet.sender_mac)\nprint(packet.sender_ip)\nprint(packet.operation)\n\n# Check operation type\nif packet.operation == 1:\n    print(\"This is an ARP request\")\nelif packet.operation == 2:\n    print(\"This is an ARP reply\")\n</code></pre>"},{"location":"models/getting-started/#serialization","title":"Serialization","text":"<pre><code># Convert to dictionary\npacket_dict = packet.model_dump()\nprint(packet_dict)\n\n# Convert to JSON\npacket_json = packet.model_dump_json(indent=2)\nprint(packet_json)\n</code></pre>"},{"location":"models/getting-started/#working-with-different-protocols","title":"Working with Different Protocols","text":""},{"location":"models/getting-started/#ethernet-packets","title":"Ethernet Packets","text":"<pre><code>from network_security_suite.models import EthernetPacket\n\nethernet = EthernetPacket(\n    src_mac=\"00:11:22:33:44:55\",\n    dst_mac=\"66:77:88:99:aa:bb\",\n    ethertype=0x0800,  # IPv4\n    payload=b\"\\x00\\x01\\x02\\x03\"\n)\n</code></pre>"},{"location":"models/getting-started/#tcp-packets","title":"TCP Packets","text":"<pre><code>from network_security_suite.models import TCPPacket\n\ntcp = TCPPacket(\n    src_port=443,\n    dst_port=54321,\n    seq=1000,\n    ack=2000,\n    flags=\"SA\",  # SYN-ACK\n    window=65535,\n    checksum=0x1234\n)\n\n# Check flags\nif \"S\" in tcp.flags:\n    print(\"SYN flag set\")\nif \"A\" in tcp.flags:\n    print(\"ACK flag set\")\n</code></pre>"},{"location":"models/getting-started/#udp-packets","title":"UDP Packets","text":"<pre><code>from network_security_suite.models import UDPPacket\n\nudp = UDPPacket(\n    src_port=53,\n    dst_port=12345,\n    length=100,\n    checksum=0x5678,\n    payload=b\"DNS query data\"\n)\n</code></pre>"},{"location":"models/getting-started/#validation","title":"Validation","text":""},{"location":"models/getting-started/#automatic-validation","title":"Automatic Validation","text":"<p>Pydantic automatically validates data:</p> <pre><code>from network_security_suite.models import ARPPacket\nfrom pydantic import ValidationError\n\ntry:\n    # Invalid MAC address format\n    packet = ARPPacket(\n        operation=1,\n        sender_mac=\"invalid\",\n        sender_ip=\"192.168.1.1\",\n        target_mac=\"00:00:00:00:00:00\",\n        target_ip=\"192.168.1.1\"\n    )\nexcept ValidationError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"models/getting-started/#custom-validation","title":"Custom Validation","text":"<pre><code>def validate_tcp_packet(packet: TCPPacket) -&gt; bool:\n    \"\"\"Custom validation logic\"\"\"\n    # Check port ranges\n    if not (0 &lt;= packet.src_port &lt;= 65535):\n        return False\n    if not (0 &lt;= packet.dst_port &lt;= 65535):\n        return False\n\n    # Check sequence numbers\n    if packet.seq &lt; 0:\n        return False\n\n    return True\n</code></pre>"},{"location":"models/getting-started/#creating-from-raw-data","title":"Creating from Raw Data","text":""},{"location":"models/getting-started/#from-dictionary","title":"From Dictionary","text":"<pre><code>from network_security_suite.models import TCPPacket\n\nraw_data = {\n    \"src_port\": 80,\n    \"dst_port\": 54321,\n    \"seq\": 1000,\n    \"ack\": 2000,\n    \"flags\": \"PA\",\n    \"window\": 65535\n}\n\npacket = TCPPacket(**raw_data)\n</code></pre>"},{"location":"models/getting-started/#from-json","title":"From JSON","text":"<pre><code>import json\nfrom network_security_suite.models import ARPPacket\n\njson_data = '{\"operation\": 1, \"sender_mac\": \"00:11:22:33:44:55\", \"sender_ip\": \"192.168.1.1\", \"target_mac\": \"00:00:00:00:00:00\", \"target_ip\": \"192.168.1.254\"}'\n\npacket = ARPPacket(**json.loads(json_data))\n</code></pre>"},{"location":"models/getting-started/#from-captured-packets","title":"From Captured Packets","text":"<pre><code>from scapy.all import sniff\nfrom network_security_suite.models import ARPPacket\n\ndef packet_handler(scapy_packet):\n    if scapy_packet.haslayer(\"ARP\"):\n        arp = scapy_packet[\"ARP\"]\n        model = ARPPacket(\n            operation=arp.op,\n            sender_mac=arp.hwsrc,\n            sender_ip=arp.psrc,\n            target_mac=arp.hwdst,\n            target_ip=arp.pdst\n        )\n        print(model)\n\n# Capture ARP packets\nsniff(filter=\"arp\", prn=packet_handler, count=10)\n</code></pre>"},{"location":"models/getting-started/#database-integration","title":"Database Integration","text":""},{"location":"models/getting-started/#storing-models","title":"Storing Models","text":"<pre><code>from network_security_suite.models import PacketRecord\nfrom sqlalchemy.orm import Session\n\ndef save_packet(session: Session, packet: EthernetPacket):\n    record = PacketRecord(**packet.model_dump())\n    session.add(record)\n    session.commit()\n</code></pre>"},{"location":"models/getting-started/#loading-from-database","title":"Loading from Database","text":"<pre><code>def load_packet(session: Session, packet_id: int) -&gt; EthernetPacket:\n    record = session.query(PacketRecord).get(packet_id)\n    return EthernetPacket(**record.to_dict())\n</code></pre>"},{"location":"models/getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"models/getting-started/#packet-processing-pipeline","title":"Packet Processing Pipeline","text":"<pre><code>from typing import List\nfrom network_security_suite.models import TCPPacket\n\ndef process_tcp_packets(packets: List[dict]) -&gt; List[TCPPacket]:\n    \"\"\"Process raw packet data into validated models\"\"\"\n    validated = []\n    errors = []\n\n    for raw_packet in packets:\n        try:\n            packet = TCPPacket(**raw_packet)\n            validated.append(packet)\n        except ValidationError as e:\n            errors.append((raw_packet, e))\n\n    if errors:\n        log_errors(errors)\n\n    return validated\n</code></pre>"},{"location":"models/getting-started/#filtering-packets","title":"Filtering Packets","text":"<pre><code>def filter_syn_packets(packets: List[TCPPacket]) -&gt; List[TCPPacket]:\n    \"\"\"Filter for SYN packets\"\"\"\n    return [p for p in packets if \"S\" in p.flags and \"A\" not in p.flags]\n\ndef filter_by_port(packets: List[TCPPacket], port: int) -&gt; List[TCPPacket]:\n    \"\"\"Filter packets by port\"\"\"\n    return [p for p in packets if p.src_port == port or p.dst_port == port]\n</code></pre>"},{"location":"models/getting-started/#aggregating-data","title":"Aggregating Data","text":"<pre><code>from collections import Counter\n\ndef analyze_tcp_flags(packets: List[TCPPacket]) -&gt; dict:\n    \"\"\"Analyze TCP flag distribution\"\"\"\n    flag_counter = Counter()\n\n    for packet in packets:\n        for flag in packet.flags:\n            flag_counter[flag] += 1\n\n    return dict(flag_counter)\n</code></pre>"},{"location":"models/getting-started/#best-practices","title":"Best Practices","text":""},{"location":"models/getting-started/#1-always-handle-validation-errors","title":"1. Always Handle Validation Errors","text":"<pre><code>from pydantic import ValidationError\n\ntry:\n    packet = ARPPacket(**raw_data)\nexcept ValidationError as e:\n    logger.error(f\"Invalid packet data: {e}\")\n    # Handle error appropriately\n</code></pre>"},{"location":"models/getting-started/#2-use-type-hints","title":"2. Use Type Hints","text":"<pre><code>from network_security_suite.models import TCPPacket\n\ndef analyze_connection(packet: TCPPacket) -&gt; dict:\n    return {\n        \"is_syn\": \"S\" in packet.flags,\n        \"is_established\": \"A\" in packet.flags\n    }\n</code></pre>"},{"location":"models/getting-started/#3-validate-before-processing","title":"3. Validate Before Processing","text":"<pre><code>def safe_process(raw_data: dict):\n    try:\n        packet = TCPPacket(**raw_data)\n        # Process validated packet\n        return process_packet(packet)\n    except ValidationError:\n        return None\n</code></pre>"},{"location":"models/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about data structures</li> <li>See API reference</li> <li>Explore database schemas</li> </ul>"},{"location":"models/api/database-schemas/","title":"Database Schemas API Reference","text":"<p>Complete API reference for database schema definitions.</p>"},{"location":"models/api/database-schemas/#module-reference","title":"Module Reference","text":""},{"location":"models/api/database-schemas/#network_security_suite.models.database_schemas","title":"database_schemas","text":""},{"location":"models/api/database-schemas/#usage-examples","title":"Usage Examples","text":""},{"location":"models/api/database-schemas/#packetrecord","title":"PacketRecord","text":"<pre><code>from network_security_suite.models import PacketRecord\nfrom sqlalchemy.orm import Session\n\n# Create a packet record\nrecord = PacketRecord(\n    timestamp=datetime.now(),\n    src_mac=\"00:11:22:33:44:55\",\n    dst_mac=\"66:77:88:99:aa:bb\",\n    protocol=\"TCP\",\n    length=100\n)\n\n# Save to database\nsession.add(record)\nsession.commit()\n</code></pre>"},{"location":"models/api/database-schemas/#flowrecord","title":"FlowRecord","text":"<pre><code>from network_security_suite.models import FlowRecord\n\n# Create a flow record\nflow = FlowRecord(\n    start_time=datetime.now(),\n    src_ip=\"192.168.1.100\",\n    dst_ip=\"10.0.0.1\",\n    src_port=54321,\n    dst_port=443,\n    protocol=\"TCP\",\n    packet_count=100,\n    byte_count=50000\n)\n</code></pre>"},{"location":"models/api/database-schemas/#see-also","title":"See Also","text":"<ul> <li>Packet Data Structures</li> <li>Getting Started Guide</li> </ul>"},{"location":"models/api/packet-data-structures/","title":"Packet Data Structures API Reference","text":"<p>Complete API reference for packet data structure models.</p>"},{"location":"models/api/packet-data-structures/#module-reference","title":"Module Reference","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures","title":"packet_data_structures","text":"<p>Data structures for network packet representation and processing.</p> <p>This module defines Pydantic models for representing network packets and their layers, providing structured data models with validation and serialization capabilities. It includes models for various packet types (Ethernet, IP, TCP, UDP, ICMP, ARP, STP) and utilities for converting packets to different formats (JSON, pandas, polars).</p> <p>The module uses a single class hierarchy based on Pydantic models, which provides: 1. Data validation and serialization through Pydantic 2. Object-oriented interface for packet manipulation 3. Conversion utilities for different data formats (JSON, pandas, polars)</p> <p>Each packet type inherits from a base packet class and adds its specific fields and methods.</p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures-classes","title":"Classes","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.PacketLayer","title":"PacketLayer","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for a network packet layer.</p> <p>This model represents a single layer in a network packet, containing the layer name and a dictionary of fields specific to that layer.</p> ATTRIBUTE DESCRIPTION <code>layer_name</code> <p>The name of the layer (e.g., \"Ethernet\", \"IP\", \"TCP\").</p> <p> TYPE: <code>str</code> </p> <code>fields</code> <p>A dictionary of fields specific to the layer.</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.PacketLayer-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.PacketLayer.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the layer information in a human-readable format.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the layer information in a human-readable format.\n    \"\"\"\n    print(f\"Layer: {self.layer_name}\")\n    for key, value in self.fields.items():\n        print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.Packet","title":"Packet","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base Pydantic model for network packets.</p> <p>This model represents a network packet with multiple protocol layers and is used for data processing and conversion to other formats (JSON, pandas, etc.).</p> ATTRIBUTE DESCRIPTION <code>timestamp</code> <p>The timestamp when the packet was captured.</p> <p> TYPE: <code>float</code> </p> <code>layers</code> <p>List of protocol layers in the packet.</p> <p> TYPE: <code>List[PacketLayer]</code> </p> <code>raw_size</code> <p>The raw size of the packet in bytes.</p> <p> TYPE: <code>int</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.Packet-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.Packet.has_layer","title":"has_layer","text":"<pre><code>has_layer(layer_name)\n</code></pre> <p>Check if the packet has a specific layer.</p> PARAMETER DESCRIPTION <code>layer_name</code> <p>The name of the layer to check for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the packet has the specified layer, False otherwise.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def has_layer(self, layer_name: str) -&gt; bool:\n    \"\"\"\n    Check if the packet has a specific layer.\n\n    Args:\n        layer_name (str): The name of the layer to check for.\n\n    Returns:\n        bool: True if the packet has the specified layer, False otherwise.\n    \"\"\"\n    return any(layer.layer_name == layer_name for layer in self.layers)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.Packet.get_layer","title":"get_layer","text":"<pre><code>get_layer(layer_name)\n</code></pre> <p>Get a specific layer from the packet.</p> PARAMETER DESCRIPTION <code>layer_name</code> <p>The name of the layer to get.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[PacketLayer]</code> <p>Optional[PacketLayer]: The layer if found, None otherwise.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layer(self, layer_name: str) -&gt; Optional[PacketLayer]:\n    \"\"\"\n    Get a specific layer from the packet.\n\n    Args:\n        layer_name (str): The name of the layer to get.\n\n    Returns:\n        Optional[PacketLayer]: The layer if found, None otherwise.\n    \"\"\"\n    for layer in self.layers:\n        if layer.layer_name == layer_name:\n            return layer\n    return None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.Packet.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet to a JSON representation.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet to a JSON representation.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.Packet.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n    \"\"\"\n    print(\"Packet:\")\n    print(f\"  Timestamp: {self.timestamp}\")\n    print(f\"  Raw Size: {self.raw_size}\")\n    for layer in self.layers:\n        layer.show()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket","title":"BasePacket","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base Pydantic model for all network packet types.</p> <p>This model serves as the base for all specific packet type models and contains common fields and methods shared by all network packets.</p> ATTRIBUTE DESCRIPTION <code>payload</code> <p>The packet payload data.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>layers</code> <p>List of protocol layers in the packet.</p> <p> TYPE: <code>List[str]</code> </p> <code>timestamp</code> <p>The timestamp when the packet was captured.</p> <p> TYPE: <code>Optional[Union[str, float]]</code> </p> <code>dst_ip</code> <p>Destination IP address.</p> <p> TYPE: <code>Optional[IPvAnyAddress]</code> </p> <code>src_ip</code> <p>Source IP address.</p> <p> TYPE: <code>Optional[IPvAnyAddress]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address.\n    \"\"\"\n    return str(self.dst_ip) if self.dst_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address.\n    \"\"\"\n    return str(self.src_ip) if self.src_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.BasePacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant packet information, including headers, addresses, and payload summary.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant packet information,\n    including headers, addresses, and payload summary.\n    \"\"\"\n    print(f\"Packet Type: {self.__class__.__name__}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n    print(f\"  Source IP: {self.src_ip}\")\n    print(f\"  Destination IP: {self.dst_ip}\")\n    print(f\"  Layers: {self.layers}\")\n    if self.payload:\n        print(\n            f\"  Payload: {self.payload[:50]}...\"\n            if len(self.payload) &gt; 50\n            else f\"  Payload: {self.payload}\"\n        )\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket","title":"ARPPacket","text":"<p>               Bases: <code>BasePacket</code></p> <p>Pydantic model for Address Resolution Protocol (ARP) packets.</p> <p>ARP is used for mapping an IP address to a physical MAC address on a local network.</p> ATTRIBUTE DESCRIPTION <code>hw_type</code> <p>Hardware type (1 for Ethernet).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>proto_type</code> <p>Protocol type (0x0800 for IPv4).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>hw_len</code> <p>Hardware address length (6 for MAC address).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>proto_len</code> <p>Protocol address length (4 for IPv4 address).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>opcode</code> <p>Operation code (1 for request, 2 for reply).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>sender_mac</code> <p>MAC address of the sender.</p> <p> TYPE: <code>Optional[MacAddress]</code> </p> <code>sender_ip</code> <p>IP address of the sender.</p> <p> TYPE: <code>Optional[IPvAnyAddress]</code> </p> <code>target_mac</code> <p>MAC address of the target.</p> <p> TYPE: <code>Optional[MacAddress]</code> </p> <code>target_ip</code> <p>IP address of the target.</p> <p> TYPE: <code>Optional[IPvAnyAddress]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data)\n</code></pre> <p>Create a new ARPPacket instance from keyword arguments.</p> PARAMETER DESCRIPTION <code>**data</code> <p>Keyword arguments corresponding to the model's fields.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ARPPacket</code> <p>A new instance of the ARPPacket.</p> <p> TYPE: <code>ARPPacket</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>@classmethod\ndef new(cls, **data: Any) -&gt; \"ARPPacket\":\n    \"\"\"\n    Create a new ARPPacket instance from keyword arguments.\n\n    Args:\n        **data: Keyword arguments corresponding to the model's fields.\n\n    Returns:\n        ARPPacket: A new instance of the ARPPacket.\n    \"\"\"\n    return ARPPacket(**data)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address (target_ip for ARP).</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address (target_ip for ARP).\n    \"\"\"\n    return str(self.target_ip) if self.target_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address (sender_ip for ARP).</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address (sender_ip for ARP).\n    \"\"\"\n    return str(self.sender_ip) if self.sender_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant ARP packet information, including hardware type, protocol type, addresses, and operation.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant ARP packet information,\n    including hardware type, protocol type, addresses, and operation.\n    \"\"\"\n    print(\"ARP Packet:\")\n    print(f\"  Hardware Type: {self.hw_type}\")\n    print(f\"  Protocol Type: {self.proto_type}\")\n    print(f\"  Hardware Length: {self.hw_len}\")\n    print(f\"  Protocol Length: {self.proto_len}\")\n    print(f\"  Operation: {self.opcode}\")\n    print(f\"  Sender MAC: {self.sender_mac}\")\n    print(f\"  Sender IP: {self.sender_ip}\")\n    print(f\"  Target MAC: {self.target_mac}\")\n    print(f\"  Target IP: {self.target_ip}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ARPPacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket","title":"STPPacket","text":"<p>               Bases: <code>BasePacket</code></p> <p>Pydantic model for Spanning Tree Protocol (STP) packets.</p> <p>STP is used to prevent loops in network topologies with redundant paths.</p> ATTRIBUTE DESCRIPTION <code>protocol_id</code> <p>Protocol identifier.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>version</code> <p>STP version.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>bpdutype</code> <p>Bridge Protocol Data Unit type (0x00 for Configuration, 0x80 for TCN).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>flags</code> <p>Flag bits, including Topology Change Notification (0x01).</p> <p> TYPE: <code>Optional[bytes]</code> </p> <code>root_bridge_id</code> <p>ID of the root bridge.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>sender_bridge_id</code> <p>ID of the sender bridge.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>root_path_cost</code> <p>Cost of the path to the root bridge.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>port_id</code> <p>ID of the sending port.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>message_age</code> <p>Time since the message was generated.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>max_age</code> <p>Maximum lifetime of the message.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>hello_time</code> <p>Interval between BPDUs.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>forward_delay</code> <p>Time to wait before forwarding.</p> <p> TYPE: <code>Optional[int]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data)\n</code></pre> <p>Create a new STPPacket instance from keyword arguments.</p> PARAMETER DESCRIPTION <code>**data</code> <p>Keyword arguments corresponding to the model's fields.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>STPPacket</code> <p>A new instance of the STPPacket.</p> <p> TYPE: <code>STPPacket</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>@classmethod\ndef new(cls, **data: Any) -&gt; \"STPPacket\":\n    \"\"\"\n    Create a new STPPacket instance from keyword arguments.\n\n    Args:\n        **data: Keyword arguments corresponding to the model's fields.\n\n    Returns:\n        STPPacket: A new instance of the STPPacket.\n    \"\"\"\n    return STPPacket(**data)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant STP packet information, including protocol ID, version, BPDU type, flags, and bridge IDs.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant STP packet information,\n    including protocol ID, version, BPDU type, flags, and bridge IDs.\n    \"\"\"\n    print(\"STP Packet:\")\n    print(f\"  Protocol ID: {self.protocol_id}\")\n    print(f\"  Version: {self.version}\")\n    print(f\"  BPDU Type: {self.bpdutype}\")\n    print(f\"  Flags: {self.flags!r}\")\n    print(f\"  Root Bridge ID: {self.root_bridge_id}\")\n    print(f\"  Sender Bridge ID: {self.sender_bridge_id}\")\n    print(f\"  Root Path Cost: {self.root_path_cost}\")\n    print(f\"  Port ID: {self.port_id}\")\n    print(f\"  Message Age: {self.message_age}\")\n    print(f\"  Max Age: {self.max_age}\")\n    print(f\"  Hello Time: {self.hello_time}\")\n    print(f\"  Forward Delay: {self.forward_delay}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address.\n    \"\"\"\n    return str(self.dst_ip) if self.dst_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address.\n    \"\"\"\n    return str(self.src_ip) if self.src_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.STPPacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket","title":"EthernetPacket","text":"<p>               Bases: <code>BasePacket</code></p> <p>Pydantic model for Ethernet frames (Layer 2 of the OSI model).</p> <p>Ethernet is the most common Layer 2 protocol used in local area networks (LANs).</p> ATTRIBUTE DESCRIPTION <code>preamble</code> <p>Synchronization pattern (typically 0xAA).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>sfd</code> <p>Start Frame Delimiter, marks the beginning of the frame.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>dst_mac</code> <p>Destination MAC address.</p> <p> TYPE: <code>Optional[MacAddress]</code> </p> <code>src_mac</code> <p>Source MAC address.</p> <p> TYPE: <code>Optional[MacAddress]</code> </p> <code>type</code> <p>EtherType field indicating the protocol of the payload (e.g., 0x0800 for IPv4).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>crc</code> <p>Cyclic Redundancy Check for error detection.</p> <p> TYPE: <code>Optional[str]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data)\n</code></pre> <p>Create a new EthernetPacket instance from keyword arguments.</p> PARAMETER DESCRIPTION <code>**data</code> <p>Keyword arguments corresponding to the model's fields.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>EthernetPacket</code> <p>A new instance of the EthernetPacket.</p> <p> TYPE: <code>EthernetPacket</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>@classmethod\ndef new(cls, **data: Any) -&gt; \"EthernetPacket\":\n    \"\"\"\n    Create a new EthernetPacket instance from keyword arguments.\n\n    Args:\n        **data: Keyword arguments corresponding to the model's fields.\n\n    Returns:\n        EthernetPacket: A new instance of the EthernetPacket.\n    \"\"\"\n    return EthernetPacket(**data)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant Ethernet frame information, including MAC addresses, EtherType, and CRC.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant Ethernet frame information,\n    including MAC addresses, EtherType, and CRC.\n    \"\"\"\n    print(\"Ethernet Packet:\")\n    print(f\"  Preamble: {self.preamble}\")\n    print(f\"  Start Frame Delimiter: {self.sfd}\")\n    print(f\"  Destination MAC: {self.dst_mac}\")\n    print(f\"  Source MAC: {self.src_mac}\")\n    print(f\"  EtherType: {self.type}\")\n    print(f\"  CRC: {self.crc}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address.\n    \"\"\"\n    return str(self.dst_ip) if self.dst_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address.\n    \"\"\"\n    return str(self.src_ip) if self.src_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.EthernetPacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket","title":"IPPacket","text":"<p>               Bases: <code>BasePacket</code></p> <p>Pydantic model for Internet Protocol (IP) packets.</p> <p>IP is the principal communications protocol for relaying packets across network boundaries.</p> ATTRIBUTE DESCRIPTION <code>version</code> <p>IP version (4 for IPv4, 6 for IPv6).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>ihl</code> <p>Internet Header Length (number of 32-bit words in the header).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>tos</code> <p>Type of Service, specifies priority and handling.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>len</code> <p>Total Length of the packet.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>id</code> <p>Identification field for uniquely identifying fragments.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>flags</code> <p>Flags for controlling fragmentation.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>frag</code> <p>Fragment Offset, indicates position of fragment in original packet.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>ttl</code> <p>Time to Live, prevents packets from circulating indefinitely.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>proto</code> <p>Protocol field, indicates the next level protocol.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>chksum</code> <p>Header Checksum for error detection.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>src</code> <p>Source IP address.</p> <p> TYPE: <code>Optional[IPvAnyAddress]</code> </p> <code>dst</code> <p>Destination IP address.</p> <p> TYPE: <code>Optional[IPvAnyAddress]</code> </p> <code>options</code> <p>IP options.</p> <p> TYPE: <code>Optional[List[dict]]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data)\n</code></pre> <p>Create a new IPPacket instance from keyword arguments.</p> PARAMETER DESCRIPTION <code>**data</code> <p>Keyword arguments corresponding to the model's fields.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>IPPacket</code> <p>A new instance of the IPPacket.</p> <p> TYPE: <code>IPPacket</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>@classmethod\ndef new(cls, **data: Any) -&gt; \"IPPacket\":\n    \"\"\"\n    Create a new IPPacket instance from keyword arguments.\n\n    Args:\n        **data: Keyword arguments corresponding to the model's fields.\n\n    Returns:\n        IPPacket: A new instance of the IPPacket.\n    \"\"\"\n    return IPPacket(**data)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address.\n    \"\"\"\n    return str(self.dst) if self.dst else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address.\n    \"\"\"\n    return str(self.src) if self.src else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant IP packet information, including version, header length, addresses, and protocol.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant IP packet information,\n    including version, header length, addresses, and protocol.\n    \"\"\"\n    print(\"IP Packet:\")\n    print(f\"  Version: {self.version}\")\n    print(f\"  Internet Header Length: {self.ihl}\")\n    print(f\"  Type of Service: {self.tos}\")\n    print(f\"  Total Length: {self.len}\")\n    print(f\"  Identification: {self.id}\")\n    print(f\"  Flags: {self.flags}\")\n    print(f\"  Fragment Offset: {self.frag}\")\n    print(f\"  Time to Live: {self.ttl}\")\n    print(f\"  Protocol: {self.proto}\")\n    print(f\"  Header Checksum: {self.chksum}\")\n    print(f\"  Source Address: {self.src}\")\n    print(f\"  Destination Address: {self.dst}\")\n    print(f\"  Options: {self.options}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.IPPacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket","title":"ICMPPacket","text":"<p>               Bases: <code>BasePacket</code></p> <p>Pydantic model for Internet Control Message Protocol (ICMP) packets.</p> <p>ICMP is used by network devices to send error messages and operational information. Common uses include ping and traceroute.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>Type of message (e.g., 0 for Echo Reply, 8 for Echo Request).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>code</code> <p>Subtype of the message, providing additional context.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>chksum</code> <p>Checksum for error detection.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>id</code> <p>Identifier to help match requests with replies.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>seq</code> <p>Sequence number to help match requests with replies.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>data</code> <p>Payload data of the ICMP message.</p> <p> TYPE: <code>Optional[bytes]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data)\n</code></pre> <p>Create a new ICMPPacket instance from keyword arguments.</p> PARAMETER DESCRIPTION <code>**data</code> <p>Keyword arguments corresponding to the model's fields.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ICMPPacket</code> <p>A new instance of the ICMPPacket.</p> <p> TYPE: <code>ICMPPacket</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>@classmethod\ndef new(cls, **data: Any) -&gt; \"ICMPPacket\":\n    \"\"\"\n    Create a new ICMPPacket instance from keyword arguments.\n\n    Args:\n        **data: Keyword arguments corresponding to the model's fields.\n\n    Returns:\n        ICMPPacket: A new instance of the ICMPPacket.\n    \"\"\"\n    return ICMPPacket(**data)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant ICMP packet information, including type, code, checksum, and data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant ICMP packet information,\n    including type, code, checksum, and data.\n    \"\"\"\n    print(\"ICMP Packet:\")\n    print(f\"  Type: {self.type}\")\n    print(f\"  Code: {self.code}\")\n    print(f\"  Checksum: {self.chksum}\")\n    print(f\"  Identifier: {self.id}\")\n    print(f\"  Sequence Number: {self.seq}\")\n    print(f\"  Data: {self.data!r}\")\n    print(f\"  Source IP: {self.src_ip}\")\n    print(f\"  Destination IP: {self.dst_ip}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address.\n    \"\"\"\n    return str(self.dst_ip) if self.dst_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address.\n    \"\"\"\n    return str(self.src_ip) if self.src_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.ICMPPacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket","title":"TCPPacket","text":"<p>               Bases: <code>BasePacket</code></p> <p>Pydantic model for Transmission Control Protocol (TCP) packets.</p> <p>TCP is one of the main protocols of the Internet protocol suite, providing reliable, ordered, and error-checked delivery of data between applications.</p> ATTRIBUTE DESCRIPTION <code>sport</code> <p>Source port number.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>dport</code> <p>Destination port number.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>seq</code> <p>Sequence number, used for ordering segments.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>ack</code> <p>Acknowledgment number, indicates next expected sequence number.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>dataofs</code> <p>Data offset, specifies the size of the TCP header.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>reserved</code> <p>Reserved bits, should be zero.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>flags</code> <p>Control flags (e.g., SYN, ACK, FIN).</p> <p> TYPE: <code>Optional[str]</code> </p> <code>window</code> <p>Window size, for flow control.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>chksum</code> <p>Checksum for error detection.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>urgptr</code> <p>Urgent pointer, indicates important data.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>options</code> <p>TCP options.</p> <p> TYPE: <code>Optional[List[tuple]]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data)\n</code></pre> <p>Create a new TCPPacket instance from keyword arguments.</p> PARAMETER DESCRIPTION <code>**data</code> <p>Keyword arguments corresponding to the model's fields.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>TCPPacket</code> <p>A new instance of the TCPPacket.</p> <p> TYPE: <code>TCPPacket</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>@classmethod\ndef new(cls, **data: Any) -&gt; \"TCPPacket\":\n    \"\"\"\n    Create a new TCPPacket instance from keyword arguments.\n\n    Args:\n        **data: Keyword arguments corresponding to the model's fields.\n\n    Returns:\n        TCPPacket: A new instance of the TCPPacket.\n    \"\"\"\n    return TCPPacket(**data)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant TCP packet information, including ports, sequence numbers, flags, and options.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant TCP packet information,\n    including ports, sequence numbers, flags, and options.\n    \"\"\"\n    print(\"TCP Packet:\")\n    print(f\"  Source Port: {self.sport}\")\n    print(f\"  Destination Port: {self.dport}\")\n    print(f\"  Sequence Number: {self.seq}\")\n    print(f\"  Acknowledgment Number: {self.ack}\")\n    print(f\"  Data Offset: {self.dataofs}\")\n    print(f\"  Reserved: {self.reserved}\")\n    print(f\"  Flags: {self.flags}\")\n    print(f\"  Window Size: {self.window}\")\n    print(f\"  Checksum: {self.chksum}\")\n    print(f\"  Urgent Pointer: {self.urgptr}\")\n    print(f\"  Options: {self.options}\")\n    print(f\"  Source IP: {self.src_ip}\")\n    print(f\"  Destination IP: {self.dst_ip}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address.\n    \"\"\"\n    return str(self.dst_ip) if self.dst_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address.\n    \"\"\"\n    return str(self.src_ip) if self.src_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.TCPPacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket","title":"UDPPacket","text":"<p>               Bases: <code>BasePacket</code></p> <p>Pydantic model for User Datagram Protocol (UDP) packets.</p> <p>UDP is a connectionless protocol that provides a simple but unreliable message service. It's often used for real-time applications where speed is more important than reliability.</p> ATTRIBUTE DESCRIPTION <code>sport</code> <p>Source port number.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>dport</code> <p>Destination port number.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>len</code> <p>Length of the UDP header and data.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>chksum</code> <p>Checksum for error detection.</p> <p> TYPE: <code>Optional[int]</code> </p>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket-functions","title":"Functions","text":""},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data)\n</code></pre> <p>Create a new UDPPacket instance from keyword arguments.</p> PARAMETER DESCRIPTION <code>**data</code> <p>Keyword arguments corresponding to the model's fields.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>UDPPacket</code> <p>A new instance of the UDPPacket.</p> <p> TYPE: <code>UDPPacket</code> </p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>@classmethod\ndef new(cls, **data: Any) -&gt; \"UDPPacket\":\n    \"\"\"\n    Create a new UDPPacket instance from keyword arguments.\n\n    Args:\n        **data: Keyword arguments corresponding to the model's fields.\n\n    Returns:\n        UDPPacket: A new instance of the UDPPacket.\n    \"\"\"\n    return UDPPacket(**data)\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display the packet information in a human-readable format.</p> <p>This method prints out all relevant UDP packet information, including ports, length, and checksum.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the packet information in a human-readable format.\n\n    This method prints out all relevant UDP packet information,\n    including ports, length, and checksum.\n    \"\"\"\n    print(\"UDP Packet:\")\n    print(f\"  Source Port: {self.sport}\")\n    print(f\"  Destination Port: {self.dport}\")\n    print(f\"  Length: {self.len}\")\n    print(f\"  Checksum: {self.chksum}\")\n    print(f\"  Source IP: {self.src_ip}\")\n    print(f\"  Destination IP: {self.dst_ip}\")\n    print(f\"  Timestamp: {self.timestamp}\")\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Get the payload data of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The payload data of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_payload(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the payload data of the packet.\n\n    Returns:\n        Optional[str]: The payload data of the packet.\n    \"\"\"\n    return self.payload\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.get_layers","title":"get_layers","text":"<pre><code>get_layers()\n</code></pre> <p>Get the list of protocol layers in the packet.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of protocol layers in the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_layers(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of protocol layers in the packet.\n\n    Returns:\n        List[str]: A list of protocol layers in the packet.\n    \"\"\"\n    return self.layers\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp()\n</code></pre> <p>Get the timestamp when the packet was captured.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Optional[float]: The timestamp of the packet capture.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_timestamp(self) -&gt; Optional[float]:\n    \"\"\"\n    Get the timestamp when the packet was captured.\n\n    Returns:\n        Optional[float]: The timestamp of the packet capture.\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.get_dst_ip","title":"get_dst_ip","text":"<pre><code>get_dst_ip()\n</code></pre> <p>Get the destination IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The destination IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_dst_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the destination IP address of the packet.\n\n    Returns:\n        Optional[str]: The destination IP address.\n    \"\"\"\n    return str(self.dst_ip) if self.dst_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.get_src_ip","title":"get_src_ip","text":"<pre><code>get_src_ip()\n</code></pre> <p>Get the source IP address of the packet.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The source IP address.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def get_src_ip(self) -&gt; Optional[str]:\n    \"\"\"\n    Get the source IP address of the packet.\n\n    Returns:\n        Optional[str]: The source IP address.\n    \"\"\"\n    return str(self.src_ip) if self.src_ip else None\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> <p>Convert the packet model to a JSON-serializable dictionary.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the packet.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the packet model to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the packet.\n    \"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas()\n</code></pre> <p>Convert the packet model to a pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the packet data.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the packet model to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the packet data.\n    \"\"\"\n    return pd.DataFrame([self.to_json()])\n</code></pre>"},{"location":"models/api/packet-data-structures/#network_security_suite.models.packet_data_structures.UDPPacket.to_polars","title":"to_polars","text":"<pre><code>to_polars()\n</code></pre> <p>Convert the packet model to a polars DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ImportError</code> <p>If the polars package is not installed.</p> Source code in <code>src/network_security_suite/models/packet_data_structures.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"\n    Convert the packet model to a polars DataFrame.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the packet data.\n\n    Raises:\n        ImportError: If the polars package is not installed.\n    \"\"\"\n    if not POLARS_AVAILABLE:\n        raise ImportError(\n            \"The polars package is not installed. \"\n            \"Please install it with 'pip install polars' or 'poetry add polars'.\"\n        )\n\n    try:\n        # Convert the model to a dictionary\n        data = self.model_dump()\n\n        # Pre-process special fields\n        for key, value in data.items():\n            # Convert IP addresses and MAC addresses to strings\n            if hasattr(value, \"__str__\") and (\n                type(value).__name__ in (\"IPvAnyAddress\", \"MacAddress\")\n            ):\n                data[key] = str(value)\n            # Convert bytes to hex strings\n            elif isinstance(value, bytes):\n                data[key] = value.hex()\n            # Convert lists to string representation\n            elif isinstance(value, list):\n                data[key] = str(value)\n\n        # Create DataFrame\n        return pl.DataFrame([data])\n\n    except Exception as e:\n        print(f\"Error converting model to Polars DataFrame: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"models/api/packet-data-structures/#usage-examples","title":"Usage Examples","text":""},{"location":"models/api/packet-data-structures/#ethernetpacket","title":"EthernetPacket","text":"<pre><code>from network_security_suite.models import EthernetPacket\n\nethernet = EthernetPacket(\n    src_mac=\"00:11:22:33:44:55\",\n    dst_mac=\"66:77:88:99:aa:bb\",\n    ethertype=0x0800,\n    payload=b\"\\x00\\x01\\x02\"\n)\n\nprint(ethernet.model_dump_json(indent=2))\n</code></pre>"},{"location":"models/api/packet-data-structures/#arppacket","title":"ARPPacket","text":"<pre><code>from network_security_suite.models import ARPPacket\n\narp = ARPPacket(\n    operation=1,\n    sender_mac=\"00:11:22:33:44:55\",\n    sender_ip=\"192.168.1.100\",\n    target_mac=\"00:00:00:00:00:00\",\n    target_ip=\"192.168.1.1\"\n)\n</code></pre>"},{"location":"models/api/packet-data-structures/#tcppacket","title":"TCPPacket","text":"<pre><code>from network_security_suite.models import TCPPacket\n\ntcp = TCPPacket(\n    src_port=443,\n    dst_port=54321,\n    seq=1000,\n    ack=2000,\n    flags=\"SA\",\n    window=65535\n)\n</code></pre>"},{"location":"models/api/packet-data-structures/#udppacket","title":"UDPPacket","text":"<pre><code>from network_security_suite.models import UDPPacket\n\nudp = UDPPacket(\n    src_port=53,\n    dst_port=12345,\n    length=100,\n    payload=b\"data\"\n)\n</code></pre>"},{"location":"models/api/packet-data-structures/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Data Structures Guide</li> <li>Database Schemas</li> </ul>"},{"location":"sniffer/","title":"Sniffer Module","text":"<p>The Sniffer module is the core network packet capture and processing engine of the Network Security Suite. It provides real-time packet capture, filtering, and storage capabilities.</p>"},{"location":"sniffer/#overview","title":"Overview","text":"<p>The sniffer module uses low-level packet capture libraries to intercept network traffic and provides a high-level API for working with captured packets. It supports multiple network interfaces, customizable packet filtering, and efficient storage using Parquet format.</p>"},{"location":"sniffer/#key-features","title":"Key Features","text":"<ul> <li>Real-time Packet Capture: Capture network packets in real-time from one or multiple network interfaces</li> <li>Advanced Filtering: Apply BPF (Berkeley Packet Filter) filters to capture only relevant traffic</li> <li>Efficient Storage: Store captured packets in Parquet format for efficient analysis</li> <li>Multi-interface Support: Capture from multiple network interfaces simultaneously</li> <li>Comprehensive Logging: Specialized loggers for different types of events (security, packets, errors, etc.)</li> <li>Protocol Support: Support for various network protocols (Ethernet, ARP, IP, TCP, UDP, DNS, etc.)</li> <li>Configuration Management: YAML-based configuration for easy setup</li> </ul>"},{"location":"sniffer/#components","title":"Components","text":""},{"location":"sniffer/#packetcapture","title":"PacketCapture","text":"<p>The main class for capturing network packets. It handles: - Interface selection and configuration - Packet filtering - Real-time packet processing - Storage management</p> <p>See PacketCapture API Reference for details.</p>"},{"location":"sniffer/#parquetprocessing","title":"ParquetProcessing","text":"<p>Handles conversion of captured packets to Parquet format for efficient storage and analysis.</p> <p>See ParquetProcessing API Reference for details.</p>"},{"location":"sniffer/#interfaces","title":"Interfaces","text":"<p>Utilities for discovering and managing network interfaces.</p> <p>See Interfaces API Reference for details.</p>"},{"location":"sniffer/#loggers","title":"Loggers","text":"<p>Specialized logger classes for different types of events: - ConsoleLogger: Console output - SecurityLogger: Security-related events - PacketLogger: Packet information - FileLogger: General file logging - RotatingFileLogger: File logging with rotation - ErrorLogger, DebugLogger, CriticalLogger, etc.</p> <p>See Loggers API Reference for details.</p>"},{"location":"sniffer/#exceptions","title":"Exceptions","text":"<p>Custom exceptions for packet capture operations.</p> <p>See Exceptions API Reference for details.</p>"},{"location":"sniffer/#configuration","title":"Configuration","text":"<p>YAML-based configuration system for sniffer settings.</p> <p>See Configuration API Reference for details.</p>"},{"location":"sniffer/#quick-start","title":"Quick Start","text":""},{"location":"sniffer/#basic-packet-capture","title":"Basic Packet Capture","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\n\n# Create a packet capture instance\ncapture = PacketCapture(\n    interface=\"eth0\",\n    packet_count=1000,\n    filter_str=\"tcp port 80\"\n)\n\n# Start capturing\ncapture.start()\n\n# Packets are automatically saved to Parquet files\n</code></pre>"},{"location":"sniffer/#using-configuration-file","title":"Using Configuration File","text":"<pre><code>from network_security_suite.sniffer.sniffer_config import SnifferConfig\n\n# Load configuration from YAML\nconfig = SnifferConfig.from_yaml(\"config.yaml\")\n\n# Create capture with configuration\ncapture = PacketCapture.from_config(config)\ncapture.start()\n</code></pre>"},{"location":"sniffer/#custom-logging","title":"Custom Logging","text":"<pre><code>from network_security_suite.sniffer import SecurityLogger, PacketLogger\n\n# Set up specialized loggers\nsecurity_logger = SecurityLogger()\npacket_logger = PacketLogger()\n\n# Use in your packet capture\ncapture = PacketCapture(\n    interface=\"eth0\",\n    security_logger=security_logger,\n    packet_logger=packet_logger\n)\n</code></pre>"},{"location":"sniffer/#use-cases","title":"Use Cases","text":""},{"location":"sniffer/#network-monitoring","title":"Network Monitoring","text":"<p>Monitor network traffic for suspicious activity, unusual patterns, or security threats.</p>"},{"location":"sniffer/#protocol-analysis","title":"Protocol Analysis","text":"<p>Analyze specific network protocols to understand traffic patterns and identify issues.</p>"},{"location":"sniffer/#security-auditing","title":"Security Auditing","text":"<p>Capture and store network traffic for security auditing and compliance purposes.</p>"},{"location":"sniffer/#performance-analysis","title":"Performance Analysis","text":"<p>Monitor network performance metrics like bandwidth usage, latency, and packet loss.</p>"},{"location":"sniffer/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Network Interface] --&gt; B[PacketCapture]\n    B --&gt; C{Packet Filter}\n    C --&gt;|Match| D[Packet Processing]\n    C --&gt;|No Match| A\n    D --&gt; E[ParquetProcessing]\n    E --&gt; F[Parquet Storage]\n    D --&gt; G[Logging System]\n    G --&gt; H[Console/File Logs]</code></pre>"},{"location":"sniffer/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Buffer Size: Adjust packet buffer size based on traffic volume</li> <li>Filter Optimization: Use efficient BPF filters to reduce processing overhead</li> <li>Storage: Parquet format provides excellent compression and query performance</li> <li>Multi-threading: Consider using multiple capture threads for high-traffic environments</li> </ul>"},{"location":"sniffer/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide: Step-by-step tutorial for setting up packet capture</li> <li>Configuration Guide: Detailed configuration options</li> <li>Packet Filtering Guide: Advanced filtering techniques</li> <li>API Reference: Complete API documentation</li> <li>Examples: Practical examples and use cases</li> </ul>"},{"location":"sniffer/configuration/","title":"Sniffer Configuration","text":"<p>This guide covers all configuration options for the packet capture module.</p>"},{"location":"sniffer/configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"sniffer/configuration/#1-direct-configuration","title":"1. Direct Configuration","text":"<p>Pass configuration directly to PacketCapture:</p> <pre><code>from network_security_suite.sniffer import PacketCapture\n\ncapture = PacketCapture(\n    interface=\"eth0\",\n    packet_count=1000,\n    timeout=60,\n    promisc=True,\n    filter_str=\"tcp\",\n    output_file=\"capture.parquet\"\n)\n</code></pre>"},{"location":"sniffer/configuration/#2-yaml-configuration","title":"2. YAML Configuration","text":"<p>Use a YAML configuration file:</p> <pre><code># config.yaml\nsniffer:\n  interface: eth0\n  packet_count: 1000\n  timeout: 60\n  promisc_mode: true\n  filter: \"tcp port 80\"\n\n  output:\n    directory: ./captures\n    filename_pattern: \"capture_{timestamp}.parquet\"\n    rotation: daily\n\n  logging:\n    level: INFO\n    handlers:\n      - type: console\n        level: INFO\n      - type: file\n        level: DEBUG\n        path: ./logs/sniffer.log\n</code></pre> <p>Load configuration:</p> <pre><code>from network_security_suite.sniffer.sniffer_config import SnifferConfig\n\nconfig = SnifferConfig.from_yaml(\"config.yaml\")\ncapture = PacketCapture.from_config(config)\n</code></pre>"},{"location":"sniffer/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"sniffer/configuration/#interface-settings","title":"Interface Settings","text":"Option Type Default Description <code>interface</code> str None Network interface to capture from <code>promisc</code> bool True Enable promiscuous mode <code>monitor_mode</code> bool False Enable monitor mode (wireless) <pre><code>capture = PacketCapture(\n    interface=\"wlan0\",\n    promisc=True,\n    monitor_mode=True  # For wireless sniffing\n)\n</code></pre>"},{"location":"sniffer/configuration/#capture-settings","title":"Capture Settings","text":"Option Type Default Description <code>packet_count</code> int 0 Number of packets to capture (0 = unlimited) <code>timeout</code> int None Capture timeout in seconds <code>buffer_size</code> int 65536 Packet buffer size in bytes <code>snaplen</code> int 65535 Maximum bytes to capture per packet <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    packet_count=10000,\n    timeout=300,  # 5 minutes\n    buffer_size=131072,  # 128KB\n    snaplen=1500  # Capture only headers\n)\n</code></pre>"},{"location":"sniffer/configuration/#filter-settings","title":"Filter Settings","text":"Option Type Default Description <code>filter_str</code> str \"\" BPF filter string <code>filter_optimize</code> bool True Optimize BPF filter <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"tcp port 443 and host 192.168.1.100\",\n    filter_optimize=True\n)\n</code></pre>"},{"location":"sniffer/configuration/#output-settings","title":"Output Settings","text":"Option Type Default Description <code>output_file</code> str None Output Parquet file path <code>output_dir</code> str \"./captures\" Output directory <code>compression</code> str \"snappy\" Parquet compression (snappy, gzip, none) <code>batch_size</code> int 1000 Packets per batch write <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    output_file=\"capture.parquet\",\n    compression=\"gzip\",\n    batch_size=5000\n)\n</code></pre>"},{"location":"sniffer/configuration/#logging-settings","title":"Logging Settings","text":"Option Type Default Description <code>log_level</code> str \"INFO\" Logging level <code>log_file</code> str None Log file path <code>log_rotation</code> str None Log rotation (daily, weekly) <pre><code>from network_security_suite.sniffer import PacketCapture, FileLogger\n\nlogger = FileLogger(\n    filename=\"sniffer.log\",\n    level=\"DEBUG\",\n    rotation=\"daily\"\n)\n\ncapture = PacketCapture(\n    interface=\"eth0\",\n    loggers=[logger]\n)\n</code></pre>"},{"location":"sniffer/configuration/#complete-yaml-configuration-example","title":"Complete YAML Configuration Example","text":"<pre><code># sniffer_config.yaml\nsniffer:\n  # Interface configuration\n  interface: eth0\n  promisc_mode: true\n  monitor_mode: false\n\n  # Capture settings\n  packet_count: 0  # Unlimited\n  timeout: null\n  buffer_size: 131072  # 128KB\n  snaplen: 65535\n\n  # Filter configuration\n  filters:\n    protocol: tcp\n    ports: [80, 443, 8080]\n    ips:\n      - 192.168.1.0/24\n      - 10.0.0.0/8\n    exclude:\n      - broadcast\n      - multicast\n\n  # Output configuration\n  output:\n    directory: ./captures\n    filename_pattern: \"capture_{date}_{time}.parquet\"\n    compression: snappy\n    batch_size: 1000\n    rotation:\n      enabled: true\n      interval: hourly\n      max_size: 1GB\n      max_files: 10\n\n  # Logging configuration\n  logging:\n    level: INFO\n    format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n\n    handlers:\n      console:\n        enabled: true\n        level: INFO\n        colored: true\n\n      file:\n        enabled: true\n        level: DEBUG\n        path: ./logs/sniffer.log\n        rotation: daily\n        max_size: 100MB\n        backup_count: 7\n\n      security:\n        enabled: true\n        level: WARNING\n        path: ./logs/security.log\n        rotation: daily\n\n      packet:\n        enabled: true\n        level: DEBUG\n        path: ./logs/packets.log\n        rotation: hourly\n        max_size: 500MB\n\n  # Performance settings\n  performance:\n    buffer_timeout: 100  # ms\n    batch_processing: true\n    parallel_processing: false\n    worker_threads: 4\n\n  # Security settings\n  security:\n    detect_anomalies: true\n    alert_on_suspicious: true\n    rate_limit: 10000  # packets/sec\n    blacklist:\n      - 192.168.1.666\n    whitelist:\n      - 192.168.1.1\n</code></pre>"},{"location":"sniffer/configuration/#environment-specific-configurations","title":"Environment-Specific Configurations","text":""},{"location":"sniffer/configuration/#development","title":"Development","text":"<pre><code># config.dev.yaml\nsniffer:\n  interface: lo  # Loopback for testing\n  packet_count: 100\n  timeout: 10\n\n  logging:\n    level: DEBUG\n    handlers:\n      console:\n        enabled: true\n        level: DEBUG\n</code></pre>"},{"location":"sniffer/configuration/#production","title":"Production","text":"<pre><code># config.prod.yaml\nsniffer:\n  interface: eth0\n  packet_count: 0\n  promisc_mode: true\n\n  output:\n    directory: /var/log/netguard/captures\n    rotation:\n      enabled: true\n      interval: hourly\n\n  logging:\n    level: WARNING\n    handlers:\n      file:\n        enabled: true\n        path: /var/log/netguard/sniffer.log\n        rotation: daily\n</code></pre>"},{"location":"sniffer/configuration/#testing","title":"Testing","text":"<pre><code># config.test.yaml\nsniffer:\n  interface: any\n  packet_count: 50\n  timeout: 5\n\n  output:\n    directory: ./test_captures\n\n  logging:\n    level: ERROR\n</code></pre>"},{"location":"sniffer/configuration/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Update configuration at runtime:</p> <pre><code>from network_security_suite.sniffer import PacketCapture\n\n# Start with initial config\ncapture = PacketCapture(interface=\"eth0\")\n\n# Update filter\ncapture.set_filter(\"tcp port 443\")\n\n# Update output\ncapture.set_output_file(\"new_capture.parquet\")\n\n# Update buffer size\ncapture.set_buffer_size(262144)\n</code></pre>"},{"location":"sniffer/configuration/#configuration-validation","title":"Configuration Validation","text":"<pre><code>from network_security_suite.sniffer.sniffer_config import SnifferConfig\n\ntry:\n    config = SnifferConfig.from_yaml(\"config.yaml\")\n    config.validate()\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\n</code></pre>"},{"location":"sniffer/configuration/#best-practices","title":"Best Practices","text":""},{"location":"sniffer/configuration/#1-use-configuration-files","title":"1. Use Configuration Files","text":"<p>For production environments, always use configuration files: - Easier to maintain - Version controlled - Environment-specific configs - No hardcoded values</p>"},{"location":"sniffer/configuration/#2-optimize-buffer-sizes","title":"2. Optimize Buffer Sizes","text":"<pre><code># For high-traffic environments\ncapture = PacketCapture(\n    interface=\"eth0\",\n    buffer_size=524288,  # 512KB\n    batch_size=5000\n)\n\n# For low-traffic environments\ncapture = PacketCapture(\n    interface=\"eth0\",\n    buffer_size=65536,   # 64KB\n    batch_size=1000\n)\n</code></pre>"},{"location":"sniffer/configuration/#3-use-appropriate-filters","title":"3. Use Appropriate Filters","text":"<pre><code># Good: Specific filter\nfilter_str = \"tcp port 443 and src net 192.168.1.0/24\"\n\n# Bad: Too broad\nfilter_str = \"ip\"  # Captures everything\n</code></pre>"},{"location":"sniffer/configuration/#4-configure-rotation","title":"4. Configure Rotation","text":"<pre><code>output:\n  rotation:\n    enabled: true\n    interval: hourly  # Rotate every hour\n    max_size: 1GB     # Rotate at 1GB\n    max_files: 24     # Keep last 24 files\n</code></pre>"},{"location":"sniffer/configuration/#5-separate-log-levels","title":"5. Separate Log Levels","text":"<pre><code>logging:\n  handlers:\n    console:\n      level: INFO  # Less verbose for console\n    file:\n      level: DEBUG  # More verbose for file\n    security:\n      level: WARNING  # Only important security events\n</code></pre>"},{"location":"sniffer/configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"sniffer/configuration/#configuration-not-loading","title":"Configuration Not Loading","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\nconfig = SnifferConfig.from_yaml(\"config.yaml\")  # Will show debug info\n</code></pre>"},{"location":"sniffer/configuration/#invalid-filter-string","title":"Invalid Filter String","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\n\ntry:\n    capture = PacketCapture(\n        interface=\"eth0\",\n        filter_str=\"invalid filter\"\n    )\nexcept ValueError as e:\n    print(f\"Invalid filter: {e}\")\n</code></pre>"},{"location":"sniffer/configuration/#permission-issues","title":"Permission Issues","text":"<pre><code># Check file permissions\nls -l config.yaml\n\n# Fix if needed\nchmod 644 config.yaml\n</code></pre>"},{"location":"sniffer/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about packet filtering</li> <li>See API reference for all configuration options</li> <li>Check examples for more configurations</li> </ul>"},{"location":"sniffer/getting-started/","title":"Getting Started with Sniffer Module","text":"<p>This guide will help you get started with the Network Security Suite's packet capture capabilities.</p>"},{"location":"sniffer/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Root/Administrator privileges (required for packet capture)</li> <li>A network interface to capture from</li> </ul>"},{"location":"sniffer/getting-started/#installation","title":"Installation","text":"<p>The sniffer module is included with the Network Security Suite. Make sure you have all dependencies installed:</p> <pre><code># Using uv\nuv sync\n\n# Or using poetry\npoetry install\n</code></pre>"},{"location":"sniffer/getting-started/#basic-packet-capture","title":"Basic Packet Capture","text":""},{"location":"sniffer/getting-started/#step-1-list-available-interfaces","title":"Step 1: List Available Interfaces","text":"<p>First, identify which network interfaces are available:</p> <pre><code>from network_security_suite.sniffer.interfaces import get_available_interfaces\n\n# List all available interfaces\ninterfaces = get_available_interfaces()\nfor iface in interfaces:\n    print(f\"Interface: {iface['name']}, IP: {iface.get('ip', 'N/A')}\")\n</code></pre>"},{"location":"sniffer/getting-started/#step-2-create-a-simple-capture","title":"Step 2: Create a Simple Capture","text":"<p>Create a basic packet capture on a specific interface:</p> <pre><code>from network_security_suite.sniffer import PacketCapture\n\n# Create capture instance\ncapture = PacketCapture(\n    interface=\"eth0\",           # Your network interface\n    packet_count=100,           # Capture 100 packets\n    output_file=\"capture.parquet\"  # Save to Parquet file\n)\n\n# Start capturing\nprint(\"Starting packet capture...\")\ncapture.start()\nprint(\"Capture complete!\")\n</code></pre>"},{"location":"sniffer/getting-started/#step-3-apply-packet-filters","title":"Step 3: Apply Packet Filters","text":"<p>Capture only specific traffic using BPF filters:</p> <pre><code># Capture only HTTP traffic\ncapture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"tcp port 80 or tcp port 443\"\n)\n\n# Capture DNS queries\ncapture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"udp port 53\"\n)\n\n# Capture traffic to/from specific IP\ncapture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"host 192.168.1.100\"\n)\n</code></pre>"},{"location":"sniffer/getting-started/#working-with-captured-data","title":"Working with Captured Data","text":""},{"location":"sniffer/getting-started/#reading-parquet-files","title":"Reading Parquet Files","text":"<p>After capturing, you can read and analyze the Parquet files:</p> <pre><code>import pandas as pd\n\n# Read captured packets\ndf = pd.read_parquet(\"capture.parquet\")\n\n# Display basic statistics\nprint(f\"Total packets: {len(df)}\")\nprint(f\"Protocols: {df['protocol'].value_counts()}\")\nprint(f\"Top sources: {df['src_ip'].value_counts().head()}\")\n</code></pre>"},{"location":"sniffer/getting-started/#using-parquetprocessing","title":"Using ParquetProcessing","text":"<p>The module provides utilities for working with captured data:</p> <pre><code>from network_security_suite.sniffer.parquet_processing import ParquetProcessor\n\n# Load and process captured data\nprocessor = ParquetProcessor(\"capture.parquet\")\n\n# Get summary statistics\nsummary = processor.get_summary()\nprint(summary)\n\n# Filter by protocol\ntcp_packets = processor.filter_by_protocol(\"TCP\")\n</code></pre>"},{"location":"sniffer/getting-started/#logging","title":"Logging","text":""},{"location":"sniffer/getting-started/#basic-logging-setup","title":"Basic Logging Setup","text":"<pre><code>from network_security_suite.sniffer import (\n    PacketCapture,\n    ConsoleLogger,\n    FileLogger\n)\n\n# Set up loggers\nconsole_logger = ConsoleLogger(level=\"INFO\")\nfile_logger = FileLogger(\n    filename=\"packet_capture.log\",\n    level=\"DEBUG\"\n)\n\n# Create capture with logging\ncapture = PacketCapture(\n    interface=\"eth0\",\n    loggers=[console_logger, file_logger]\n)\n</code></pre>"},{"location":"sniffer/getting-started/#specialized-loggers","title":"Specialized Loggers","text":"<pre><code>from network_security_suite.sniffer import (\n    SecurityLogger,\n    PacketLogger,\n    ErrorLogger\n)\n\n# Security events logger\nsecurity_logger = SecurityLogger(\n    filename=\"security.log\",\n    level=\"WARNING\"\n)\n\n# Packet details logger\npacket_logger = PacketLogger(\n    filename=\"packets.log\",\n    level=\"DEBUG\"\n)\n\n# Error logger\nerror_logger = ErrorLogger(\n    filename=\"errors.log\",\n    level=\"ERROR\"\n)\n\ncapture = PacketCapture(\n    interface=\"eth0\",\n    loggers=[security_logger, packet_logger, error_logger]\n)\n</code></pre>"},{"location":"sniffer/getting-started/#configuration-files","title":"Configuration Files","text":""},{"location":"sniffer/getting-started/#creating-a-configuration-file","title":"Creating a Configuration File","text":"<p>Create a YAML configuration file (<code>sniffer_config.yaml</code>):</p> <pre><code>sniffer:\n  interface: eth0\n  packet_count: 1000\n  timeout: 60\n  promisc_mode: true\n\n  filters:\n    - \"tcp port 80\"\n    - \"tcp port 443\"\n\n  output:\n    directory: \"./captures\"\n    format: parquet\n    rotation: daily\n\n  logging:\n    level: INFO\n    console: true\n    file:\n      enabled: true\n      path: \"./logs/sniffer.log\"\n      rotation: daily\n      max_size: 100MB\n</code></pre>"},{"location":"sniffer/getting-started/#using-configuration","title":"Using Configuration","text":"<pre><code>from network_security_suite.sniffer.sniffer_config import SnifferConfig\n\n# Load configuration\nconfig = SnifferConfig.from_yaml(\"sniffer_config.yaml\")\n\n# Create capture from configuration\ncapture = PacketCapture.from_config(config)\ncapture.start()\n</code></pre>"},{"location":"sniffer/getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"sniffer/getting-started/#continuous-capture","title":"Continuous Capture","text":"<pre><code>import time\nfrom network_security_suite.sniffer import PacketCapture\n\n# Create capture that runs continuously\ncapture = PacketCapture(\n    interface=\"eth0\",\n    packet_count=0,  # 0 = unlimited\n    timeout=None     # No timeout\n)\n\n# Start in background\ncapture.start_async()\n\n# Run for specific duration\ntime.sleep(3600)  # Capture for 1 hour\n\n# Stop capture\ncapture.stop()\n</code></pre>"},{"location":"sniffer/getting-started/#multiple-interface-capture","title":"Multiple Interface Capture","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\nimport threading\n\ndef capture_interface(interface_name):\n    capture = PacketCapture(\n        interface=interface_name,\n        output_file=f\"capture_{interface_name}.parquet\"\n    )\n    capture.start()\n\n# Capture from multiple interfaces\ninterfaces = [\"eth0\", \"eth1\", \"wlan0\"]\nthreads = []\n\nfor iface in interfaces:\n    thread = threading.Thread(target=capture_interface, args=(iface,))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all captures to complete\nfor thread in threads:\n    thread.join()\n</code></pre>"},{"location":"sniffer/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"sniffer/getting-started/#permission-denied","title":"Permission Denied","text":"<p>If you get permission errors:</p> <pre><code># Run with sudo\nsudo python your_capture_script.py\n\n# Or set capabilities (Linux)\nsudo setcap cap_net_raw,cap_net_admin=eip /usr/bin/python3.11\n</code></pre>"},{"location":"sniffer/getting-started/#interface-not-found","title":"Interface Not Found","text":"<pre><code># Verify interface exists\nfrom network_security_suite.sniffer.interfaces import get_available_interfaces\n\ninterfaces = get_available_interfaces()\nprint(\"Available interfaces:\", [i['name'] for i in interfaces])\n</code></pre>"},{"location":"sniffer/getting-started/#no-packets-captured","title":"No Packets Captured","text":"<ul> <li>Check if interface is active and has traffic</li> <li>Verify filter string is correct</li> <li>Ensure sufficient permissions</li> <li>Check if promiscuous mode is enabled</li> </ul>"},{"location":"sniffer/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about advanced filtering</li> <li>Explore configuration options</li> <li>See API reference for all available options</li> <li>Check out examples for more use cases</li> </ul>"},{"location":"sniffer/packet-filtering/","title":"Packet Filtering Guide","text":"<p>This guide covers advanced packet filtering techniques using Berkeley Packet Filter (BPF) syntax.</p>"},{"location":"sniffer/packet-filtering/#bpf-filter-basics","title":"BPF Filter Basics","text":"<p>BPF filters allow you to capture only the packets you're interested in, reducing processing overhead and storage requirements.</p>"},{"location":"sniffer/packet-filtering/#basic-syntax","title":"Basic Syntax","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\n\n# Capture all TCP packets\ncapture = PacketCapture(interface=\"eth0\", filter_str=\"tcp\")\n\n# Capture all UDP packets\ncapture = PacketCapture(interface=\"eth0\", filter_str=\"udp\")\n\n# Capture all ICMP packets\ncapture = PacketCapture(interface=\"eth0\", filter_str=\"icmp\")\n</code></pre>"},{"location":"sniffer/packet-filtering/#common-filter-patterns","title":"Common Filter Patterns","text":""},{"location":"sniffer/packet-filtering/#filter-by-protocol","title":"Filter by Protocol","text":"<pre><code># TCP only\nfilter_str = \"tcp\"\n\n# UDP only\nfilter_str = \"udp\"\n\n# ICMP only\nfilter_str = \"icmp\"\n\n# ARP only\nfilter_str = \"arp\"\n\n# IP (any IP protocol)\nfilter_str = \"ip\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#filter-by-port","title":"Filter by Port","text":"<pre><code># Specific port\nfilter_str = \"port 80\"\n\n# Source port\nfilter_str = \"src port 443\"\n\n# Destination port\nfilter_str = \"dst port 22\"\n\n# Port range\nfilter_str = \"portrange 8000-9000\"\n\n# Multiple ports\nfilter_str = \"port 80 or port 443 or port 8080\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#filter-by-ip-address","title":"Filter by IP Address","text":"<pre><code># Specific host\nfilter_str = \"host 192.168.1.100\"\n\n# Source IP\nfilter_str = \"src host 10.0.0.1\"\n\n# Destination IP\nfilter_str = \"dst host 172.16.0.1\"\n\n# Network range (CIDR)\nfilter_str = \"net 192.168.1.0/24\"\n\n# Source network\nfilter_str = \"src net 10.0.0.0/8\"\n\n# Destination network\nfilter_str = \"dst net 172.16.0.0/16\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#advanced-filters","title":"Advanced Filters","text":""},{"location":"sniffer/packet-filtering/#combining-filters","title":"Combining Filters","text":"<p>Use logical operators to combine filters:</p> <pre><code># AND operator\nfilter_str = \"tcp and port 80\"\n\n# OR operator\nfilter_str = \"tcp port 80 or tcp port 443\"\n\n# NOT operator\nfilter_str = \"not broadcast\"\n\n# Complex combination\nfilter_str = \"tcp and (port 80 or port 443) and src net 192.168.1.0/24\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#protocol-specific-filters","title":"Protocol-Specific Filters","text":""},{"location":"sniffer/packet-filtering/#httphttps-traffic","title":"HTTP/HTTPS Traffic","text":"<pre><code># HTTP traffic\nfilter_str = \"tcp port 80\"\n\n# HTTPS traffic\nfilter_str = \"tcp port 443\"\n\n# Both HTTP and HTTPS\nfilter_str = \"tcp port 80 or tcp port 443\"\n\n# HTTP methods (requires deep packet inspection)\nfilter_str = \"tcp port 80 and tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420\"  # GET\n</code></pre>"},{"location":"sniffer/packet-filtering/#dns-traffic","title":"DNS Traffic","text":"<pre><code># DNS queries and responses\nfilter_str = \"udp port 53\"\n\n# DNS over TCP\nfilter_str = \"tcp port 53\"\n\n# All DNS traffic\nfilter_str = \"port 53\"\n\n# DNS from specific server\nfilter_str = \"src host 8.8.8.8 and port 53\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#ssh-traffic","title":"SSH Traffic","text":"<pre><code># SSH connections\nfilter_str = \"tcp port 22\"\n\n# SSH to specific host\nfilter_str = \"tcp port 22 and dst host 192.168.1.100\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#email-protocols","title":"Email Protocols","text":"<pre><code># SMTP\nfilter_str = \"tcp port 25\"\n\n# IMAP\nfilter_str = \"tcp port 143\"\n\n# POP3\nfilter_str = \"tcp port 110\"\n\n# All email protocols\nfilter_str = \"port 25 or port 110 or port 143\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#tcp-specific-filters","title":"TCP-Specific Filters","text":"<pre><code># TCP SYN packets (connection attempts)\nfilter_str = \"tcp[tcpflags] &amp; tcp-syn != 0\"\n\n# TCP SYN-ACK packets\nfilter_str = \"tcp[tcpflags] &amp; (tcp-syn|tcp-ack) == (tcp-syn|tcp-ack)\"\n\n# TCP RST packets\nfilter_str = \"tcp[tcpflags] &amp; tcp-rst != 0\"\n\n# TCP FIN packets\nfilter_str = \"tcp[tcpflags] &amp; tcp-fin != 0\"\n\n# Established connections\nfilter_str = \"tcp[tcpflags] &amp; tcp-ack != 0 and not tcp[tcpflags] &amp; tcp-syn != 0\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#size-based-filters","title":"Size-Based Filters","text":"<pre><code># Packets larger than 1000 bytes\nfilter_str = \"greater 1000\"\n\n# Packets smaller than 100 bytes\nfilter_str = \"less 100\"\n\n# Large packets only\nfilter_str = \"greater 1400\"  # Likely fragmented\n\n# Small packets only\nfilter_str = \"less 64\"  # Might be suspicious\n</code></pre>"},{"location":"sniffer/packet-filtering/#direction-based-filters","title":"Direction-Based Filters","text":"<pre><code># Incoming traffic only\nfilter_str = \"inbound\"\n\n# Outgoing traffic only\nfilter_str = \"outbound\"\n\n# Incoming on specific network\nfilter_str = \"src net 192.168.1.0/24 and dst net 10.0.0.0/8\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#security-focused-filters","title":"Security-Focused Filters","text":""},{"location":"sniffer/packet-filtering/#suspicious-activity","title":"Suspicious Activity","text":"<pre><code># Port scanning detection (SYN to multiple ports)\nfilter_str = \"tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack == 0\"\n\n# NULL scans\nfilter_str = \"tcp[tcpflags] == 0\"\n\n# XMAS scans\nfilter_str = \"tcp[tcpflags] &amp; (tcp-fin|tcp-urg|tcp-push) == (tcp-fin|tcp-urg|tcp-push)\"\n\n# Fragmented packets (potential evasion)\nfilter_str = \"ip[6:2] &amp; 0x1fff != 0\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#broadcast-and-multicast","title":"Broadcast and Multicast","text":"<pre><code># Exclude broadcast\nfilter_str = \"not broadcast\"\n\n# Exclude multicast\nfilter_str = \"not multicast\"\n\n# Only broadcast\nfilter_str = \"broadcast\"\n\n# Only multicast\nfilter_str = \"multicast\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#specific-threats","title":"Specific Threats","text":"<pre><code># DNS tunneling detection (large DNS responses)\nfilter_str = \"udp port 53 and greater 512\"\n\n# Potential DDoS (many connections from same source)\nfilter_str = \"tcp[tcpflags] &amp; tcp-syn != 0 and src host 192.168.1.100\"\n\n# ARP spoofing detection\nfilter_str = \"arp\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#performance-optimization","title":"Performance Optimization","text":""},{"location":"sniffer/packet-filtering/#efficient-filters","title":"Efficient Filters","text":"<pre><code># Good: Specific and efficient\nfilter_str = \"tcp port 443 and src net 192.168.1.0/24\"\n\n# Bad: Too broad, captures everything\nfilter_str = \"ip\"\n\n# Good: Combines related filters\nfilter_str = \"(port 80 or port 443) and tcp\"\n\n# Bad: Redundant\nfilter_str = \"tcp and tcp port 80\"  # \"tcp\" is redundant\n</code></pre>"},{"location":"sniffer/packet-filtering/#filter-order-matters","title":"Filter Order Matters","text":"<pre><code># More efficient (checks protocol first)\nfilter_str = \"tcp and port 443 and host 192.168.1.100\"\n\n# Less efficient (checks host first, broader)\nfilter_str = \"host 192.168.1.100 and port 443 and tcp\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#complex-filter-examples","title":"Complex Filter Examples","text":""},{"location":"sniffer/packet-filtering/#web-traffic-analysis","title":"Web Traffic Analysis","text":"<pre><code># All web traffic (HTTP + HTTPS)\nfilter_str = \"tcp and (port 80 or port 443 or port 8080)\"\n\n# Web traffic to/from specific subnet\nfilter_str = \"(tcp port 80 or tcp port 443) and (src net 192.168.1.0/24 or dst net 192.168.1.0/24)\"\n\n# Non-standard web ports\nfilter_str = \"tcp and (port 8080 or port 8443 or port 3000)\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#database-traffic","title":"Database Traffic","text":"<pre><code># MySQL\nfilter_str = \"tcp port 3306\"\n\n# PostgreSQL\nfilter_str = \"tcp port 5432\"\n\n# MongoDB\nfilter_str = \"tcp port 27017\"\n\n# Redis\nfilter_str = \"tcp port 6379\"\n\n# All common databases\nfilter_str = \"tcp and (port 3306 or port 5432 or port 27017 or port 6379)\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#network-diagnostics","title":"Network Diagnostics","text":"<pre><code># ICMP Echo (ping)\nfilter_str = \"icmp[icmptype] == icmp-echo or icmp[icmptype] == icmp-echoreply\"\n\n# Traceroute\nfilter_str = \"icmp or (udp and portrange 33434-33534)\"\n\n# Network errors\nfilter_str = \"icmp and (icmp[icmptype] == icmp-unreach or icmp[icmptype] == icmp-timxceed)\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#vpn-and-tunneling","title":"VPN and Tunneling","text":"<pre><code># OpenVPN\nfilter_str = \"udp port 1194\"\n\n# IPSec\nfilter_str = \"esp or ah or udp port 500\"\n\n# WireGuard\nfilter_str = \"udp port 51820\"\n\n# GRE tunnels\nfilter_str = \"proto gre\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#filter-testing","title":"Filter Testing","text":"<p>Test your filters before deployment:</p> <pre><code>from network_security_suite.sniffer import PacketCapture\n\ndef test_filter(filter_str, count=10):\n    \"\"\"Test a BPF filter\"\"\"\n    try:\n        capture = PacketCapture(\n            interface=\"eth0\",\n            filter_str=filter_str,\n            packet_count=count\n        )\n        print(f\"Filter valid: {filter_str}\")\n        capture.start()\n        print(f\"Captured {count} packets\")\n    except Exception as e:\n        print(f\"Filter error: {e}\")\n\n# Test various filters\ntest_filter(\"tcp port 80\")\ntest_filter(\"invalid filter\")  # Will show error\n</code></pre>"},{"location":"sniffer/packet-filtering/#common-mistakes","title":"Common Mistakes","text":""},{"location":"sniffer/packet-filtering/#1-incorrect-syntax","title":"1. Incorrect Syntax","text":"<pre><code># Wrong\nfilter_str = \"port = 80\"  # No '=' operator\n\n# Correct\nfilter_str = \"port 80\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#2-missing-quotes","title":"2. Missing Quotes","text":"<pre><code># Wrong (in YAML)\nfilter: tcp port 80  # Might be parsed incorrectly\n\n# Correct\nfilter: \"tcp port 80\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#3-overly-complex-filters","title":"3. Overly Complex Filters","text":"<pre><code># Too complex, hard to maintain\nfilter_str = \"((tcp port 80 or tcp port 443) and (src net 192.168.1.0/24 or dst net 192.168.1.0/24)) or ((udp port 53) and not (src host 8.8.8.8 or src host 8.8.4.4))\"\n\n# Better: Break into separate captures or simplify\nfilter_str = \"tcp and (port 80 or port 443)\"\n</code></pre>"},{"location":"sniffer/packet-filtering/#best-practices","title":"Best Practices","text":"<ol> <li>Start broad, then narrow: Begin with simple filters and add specificity</li> <li>Test filters: Always test on low-traffic interfaces first</li> <li>Document filters: Comment complex filters in configuration files</li> <li>Performance: More specific filters = better performance</li> <li>Security: Use filters to reduce attack surface</li> </ol>"},{"location":"sniffer/packet-filtering/#filter-reference","title":"Filter Reference","text":""},{"location":"sniffer/packet-filtering/#quick-reference-table","title":"Quick Reference Table","text":"Filter Description <code>tcp</code> TCP packets only <code>udp</code> UDP packets only <code>icmp</code> ICMP packets only <code>port N</code> Port N (src or dst) <code>src port N</code> Source port N <code>dst port N</code> Destination port N <code>host IP</code> IP address (src or dst) <code>src host IP</code> Source IP <code>dst host IP</code> Destination IP <code>net CIDR</code> Network range <code>greater N</code> Packets &gt; N bytes <code>less N</code> Packets &lt; N bytes <code>and</code> Logical AND <code>or</code> Logical OR <code>not</code> Logical NOT"},{"location":"sniffer/packet-filtering/#next-steps","title":"Next Steps","text":"<ul> <li>Practice with examples</li> <li>Read BPF manual</li> <li>Learn about configuration</li> <li>See API reference</li> </ul>"},{"location":"sniffer/api/exceptions/","title":"Exceptions API Reference","text":"<p>Custom exceptions for packet capture operations.</p>"},{"location":"sniffer/api/exceptions/#module-reference","title":"Module Reference","text":""},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions","title":"exceptions","text":"<p>Exception handler for different types of sniffing related exceptions.md.</p> <p>This module provides a comprehensive set of exception classes for the sniffer module. These exceptions.md help in identifying and handling specific error scenarios that may occur during network sniffing operations, packet processing, data conversion, and interface management.</p> <p>The exception hierarchy is organized as follows: - SnifferException: Base exception for all sniffer-related errors   - InterfaceException: Base for interface-related errors     - InterfaceNotFoundError: When a specified interface doesn't exist     - InterfacePermissionError: When permissions are insufficient for an interface     - InterfaceConfigurationError: When interface configuration is invalid   - PacketCaptureException: Base for packet capture errors     - PacketProcessingError: When processing a packet fails     - CaptureLimitExceededError: When capture limits are exceeded     - FilterError: When a BPF filter is invalid   - DataProcessingException: Base for data processing errors     - DataConversionError: When converting data between formats fails     - DataExportError: When exporting data fails     - DataImportError: When importing data fails   - ConfigurationException: Base for configuration errors     - InvalidConfigurationError: When configuration is invalid     - ConfigurationNotFoundError: When configuration is not found</p>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions-classes","title":"Classes","text":""},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.SnifferException","title":"SnifferException","text":"<pre><code>SnifferException(message='An error occurred in the sniffer module')\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception class for all sniffer-related errors.</p> <p>This is the parent class for all exceptions.md in the sniffer module. It provides a common base for catching all sniffer-related exceptions.md.</p> ATTRIBUTE DESCRIPTION <code>message</code> <p>Explanation of the error</p> <p> TYPE: <code>str</code> </p> <code>logger</code> <p>Logger for error messages</p> <p> TYPE: <code>ErrorLogger</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, message=\"An error occurred in the sniffer module\"):\n    self.message = message\n    self.logger = ErrorLogger()\n    self.logger.log(f\"SnifferException: {self.message}\")\n    super().__init__(self.message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.InterfaceException","title":"InterfaceException","text":"<pre><code>InterfaceException(interface='', message='An interface-related error occurred')\n</code></pre> <p>               Bases: <code>SnifferException</code></p> <p>Base exception for interface-related errors.</p> <p>This exception is raised when there's an issue with network interfaces.</p> ATTRIBUTE DESCRIPTION <code>interface</code> <p>Name of the interface that caused the error</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>Explanation of the error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, interface=\"\", message=\"An interface-related error occurred\"):\n    self.interface = interface\n    message_with_interface = (\n        f\"{message}\" if not interface else f\"{message} (Interface: {interface})\"\n    )\n    super().__init__(message_with_interface)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.InterfaceNotFoundError","title":"InterfaceNotFoundError","text":"<pre><code>InterfaceNotFoundError(interface='')\n</code></pre> <p>               Bases: <code>InterfaceException</code></p> <p>Exception raised when a specified interface doesn't exist.</p> <p>This exception is raised when trying to use a network interface that doesn't exist on the system.</p> ATTRIBUTE DESCRIPTION <code>interface</code> <p>Name of the interface that wasn't found</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, interface=\"\"):\n    super().__init__(interface, \"Network interface not found\")\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.InterfacePermissionError","title":"InterfacePermissionError","text":"<pre><code>InterfacePermissionError(interface='')\n</code></pre> <p>               Bases: <code>InterfaceException</code></p> <p>Exception raised when permissions are insufficient for an interface.</p> <p>This exception is raised when the user doesn't have sufficient permissions to access or use a network interface.</p> ATTRIBUTE DESCRIPTION <code>interface</code> <p>Name of the interface with permission issues</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, interface=\"\"):\n    super().__init__(interface, \"Insufficient permissions for network interface\")\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.InterfaceConfigurationError","title":"InterfaceConfigurationError","text":"<pre><code>InterfaceConfigurationError(interface='', config_issue='')\n</code></pre> <p>               Bases: <code>InterfaceException</code></p> <p>Exception raised when interface configuration is invalid.</p> <p>This exception is raised when there's an issue with the configuration of a network interface.</p> ATTRIBUTE DESCRIPTION <code>interface</code> <p>Name of the interface with configuration issues</p> <p> TYPE: <code>str</code> </p> <code>config_issue</code> <p>Description of the configuration issue</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, interface=\"\", config_issue=\"\"):\n    message = \"Invalid interface configuration\"\n    if config_issue:\n        message += f\": {config_issue}\"\n    super().__init__(interface, message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.PacketCaptureException","title":"PacketCaptureException","text":"<pre><code>PacketCaptureException(message='An error occurred during packet capture')\n</code></pre> <p>               Bases: <code>SnifferException</code></p> <p>Base exception for packet capture errors.</p> <p>This exception is raised when there's an issue with packet capturing.</p> ATTRIBUTE DESCRIPTION <code>message</code> <p>Explanation of the error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, message=\"An error occurred during packet capture\"):\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.PacketProcessingError","title":"PacketProcessingError","text":"<pre><code>PacketProcessingError(packet_id='', error_details='')\n</code></pre> <p>               Bases: <code>PacketCaptureException</code></p> <p>Exception raised when processing a packet fails.</p> <p>This exception is raised when there's an error processing a captured packet.</p> ATTRIBUTE DESCRIPTION <code>packet_id</code> <p>Identifier for the packet that caused the error</p> <p> TYPE: <code>str</code> </p> <code>error_details</code> <p>Details about the processing error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, packet_id=\"\", error_details=\"\"):\n    message = \"Error processing packet\"\n    if packet_id:\n        message += f\" (ID: {packet_id})\"\n    if error_details:\n        message += f\": {error_details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.CaptureLimitExceededError","title":"CaptureLimitExceededError","text":"<pre><code>CaptureLimitExceededError(limit_type='', limit_value=0, current_value=0)\n</code></pre> <p>               Bases: <code>PacketCaptureException</code></p> <p>Exception raised when capture limits are exceeded.</p> <p>This exception is raised when a capture operation exceeds defined limits such as maximum number of packets or memory usage.</p> ATTRIBUTE DESCRIPTION <code>limit_type</code> <p>Type of limit that was exceeded (e.g., \"packets\", \"memory\")</p> <p> TYPE: <code>str</code> </p> <code>limit_value</code> <p>Value of the limit that was exceeded</p> <p> TYPE: <code>int</code> </p> <code>current_value</code> <p>Current value that exceeded the limit</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, limit_type=\"\", limit_value=0, current_value=0):\n    message = \"Capture limit exceeded\"\n    if limit_type:\n        message += f\" for {limit_type}\"\n        if limit_value &gt; 0:\n            message += f\" (limit: {limit_value}\"\n            if current_value &gt; 0:\n                message += f\", current: {current_value}\"\n            message += \")\"\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.FilterError","title":"FilterError","text":"<pre><code>FilterError(filter_expression='', error_details='')\n</code></pre> <p>               Bases: <code>PacketCaptureException</code></p> <p>Exception raised when a BPF filter is invalid.</p> <p>This exception is raised when there's an issue with a Berkeley Packet Filter (BPF) used for packet capturing.</p> ATTRIBUTE DESCRIPTION <code>filter_expression</code> <p>The filter expression that caused the error</p> <p> TYPE: <code>str</code> </p> <code>error_details</code> <p>Details about the filter error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, filter_expression=\"\", error_details=\"\"):\n    message = \"Invalid packet filter\"\n    if filter_expression:\n        message += f\" (expression: '{filter_expression}')\"\n    if error_details:\n        message += f\": {error_details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.DataProcessingException","title":"DataProcessingException","text":"<pre><code>DataProcessingException(message='An error occurred during data processing')\n</code></pre> <p>               Bases: <code>SnifferException</code></p> <p>Base exception for data processing errors.</p> <p>This exception is raised when there's an issue with processing captured data.</p> ATTRIBUTE DESCRIPTION <code>message</code> <p>Explanation of the error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, message=\"An error occurred during data processing\"):\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.DataConversionError","title":"DataConversionError","text":"<pre><code>DataConversionError(source_format='', target_format='', error_details='')\n</code></pre> <p>               Bases: <code>DataProcessingException</code></p> <p>Exception raised when converting data between formats fails.</p> <p>This exception is raised when there's an error converting data between different formats (e.g., from raw packets to JSON, Pandas, or Polars).</p> ATTRIBUTE DESCRIPTION <code>source_format</code> <p>Format being converted from</p> <p> TYPE: <code>str</code> </p> <code>target_format</code> <p>Format being converted to</p> <p> TYPE: <code>str</code> </p> <code>error_details</code> <p>Details about the conversion error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, source_format=\"\", target_format=\"\", error_details=\"\"):\n    message = \"Error converting data\"\n    if source_format and target_format:\n        message += f\" from {source_format} to {target_format}\"\n    if error_details:\n        message += f\": {error_details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.DataExportError","title":"DataExportError","text":"<pre><code>DataExportError(export_format='', destination='', error_details='')\n</code></pre> <p>               Bases: <code>DataProcessingException</code></p> <p>Exception raised when exporting data fails.</p> <p>This exception is raised when there's an error exporting data to a file or external system.</p> ATTRIBUTE DESCRIPTION <code>export_format</code> <p>Format being exported to</p> <p> TYPE: <code>str</code> </p> <code>destination</code> <p>Destination of the export</p> <p> TYPE: <code>str</code> </p> <code>error_details</code> <p>Details about the export error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, export_format=\"\", destination=\"\", error_details=\"\"):\n    message = \"Error exporting data\"\n    if export_format:\n        message += f\" as {export_format}\"\n    if destination:\n        message += f\" to {destination}\"\n    if error_details:\n        message += f\": {error_details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.DataImportError","title":"DataImportError","text":"<pre><code>DataImportError(import_format='', source='', error_details='')\n</code></pre> <p>               Bases: <code>DataProcessingException</code></p> <p>Exception raised when importing data fails.</p> <p>This exception is raised when there's an error importing data from a file or external system.</p> ATTRIBUTE DESCRIPTION <code>import_format</code> <p>Format being imported from</p> <p> TYPE: <code>str</code> </p> <code>source</code> <p>Source of the import</p> <p> TYPE: <code>str</code> </p> <code>error_details</code> <p>Details about the import error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, import_format=\"\", source=\"\", error_details=\"\"):\n    message = \"Error importing data\"\n    if import_format:\n        message += f\" from {import_format}\"\n    if source:\n        message += f\" source {source}\"\n    if error_details:\n        message += f\": {error_details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.ConfigurationException","title":"ConfigurationException","text":"<pre><code>ConfigurationException(config_name='', message='A configuration error occurred')\n</code></pre> <p>               Bases: <code>SnifferException</code></p> <p>Base exception for configuration errors.</p> <p>This exception is raised when there's an issue with sniffer configuration.</p> ATTRIBUTE DESCRIPTION <code>config_name</code> <p>Name of the configuration that caused the error</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>Explanation of the error</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, config_name=\"\", message=\"A configuration error occurred\"):\n    self.config_name = config_name\n    message_with_config = (\n        f\"{message}\"\n        if not config_name\n        else f\"{message} (Configuration: {config_name})\"\n    )\n    super().__init__(message_with_config)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.InvalidConfigurationError","title":"InvalidConfigurationError","text":"<pre><code>InvalidConfigurationError(config_name='', config_value='', reason='')\n</code></pre> <p>               Bases: <code>ConfigurationException</code></p> <p>Exception raised when configuration is invalid.</p> <p>This exception is raised when a configuration value or setting is invalid.</p> ATTRIBUTE DESCRIPTION <code>config_name</code> <p>Name of the configuration that is invalid</p> <p> TYPE: <code>str</code> </p> <code>config_value</code> <p>Value of the configuration that is invalid</p> <p> TYPE: <code>str</code> </p> <code>reason</code> <p>Reason why the configuration is invalid</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, config_name=\"\", config_value=\"\", reason=\"\"):\n    message = \"Invalid configuration\"\n    if config_value:\n        message += f\" value: {config_value}\"\n    if reason:\n        message += f\" - {reason}\"\n    super().__init__(config_name, message)\n</code></pre>"},{"location":"sniffer/api/exceptions/#network_security_suite.sniffer.exceptions.ConfigurationNotFoundError","title":"ConfigurationNotFoundError","text":"<pre><code>ConfigurationNotFoundError(config_name='')\n</code></pre> <p>               Bases: <code>ConfigurationException</code></p> <p>Exception raised when configuration is not found.</p> <p>This exception is raised when a required configuration setting is missing.</p> ATTRIBUTE DESCRIPTION <code>config_name</code> <p>Name of the configuration that is missing</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/sniffer/exceptions.py</code> <pre><code>def __init__(self, config_name=\"\"):\n    super().__init__(config_name, \"Configuration not found\")\n</code></pre>"},{"location":"sniffer/api/exceptions/#usage-examples","title":"Usage Examples","text":""},{"location":"sniffer/api/exceptions/#handling-exceptions","title":"Handling Exceptions","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\nfrom network_security_suite.sniffer.exceptions import (\n    InterfaceError,\n    CaptureError,\n    FilterError,\n    PermissionError\n)\n\ntry:\n    capture = PacketCapture(interface=\"eth0\", filter_str=\"tcp\")\n    capture.start()\nexcept InterfaceError as e:\n    print(f\"Interface not found: {e}\")\nexcept FilterError as e:\n    print(f\"Invalid filter: {e}\")\nexcept CaptureError as e:\n    print(f\"Capture failed: {e}\")\nexcept PermissionError as e:\n    print(f\"Permission denied: {e}\")\n</code></pre>"},{"location":"sniffer/api/exceptions/#see-also","title":"See Also","text":"<ul> <li>PacketCapture API</li> <li>Getting Started Guide</li> </ul>"},{"location":"sniffer/api/interfaces/","title":"Interfaces API Reference","text":"<p>Network interface discovery and management utilities.</p>"},{"location":"sniffer/api/interfaces/#module-reference","title":"Module Reference","text":""},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces","title":"interfaces","text":"<p>interfaces.py This module contains the Interface class for detecting and managing network interfaces. Compatible with multiple operating systems.</p>"},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces-classes","title":"Classes","text":""},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface","title":"Interface","text":"<pre><code>Interface(config=None, interface=None, interface_detection_method=None, log_dir=None)\n</code></pre> <p>Initialize the Interface class with configuration support.</p> Source code in <code>src/network_security_suite/sniffer/interfaces.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[SnifferConfig] = None,\n    interface: Optional[str] = None,  # Legacy support\n    interface_detection_method: Optional[str] = None,  # Legacy support\n    log_dir: Optional[str] = None,  # Legacy support\n):\n    \"\"\"Initialize the Interface class with configuration support.\"\"\"\n    # Import here to avoid circular imports\n    from .sniffer_config import SnifferConfig\n\n    # Use provided config or create default\n    self.config = config if config is not None else SnifferConfig()\n\n    # Legacy support - override config with direct parameters if provided\n    if interface is not None:\n        self.config.interface = interface\n    if interface_detection_method is not None:\n        self.config.interface_detection_method = interface_detection_method\n    if log_dir is not None:\n        self.config.log_dir = log_dir\n\n    # Initialize loggers\n    self.info_logger = InfoLogger(log_dir=self.config.log_dir)\n    self.debug_logger = DebugLogger(log_dir=self.config.log_dir)\n    self.error_logger = ErrorLogger(log_dir=self.config.log_dir)\n\n    self.os_type = platform.system().lower()\n    self.interfaces = {}\n    self.VALID_IFACE_CHARS = set(string.ascii_letters + string.digits + \"-_.\")\n\n    try:\n        self.interfaces = self._get_interfaces()\n        self.info_logger.log(f\"Detected {len(self.interfaces)} network interfaces\")\n    except Exception as e:\n        self.error_logger.log(f\"Error detecting interfaces: {str(e)}\")\n        self.interfaces = {}\n</code></pre>"},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface-functions","title":"Functions","text":""},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface.get_recommended_interface","title":"get_recommended_interface","text":"<pre><code>get_recommended_interface()\n</code></pre> <p>Get a recommended interface based on configuration preferences.</p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: The name of the recommended interface, or None if no suitable interface is found.</p> Source code in <code>src/network_security_suite/sniffer/interfaces.py</code> <pre><code>def get_recommended_interface(self) -&gt; Optional[str]:\n    \"\"\"\n    Get a recommended interface based on configuration preferences.\n\n    Returns:\n        Optional[str]: The name of the recommended interface, or None if no suitable interface is found.\n    \"\"\"\n    if not self.interfaces:\n        self.error_logger.log(\"No interfaces available for recommendation\")\n        return None\n\n    # If a specific interface is configured and exists, use it\n    if (\n        self.config.interface\n        and self.config.interface in self.interfaces\n        and self.config.interface_detection_method == \"manual\"\n    ):\n        return self.config.interface\n\n    # Auto-detection based on preferences\n    if self.config.interface_detection_method == \"auto\":\n        # Get active interfaces first\n        active_interfaces = self.get_active_interfaces()\n\n        # Filter by preferred types\n        for preferred_type in self.config.preferred_interface_types:\n            matching_interfaces = [\n                iface\n                for iface in active_interfaces\n                if self.interfaces[iface].get(\"type\") == preferred_type\n            ]\n            if matching_interfaces:\n                selected = matching_interfaces[0]  # Take the first match\n                self.info_logger.log(\n                    f\"Auto-selected interface: {selected} (type: {preferred_type})\"\n                )\n                return selected\n\n        # If no preferred type matches, return the first active interface\n        if active_interfaces:\n            selected = active_interfaces[0]\n            self.info_logger.log(f\"Auto-selected interface: {selected} (fallback)\")\n            return selected\n\n    self.error_logger.log(\"No suitable interface found\")\n    return None\n</code></pre>"},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface.validate_interface","title":"validate_interface","text":"<pre><code>validate_interface(interface_name)\n</code></pre> <p>Validate interface name based on config security settings.</p> Source code in <code>src/network_security_suite/sniffer/interfaces.py</code> <pre><code>def validate_interface(self, interface_name: str) -&gt; bool:\n    \"\"\"Validate interface name based on config security settings.\"\"\"\n    if not self.config.validate_interface_names:\n        return True\n\n    return self._is_valid_interface_name(interface_name)\n</code></pre>"},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface.show_available_interfaces","title":"show_available_interfaces","text":"<pre><code>show_available_interfaces()\n</code></pre> <p>Display all available network interfaces with their details.</p> <p>Prints a formatted list of all detected network interfaces and their properties to the console, including name, MAC address, IP addresses, interface type, and state.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>src/network_security_suite/sniffer/interfaces.py</code> <pre><code>def show_available_interfaces(self) -&gt; None:\n    \"\"\"\n    Display all available network interfaces with their details.\n\n    Prints a formatted list of all detected network interfaces and their properties\n    to the console, including name, MAC address, IP addresses, interface type, and state.\n\n    Returns:\n        None\n    \"\"\"\n    self.info_logger.log(f\"Displaying {len(self.interfaces)} network interfaces\")\n    print(f\"\\nNetwork Interfaces on {self.os_type.capitalize()}:\")\n    print(\"-\" * 60)\n    for name, info in self.interfaces.items():\n        print(f\"Interface: {name}\")\n        self.debug_logger.log(f\"Displaying details for interface: {name}\")\n        for key, value in info.items():\n            if key != \"name\":\n                print(f\"  {key}: {value}\")\n        print(\"-\" * 60)\n    self.info_logger.log(\"Finished displaying network interfaces\")\n</code></pre>"},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface.get_interface_by_type","title":"get_interface_by_type","text":"<pre><code>get_interface_by_type(type_name)\n</code></pre> <p>Get all interfaces of a specific type.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>The type of interface to filter by. Valid values include: 'loopback', 'ethernet', 'wireless', 'docker', 'virtual', 'vpn', 'unknown'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of interface names that match the specified type. Returns an empty list if no interfaces of the specified type are found.</p> Source code in <code>src/network_security_suite/sniffer/interfaces.py</code> <pre><code>def get_interface_by_type(self, type_name: str) -&gt; List[str]:\n    \"\"\"\n    Get all interfaces of a specific type.\n\n    Args:\n        type_name (str): The type of interface to filter by. Valid values include:\n            'loopback', 'ethernet', 'wireless', 'docker', 'virtual', 'vpn', 'unknown'.\n\n    Returns:\n        List[str]: A list of interface names that match the specified type.\n            Returns an empty list if no interfaces of the specified type are found.\n    \"\"\"\n    self.debug_logger.log(f\"Filtering interfaces by type: {type_name}\")\n    interfaces = [\n        name for name, info in self.interfaces.items() if info[\"type\"] == type_name\n    ]\n    self.info_logger.log(\n        f\"Found {len(interfaces)} interfaces of type '{type_name}'\"\n    )\n    return interfaces\n</code></pre>"},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface.get_active_interfaces","title":"get_active_interfaces","text":"<pre><code>get_active_interfaces()\n</code></pre> <p>Get all active network interfaces.</p> <p>Returns a list of interface names that have their state set to 'UP'. Note that this may not be accurate on all systems, particularly Windows, where the state information might not be available.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: A list of active interface names. Returns an empty list if no active interfaces are found.</p> Source code in <code>src/network_security_suite/sniffer/interfaces.py</code> <pre><code>def get_active_interfaces(self) -&gt; List[str]:\n    \"\"\"\n    Get all active network interfaces.\n\n    Returns a list of interface names that have their state set to 'UP'.\n    Note that this may not be accurate on all systems, particularly Windows,\n    where the state information might not be available.\n\n    Returns:\n        List[str]: A list of active interface names.\n            Returns an empty list if no active interfaces are found.\n    \"\"\"\n    self.debug_logger.log(\"Filtering interfaces by active state (UP)\")\n    active_interfaces = [\n        name for name, info in self.interfaces.items() if info.get(\"state\") == \"UP\"\n    ]\n    self.info_logger.log(f\"Found {len(active_interfaces)} active interfaces\")\n    return active_interfaces\n</code></pre>"},{"location":"sniffer/api/interfaces/#network_security_suite.sniffer.interfaces.Interface.get_interface_info","title":"get_interface_info","text":"<pre><code>get_interface_info(interface_name)\n</code></pre> <p>Get detailed information about a specific network interface.</p> PARAMETER DESCRIPTION <code>interface_name</code> <p>The name of the interface to retrieve information for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the interface properties including name, MAC address, IP addresses, type, and state (if available). Returns an empty dictionary if the specified interface is not found.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/network_security_suite/sniffer/interfaces.py</code> <pre><code>def get_interface_info(self, interface_name: str) -&gt; dict:\n    \"\"\"\n    Get detailed information about a specific network interface.\n\n    Args:\n        interface_name (str): The name of the interface to retrieve information for.\n\n    Returns:\n        dict: A dictionary containing the interface properties including name, MAC address,\n            IP addresses, type, and state (if available). Returns an empty dictionary\n            if the specified interface is not found.\n    \"\"\"\n    self.debug_logger.log(f\"Retrieving information for interface: {interface_name}\")\n    interface_info = self.interfaces.get(interface_name, {})\n    if interface_info:\n        self.info_logger.log(f\"Found interface information for {interface_name}\")\n    else:\n        self.error_logger.log(f\"Interface not found: {interface_name}\")\n    return interface_info\n</code></pre>"},{"location":"sniffer/api/interfaces/#usage-examples","title":"Usage Examples","text":""},{"location":"sniffer/api/interfaces/#list-available-interfaces","title":"List Available Interfaces","text":"<pre><code>from network_security_suite.sniffer.interfaces import get_available_interfaces\n\n# Get all interfaces\ninterfaces = get_available_interfaces()\nfor iface in interfaces:\n    print(f\"Interface: {iface['name']}\")\n    print(f\"  IP: {iface.get('ip', 'N/A')}\")\n    print(f\"  MAC: {iface.get('mac', 'N/A')}\")\n    print(f\"  Status: {iface.get('status', 'unknown')}\")\n</code></pre>"},{"location":"sniffer/api/interfaces/#get-default-interface","title":"Get Default Interface","text":"<pre><code>from network_security_suite.sniffer.interfaces import get_default_interface\n\n# Get default interface\ndefault_iface = get_default_interface()\nprint(f\"Default interface: {default_iface}\")\n</code></pre>"},{"location":"sniffer/api/interfaces/#check-interface-status","title":"Check Interface Status","text":"<pre><code>from network_security_suite.sniffer.interfaces import is_interface_up\n\n# Check if interface is up\nif is_interface_up(\"eth0\"):\n    print(\"Interface is up\")\nelse:\n    print(\"Interface is down\")\n</code></pre>"},{"location":"sniffer/api/interfaces/#see-also","title":"See Also","text":"<ul> <li>PacketCapture API</li> <li>Getting Started Guide</li> </ul>"},{"location":"sniffer/api/loggers/","title":"Loggers API Reference","text":"<p>Specialized logger classes for different types of logging events.</p>"},{"location":"sniffer/api/loggers/#module-reference","title":"Module Reference","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers","title":"loggers","text":"<p>Logging module for the sniffer component.</p> <p>This module provides specialized logger classes for different handler types used in the network security suite's sniffer module.</p>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers-classes","title":"Classes","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.ConsoleLogger","title":"ConsoleLogger","text":"<pre><code>ConsoleLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for console output.</p> <p>This logger is designed for displaying log messages in the console with a simple format focused on readability.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"console_handler\": HandlerConfig(\n            \"console\", logging.INFO, Formatter(\"%(message)s\")\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.ConsoleLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.ConsoleLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.SecurityLogger","title":"SecurityLogger","text":"<pre><code>SecurityLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for security-related events.</p> <p>This logger captures security-related events and warnings, storing them in a dedicated log file.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"security_handler\": HandlerConfig(\n            \"security\",\n            logging.WARNING,\n            Formatter(\"%(asctime)s [SECURITY] %(message)s\"),\n            filepath=\"logs/security.log\",\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.SecurityLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.SecurityLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.PacketLogger","title":"PacketLogger","text":"<pre><code>PacketLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for packet-related information.</p> <p>This logger is specialized for logging packet capture and processing information, useful for debugging and analysis.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"packet_handler\": HandlerConfig(\n            \"packet\",\n            logging.DEBUG,\n            Formatter(\"%(asctime)s [PACKET] %(message)s\"),\n            filepath=\"logs/packets.log\",\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.PacketLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.PacketLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.FileLogger","title":"FileLogger","text":"<pre><code>FileLogger(filepath='logs/general.log', log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for general file-based logging.</p> <p>This logger writes log messages to a specified file with a standard format.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self,\n    filepath: str = \"logs/general.log\",\n    log_format: Optional[Formatter] = None,\n    log_dir: Optional[str] = None,\n):\n    handlers: HandlerTypes = {\n        \"file_handler\": HandlerConfig(\n            \"file\",\n            logging.INFO,\n            Formatter(\"%(asctime)s [%(levelname)s] %(message)s\"),\n            filepath=filepath,\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.FileLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.FileLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.RotatingFileLogger","title":"RotatingFileLogger","text":"<pre><code>RotatingFileLogger(filepath='logs/rotating.log', max_bytes=10485760, backup_count=5, log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger with rotating file capability.</p> <p>This logger writes to files that rotate when they reach a certain size, useful for managing log file sizes in long-running applications.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self,\n    filepath: str = \"logs/rotating.log\",\n    max_bytes: int = 10485760,  # 10MB\n    backup_count: int = 5,\n    log_format: Optional[Formatter] = None,\n    log_dir: Optional[str] = None,\n):\n    handlers: HandlerTypes = {\n        \"rotating_file_handler\": HandlerConfig(\n            \"rotating_file\",\n            logging.INFO,\n            Formatter(\"%(asctime)s [%(levelname)s] %(message)s\"),\n            filepath=filepath,\n            max_bytes=max_bytes,\n            backup_count=backup_count,\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.RotatingFileLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.RotatingFileLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.TimedRotatingFileLogger","title":"TimedRotatingFileLogger","text":"<pre><code>TimedRotatingFileLogger(filepath='logs/timed_rotating.log', log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger with time-based file rotation.</p> <p>This logger writes to files that rotate at specified time intervals, useful for organizing logs by time periods.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self,\n    filepath: str = \"logs/timed_rotating.log\",\n    log_format: Optional[Formatter] = None,\n    log_dir: Optional[str] = None,\n):\n    # Note: TimedRotatingFileHandler would need to be implemented in HandlerConfig\n    # For now, using regular rotating file handler\n    handlers: HandlerTypes = {\n        \"timed_rotating_file_handler\": HandlerConfig(\n            \"timed_rotating_file\",\n            logging.INFO,\n            Formatter(\"%(asctime)s [%(levelname)s] %(message)s\"),\n            filepath=filepath,\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.TimedRotatingFileLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.TimedRotatingFileLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.ErrorLogger","title":"ErrorLogger","text":"<pre><code>ErrorLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for error messages.</p> <p>This logger is dedicated to capturing and storing error messages for debugging and troubleshooting.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"error_handler\": HandlerConfig(\n            \"error\",\n            logging.ERROR,\n            Formatter(\"%(asctime)s [ERROR] %(message)s\"),\n            filepath=\"logs/error.log\",\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.ErrorLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.ErrorLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.DebugLogger","title":"DebugLogger","text":"<pre><code>DebugLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for debug messages.</p> <p>This logger captures detailed debug information useful during development and troubleshooting.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"debug_handler\": HandlerConfig(\n            \"debug\",\n            logging.DEBUG,\n            Formatter(\"%(asctime)s [DEBUG] %(message)s\"),\n            filepath=\"logs/debug.log\",\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.DebugLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.DebugLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.CriticalLogger","title":"CriticalLogger","text":"<pre><code>CriticalLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for critical messages.</p> <p>This logger captures critical issues that require immediate attention.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"critical_handler\": HandlerConfig(\n            \"critical\",\n            logging.CRITICAL,\n            Formatter(\"%(asctime)s [CRITICAL] %(message)s\"),\n            filepath=\"logs/critical.log\",\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.CriticalLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.CriticalLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.WarningLogger","title":"WarningLogger","text":"<pre><code>WarningLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for warning messages.</p> <p>This logger captures warning messages that indicate potential issues.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"warning_handler\": HandlerConfig(\n            \"warning\",\n            logging.WARNING,\n            Formatter(\"%(asctime)s [WARNING] %(message)s\"),\n            filepath=\"logs/warning.log\",\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.WarningLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.WarningLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.InfoLogger","title":"InfoLogger","text":"<pre><code>InfoLogger(log_format=None, log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Logger for informational messages.</p> <p>This logger captures general informational messages about system operation.</p> Source code in <code>src/network_security_suite/sniffer/loggers.py</code> <pre><code>def __init__(\n    self, log_format: Optional[Formatter] = None, log_dir: Optional[str] = None\n):\n    handlers: HandlerTypes = {\n        \"info_handler\": HandlerConfig(\n            \"info\",\n            logging.INFO,\n            Formatter(\"%(asctime)s [INFO] %(message)s\"),\n            filepath=\"logs/info.log\",\n            log_dir=log_dir,\n        )\n    }\n    super().__init__(log_format=log_format, handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.InfoLogger-functions","title":"Functions","text":""},{"location":"sniffer/api/loggers/#network_security_suite.sniffer.loggers.InfoLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"sniffer/api/loggers/#usage-examples","title":"Usage Examples","text":""},{"location":"sniffer/api/loggers/#console-logger","title":"Console Logger","text":"<pre><code>from network_security_suite.sniffer import ConsoleLogger\n\nlogger = ConsoleLogger(level=\"INFO\")\nlogger.info(\"Application started\")\n</code></pre>"},{"location":"sniffer/api/loggers/#file-logger","title":"File Logger","text":"<pre><code>from network_security_suite.sniffer import FileLogger\n\nlogger = FileLogger(\n    filename=\"app.log\",\n    level=\"DEBUG\"\n)\nlogger.debug(\"Debug message\")\n</code></pre>"},{"location":"sniffer/api/loggers/#rotating-file-logger","title":"Rotating File Logger","text":"<pre><code>from network_security_suite.sniffer import RotatingFileLogger\n\nlogger = RotatingFileLogger(\n    filename=\"app.log\",\n    max_bytes=10485760,  # 10MB\n    backup_count=5\n)\n</code></pre>"},{"location":"sniffer/api/loggers/#security-logger","title":"Security Logger","text":"<pre><code>from network_security_suite.sniffer import SecurityLogger\n\nsecurity_logger = SecurityLogger(\n    filename=\"security.log\",\n    level=\"WARNING\"\n)\nsecurity_logger.warning(\"Suspicious activity detected\")\n</code></pre>"},{"location":"sniffer/api/loggers/#packet-logger","title":"Packet Logger","text":"<pre><code>from network_security_suite.sniffer import PacketLogger\n\npacket_logger = PacketLogger(filename=\"packets.log\")\npacket_logger.info(f\"Captured packet: {packet.summary()}\")\n</code></pre>"},{"location":"sniffer/api/loggers/#see-also","title":"See Also","text":"<ul> <li>PacketCapture API</li> <li>Configuration Guide</li> </ul>"},{"location":"sniffer/api/packet-capture/","title":"PacketCapture API Reference","text":"<p>The <code>PacketCapture</code> class is the main interface for capturing network packets.</p>"},{"location":"sniffer/api/packet-capture/#overview","title":"Overview","text":"<p>PacketCapture provides a high-level API for capturing network traffic from network interfaces. It handles packet filtering, buffering, and storage.</p>"},{"location":"sniffer/api/packet-capture/#class-reference","title":"Class Reference","text":""},{"location":"sniffer/api/packet-capture/#network_security_suite.sniffer.packet_capture.PacketCapture","title":"PacketCapture","text":"<pre><code>PacketCapture(config=None, realtime_display=False)\n</code></pre> <p>Class for capturing and processing network packets from a specified interface.</p> <p>This class uses the scapy library to capture packets from a network interface and converts them into appropriate packet models based on their protocol type.</p> ATTRIBUTE DESCRIPTION <code>interface</code> <p>The name of the network interface to capture packets from.</p> <p> TYPE: <code>str</code> </p> <code>packets</code> <p>A list of captured packet objects.</p> <p> TYPE: <code>list[Packet]</code> </p> <p>Initialize PacketCapture with configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration object. Defaults to None.</p> <p> TYPE: <code>Optional[SnifferConfig]</code> DEFAULT: <code>None</code> </p> <code>realtime_display</code> <p>Enable real-time packet display. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/network_security_suite/sniffer/packet_capture.py</code> <pre><code>def __init__(\n    self, config: Optional[SnifferConfig] = None, realtime_display: bool = False\n):\n    \"\"\"\n    Initialize PacketCapture with configuration.\n\n    Args:\n        config (Optional[SnifferConfig], optional): Configuration object. Defaults to None.\n        realtime_display (bool, optional): Enable real-time packet display. Defaults to False.\n    \"\"\"\n    # Import here to avoid circular imports\n    import os\n\n    from .sniffer_config import SnifferConfig\n\n    # Use provided config or create default\n    self.config = config if config is not None else SnifferConfig()\n\n    # Use config values directly\n    self.interface = self.config.interface\n    self.max_memory_packets = self.config.max_memory_packets\n    self.log_dir = self.config.log_dir\n\n    # Initialize loggers using config\n    self.info_logger = InfoLogger(log_dir=self.config.log_dir)\n    self.debug_logger = DebugLogger(log_dir=self.config.log_dir)\n    self.error_logger = ErrorLogger(log_dir=self.config.log_dir)\n    self.packet_logger = PacketLogger(log_dir=self.config.log_dir)\n\n    # Validation using config values\n    if self.config.max_memory_packets &lt; 100:\n        self.error_logger.log(\n            f\"Invalid max_memory_packets value: {self.config.max_memory_packets}\"\n        )\n        raise ValueError(\"max_memory_packets must be at least 100\")\n\n    if self.config.max_memory_packets % 10 != 0:\n        self.error_logger.log(\n            f\"Invalid max_memory_packets value: {self.config.max_memory_packets}\"\n        )\n        raise ValueError(\"max_memory_packets must be multiple of 10\")\n\n    # Initialize other attributes\n    self.packets: list[Packet] = []\n    self.packet_queue: Queue[list[Packet]] = Queue()\n    self.is_running: bool = False\n    self.max_processing_batch = self.config.max_processing_batch_size\n    self.stats_lock = Lock()\n    self.stats = {\n        \"processed_packets\": 0,\n        \"dropped_packets\": 0,\n        \"processing_time\": 0.0,\n        \"batch_count\": 0,\n    }\n\n    # Real-time display attributes\n    # Use realtime_display parameter if provided, otherwise use config value\n    self.realtime_display = (\n        realtime_display\n        if realtime_display\n        else self.config.enable_realtime_display\n    )\n    self.realtime_packets = deque(maxlen=50)  # Store last 50 packets for display\n    self.display_thread = None\n    self.display_running = False\n\n    self.info_logger.log(\n        f\"Initializing PacketCapture for interface: {self.config.interface}\"\n    )\n\n    if self.config.max_memory_packets &lt; 100:\n        self.error_logger.log(\n            f\"Invalid max_memory_packets value: {self.config.max_memory_packets}, must be at least 100\"\n        )\n        raise ValueError(\"max_memory_packets must be at least 100\")\n    if self.config.max_memory_packets % 10 != 0:\n        self.error_logger.log(\n            f\"Invalid max_memory_packets value: {self.config.max_memory_packets}, must be multiple of 10\"\n        )\n        raise ValueError(\n            \"max_memory_packets must be multiple of 10 for faster processing\"\n        )\n\n    self.packets: list[Packet] = []\n    self.packet_queue: Queue[list[Packet]] = Queue()\n    self.is_running: bool = False\n    self.max_processing_batch = self.config.max_processing_batch_size\n    self.stats_lock = Lock()\n    self.stats = {\n        \"processed_packets\": 0,\n        \"dropped_packets\": 0,\n        \"processing_time\": 0.0,\n        \"batch_count\": 0,\n    }\n    self.debug_logger.log(\n        f\"PacketCapture initialized with max_memory_packets: {self.max_memory_packets}, \"\n        f\"max_processing_batch: {self.max_processing_batch}\"\n    )\n</code></pre>"},{"location":"sniffer/api/packet-capture/#network_security_suite.sniffer.packet_capture.PacketCapture-functions","title":"Functions","text":""},{"location":"sniffer/api/packet-capture/#usage-examples","title":"Usage Examples","text":""},{"location":"sniffer/api/packet-capture/#basic-capture","title":"Basic Capture","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\n\n# Create and start capture\ncapture = PacketCapture(\n    interface=\"eth0\",\n    packet_count=1000,\n    filter_str=\"tcp port 80\"\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/api/packet-capture/#async-capture","title":"Async Capture","text":"<pre><code># Start capture in background\ncapture = PacketCapture(interface=\"eth0\")\ncapture.start_async()\n\n# Do other work...\n\n# Stop when done\ncapture.stop()\n</code></pre>"},{"location":"sniffer/api/packet-capture/#get-statistics","title":"Get Statistics","text":"<pre><code>capture = PacketCapture(interface=\"eth0\")\ncapture.start()\n\nstats = capture.get_stats()\nprint(f\"Packets captured: {stats['captured']}\")\nprint(f\"Packets dropped: {stats['dropped']}\")\n</code></pre>"},{"location":"sniffer/api/packet-capture/#from-configuration","title":"From Configuration","text":"<pre><code>from network_security_suite.sniffer.sniffer_config import SnifferConfig\n\nconfig = SnifferConfig.from_yaml(\"config.yaml\")\ncapture = PacketCapture.from_config(config)\ncapture.start()\n</code></pre>"},{"location":"sniffer/api/packet-capture/#parameters","title":"Parameters","text":""},{"location":"sniffer/api/packet-capture/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Default Description <code>interface</code> str None Network interface name <code>packet_count</code> int 0 Number of packets to capture (0=unlimited) <code>timeout</code> int | None None Capture timeout in seconds <code>promisc</code> bool True Enable promiscuous mode <code>filter_str</code> str \"\" BPF filter string <code>output_file</code> str | None None Output Parquet file path <code>buffer_size</code> int 65536 Packet buffer size <code>snaplen</code> int 65535 Snapshot length"},{"location":"sniffer/api/packet-capture/#methods","title":"Methods","text":""},{"location":"sniffer/api/packet-capture/#start","title":"start()","text":"<p>Start packet capture (blocking).</p> <pre><code>capture.start()\n</code></pre> <p>Returns: None</p> <p>Raises: - <code>PermissionError</code>: If insufficient permissions - <code>InterfaceError</code>: If interface not found</p>"},{"location":"sniffer/api/packet-capture/#start_async","title":"start_async()","text":"<p>Start packet capture in background thread.</p> <pre><code>capture.start_async()\n</code></pre> <p>Returns: None</p>"},{"location":"sniffer/api/packet-capture/#stop","title":"stop()","text":"<p>Stop packet capture.</p> <pre><code>capture.stop()\n</code></pre> <p>Returns: None</p>"},{"location":"sniffer/api/packet-capture/#set_filterfilter_str-str","title":"set_filter(filter_str: str)","text":"<p>Update the BPF filter.</p> <pre><code>capture.set_filter(\"tcp port 443\")\n</code></pre> <p>Parameters: - <code>filter_str</code> (str): BPF filter string</p> <p>Returns: None</p> <p>Raises: - <code>ValueError</code>: If filter string is invalid</p>"},{"location":"sniffer/api/packet-capture/#get_stats","title":"get_stats()","text":"<p>Get capture statistics.</p> <pre><code>stats = capture.get_stats()\n</code></pre> <p>Returns: dict with keys: - <code>captured</code>: Number of packets captured - <code>dropped</code>: Number of packets dropped - <code>interface_dropped</code>: Number dropped by interface</p>"},{"location":"sniffer/api/packet-capture/#properties","title":"Properties","text":""},{"location":"sniffer/api/packet-capture/#interface","title":"interface","text":"<p>Get the current interface name.</p> <pre><code>iface = capture.interface\n</code></pre>"},{"location":"sniffer/api/packet-capture/#is_running","title":"is_running","text":"<p>Check if capture is currently running.</p> <pre><code>if capture.is_running:\n    print(\"Capture is active\")\n</code></pre>"},{"location":"sniffer/api/packet-capture/#packets_captured","title":"packets_captured","text":"<p>Get number of packets captured so far.</p> <pre><code>count = capture.packets_captured\n</code></pre>"},{"location":"sniffer/api/packet-capture/#events-and-callbacks","title":"Events and Callbacks","text":""},{"location":"sniffer/api/packet-capture/#packet-callback","title":"Packet Callback","text":"<p>Process packets as they are captured:</p> <pre><code>def packet_handler(packet):\n    print(f\"Captured: {packet.summary()}\")\n\ncapture = PacketCapture(\n    interface=\"eth0\",\n    packet_callback=packet_handler\n)\n</code></pre>"},{"location":"sniffer/api/packet-capture/#statistics-callback","title":"Statistics Callback","text":"<p>Get periodic statistics:</p> <pre><code>def stats_callback(stats):\n    print(f\"Captured: {stats['captured']}, Dropped: {stats['dropped']}\")\n\ncapture = PacketCapture(\n    interface=\"eth0\",\n    stats_callback=stats_callback,\n    stats_interval=10  # Every 10 seconds\n)\n</code></pre>"},{"location":"sniffer/api/packet-capture/#error-handling","title":"Error Handling","text":"<pre><code>from network_security_suite.sniffer import PacketCapture\nfrom network_security_suite.sniffer.exceptions import (\n    InterfaceError,\n    CaptureError,\n    FilterError\n)\n\ntry:\n    capture = PacketCapture(interface=\"invalid\")\n    capture.start()\nexcept InterfaceError as e:\n    print(f\"Interface error: {e}\")\nexcept FilterError as e:\n    print(f\"Filter error: {e}\")\nexcept CaptureError as e:\n    print(f\"Capture error: {e}\")\nexcept PermissionError as e:\n    print(f\"Permission denied: {e}\")\n</code></pre>"},{"location":"sniffer/api/packet-capture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"sniffer/api/packet-capture/#buffer-size","title":"Buffer Size","text":"<p>Adjust buffer size based on traffic volume:</p> <pre><code># High traffic\ncapture = PacketCapture(\n    interface=\"eth0\",\n    buffer_size=524288  # 512KB\n)\n\n# Low traffic\ncapture = PacketCapture(\n    interface=\"eth0\",\n    buffer_size=65536   # 64KB\n)\n</code></pre>"},{"location":"sniffer/api/packet-capture/#snapshot-length","title":"Snapshot Length","text":"<p>Reduce snaplen to capture only headers:</p> <pre><code># Capture only headers (faster)\ncapture = PacketCapture(\n    interface=\"eth0\",\n    snaplen=128  # Just headers\n)\n\n# Capture full packets\ncapture = PacketCapture(\n    interface=\"eth0\",\n    snaplen=65535  # Full packets\n)\n</code></pre>"},{"location":"sniffer/api/packet-capture/#thread-safety","title":"Thread Safety","text":"<p>PacketCapture is thread-safe. You can safely call methods from multiple threads:</p> <pre><code>import threading\n\ncapture = PacketCapture(interface=\"eth0\")\n\n# Start in one thread\nstart_thread = threading.Thread(target=capture.start_async)\nstart_thread.start()\n\n# Stop from another thread\ndef stop_after_delay():\n    time.sleep(60)\n    capture.stop()\n\nstop_thread = threading.Thread(target=stop_after_delay)\nstop_thread.start()\n</code></pre>"},{"location":"sniffer/api/packet-capture/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Configuration Guide</li> <li>Packet Filtering Guide</li> <li>ParquetProcessing API</li> <li>Interfaces API</li> </ul>"},{"location":"sniffer/api/parquet-processing/","title":"ParquetProcessing API Reference","text":"<p>The <code>ParquetProcessing</code> module handles conversion and processing of captured packets to/from Parquet format.</p>"},{"location":"sniffer/api/parquet-processing/#module-reference","title":"Module Reference","text":""},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing","title":"parquet_processing","text":"<p>Parquet Processing Module for Network Security Suite.</p> <p>This module provides functionality for capturing network packets and storing them in Parquet format, which is an efficient columnar storage format. It also provides functionality for loading previously saved packet data from Parquet files.</p> <p>The module uses the Polars library for DataFrame operations and the PyArrow library for Parquet file handling. It integrates with the PacketCapture class to capture network packets and the Interface class to manage network interfaces.</p> <p>Key features: - Comprehensive logging with InfoLogger, DebugLogger, and ErrorLogger - Performance monitoring with metrics for timing and memory usage - Efficient packet capture and storage in Parquet format - Data analysis utilities for examining captured packet data</p> Example usage"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing--basic-usage","title":"Basic usage","text":"<p>config = SnifferConfig(interface=\"eth0\") processor = ParquetProcessing(config=config) processor.save_packets(filepath=\"/path/to/output.parquet\") df = processor.load_packets(filepath=\"/path/to/output.parquet\") processor.show_dataframe_stats(df)</p>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing--with-real-time-display-enabled-in-config","title":"With real-time display enabled in config","text":"<p>config = SnifferConfig(interface=\"eth0\", enable_realtime_display=True) processor = ParquetProcessing(config=config) processor.save_packets(filepath=\"/path/to/output.parquet\")</p>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing--with-real-time-display-enabled-for-a-specific-capture","title":"With real-time display enabled for a specific capture","text":"<p>config = SnifferConfig(interface=\"eth0\") processor = ParquetProcessing(config=config) processor.save_packets(filepath=\"/path/to/output.parquet\", realtime=True)</p>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing-classes","title":"Classes","text":""},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing","title":"ParquetProcessing","text":"<pre><code>ParquetProcessing(config=None)\n</code></pre> <p>A class for capturing network packets and storing them in Parquet format.</p> <p>This class provides methods for capturing network packets from specified interfaces, processing them into structured data models, and saving them to Parquet files. It also provides methods for loading previously saved packet data from Parquet files.</p> <p>Parquet is an efficient columnar storage format that is well-suited for storing and querying large datasets, making it ideal for network packet capture data.</p> <p>The class includes comprehensive logging capabilities using InfoLogger, DebugLogger, and ErrorLogger to track operations, debug issues, and record errors. It also integrates performance monitoring through the performance_metrics utility to track execution time and resource usage of key operations.</p> ATTRIBUTE DESCRIPTION <code>interface</code> <p>The name of the network interface to capture packets from.</p> <p> TYPE: <code>str</code> </p> <code>log_dir</code> <p>Directory where log files are stored.</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Configuration object with settings for packet capture.</p> <p> TYPE: <code>SnifferConfig</code> </p> <code>info_logger</code> <p>Logger for informational messages.</p> <p> TYPE: <code>InfoLogger</code> </p> <code>debug_logger</code> <p>Logger for debug messages.</p> <p> TYPE: <code>DebugLogger</code> </p> <code>error_logger</code> <p>Logger for error messages.</p> <p> TYPE: <code>ErrorLogger</code> </p> <code>perf_metrics</code> <p>Performance monitoring utility.</p> <p> TYPE: <code>PerformanceMetricsProxy</code> </p> <code>realtime_display</code> <p>Whether real-time display of packets is enabled.</p> <p> TYPE: <code>bool</code> </p> <code>realtime_packets</code> <p>Queue of packets for real-time display.</p> <p> TYPE: <code>deque</code> </p> <code>display_thread</code> <p>Thread for real-time display.</p> <p> TYPE: <code>Thread</code> </p> <code>display_running</code> <p>Whether the real-time display thread is running.</p> <p> TYPE: <code>bool</code> </p> <p>Initialize a new ParquetProcessing instance.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration object. Defaults to None.</p> <p> TYPE: <code>Optional[SnifferConfig]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/network_security_suite/sniffer/parquet_processing.py</code> <pre><code>def __init__(self, config: Optional[SnifferConfig] = None):\n    \"\"\"\n    Initialize a new ParquetProcessing instance.\n\n    Args:\n        config (Optional[SnifferConfig], optional): Configuration object. Defaults to None.\n    \"\"\"\n    # Use configuration if provided\n    self.config = config if config is not None else SnifferConfig()\n\n    # Get values from config\n    self.interface = self.config.interface\n    self.log_dir = self.config.log_dir if self.config.log_to_file else None\n\n    # Initialize loggers\n    self.info_logger = InfoLogger(log_dir=self.log_dir)\n    self.debug_logger = DebugLogger(log_dir=self.log_dir)\n    self.error_logger = ErrorLogger(log_dir=self.log_dir)\n\n    # Initialize performance metrics\n    self.perf_metrics = perf\n\n    # Initialize real-time display attributes\n    self.realtime_display = self.config.enable_realtime_display\n    self.realtime_packets = deque(maxlen=50)  # Store last 50 packets for display\n    self.display_thread = None\n    self.display_running = False\n\n    self.info_logger.log(\n        f\"Initializing ParquetProcessing for interface: {self.interface}\"\n    )\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing-functions","title":"Functions","text":""},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing.save_packets","title":"save_packets","text":"<pre><code>save_packets(filepath='', interface_type='', max_packets=None, realtime=None)\n</code></pre> <p>Capture network packets and save them to a Parquet file.</p> <p>This method captures network packets from the specified interface type, processes them into a structured format, and saves them to a Parquet file. It also displays information about the captured packets and performance statistics.</p> <p>The method performs the following steps: 1. Initialize the interface and capture packets 2. Display captured packets and performance statistics 3. Convert the packets to a Polars DataFrame 4. Add date and hour columns based on the timestamp 5. Save the DataFrame to a Parquet file (or CSV if PyArrow is not available)</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The path where the Parquet file will be saved. If empty, uses the export_dir from config.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>interface_type</code> <p>The type of interface to capture packets from. If empty, uses the preferred_interface_types from config.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>max_packets</code> <p>Maximum number of packets to capture. If None, uses the packet_count from config.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>realtime</code> <p>Enable real-time display of packets. If None, uses the value from config.enable_realtime_display.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If no network interfaces are found or if no filepath is provided.</p> <code>Exception</code> <p>If there's an error processing the DataFrame or writing to the file.</p> Source code in <code>src/network_security_suite/sniffer/parquet_processing.py</code> <pre><code>@perf.monitor(\"save_packets\")\ndef save_packets(\n    self,\n    filepath: str = \"\",\n    interface_type: str = \"\",\n    max_packets: int = None,\n    realtime: bool = None,\n    # compression_type: str = \"zstd\",\n) -&gt; None:\n    \"\"\"\n    Capture network packets and save them to a Parquet file.\n\n    This method captures network packets from the specified interface type,\n    processes them into a structured format, and saves them to a Parquet file.\n    It also displays information about the captured packets and performance statistics.\n\n\n    The method performs the following steps:\n    1. Initialize the interface and capture packets\n    2. Display captured packets and performance statistics\n    3. Convert the packets to a Polars DataFrame\n    4. Add date and hour columns based on the timestamp\n    5. Save the DataFrame to a Parquet file (or CSV if PyArrow is not available)\n\n    Args:\n        filepath (str, optional): The path where the Parquet file will be saved.\n            If empty, uses the export_dir from config.\n        interface_type (str, optional): The type of interface to capture packets from.\n            If empty, uses the preferred_interface_types from config.\n        max_packets (int, optional): Maximum number of packets to capture.\n            If None, uses the packet_count from config.\n        realtime (bool, optional): Enable real-time display of packets.\n            If None, uses the value from config.enable_realtime_display.\n\n    Raises:\n        ValueError: If no network interfaces are found or if no filepath is provided.\n        Exception: If there's an error processing the DataFrame or writing to the file.\n    \"\"\"\n    # Start performance monitoring\n    start_time = time.time()\n    # Use configuration values if parameters are not provided\n    if not filepath:\n        timestamp = int(time.time())\n        filepath = os.path.join(\n            self.config.export_dir,\n            f\"packets_{self.interface}_{timestamp}.{self.config.export_format}\",\n        )\n\n    if not interface_type and self.config.preferred_interface_types:\n        interface_type = self.config.preferred_interface_types[0]\n    elif not interface_type:\n        interface_type = \"wireless\"  # Default fallback\n\n    if max_packets is None:\n        max_packets = (\n            self.config.packet_count if self.config.packet_count &gt; 0 else 10000\n        )\n\n    # Set realtime display flag\n    # Use realtime parameter if provided, otherwise use config value\n    if realtime is None:\n        realtime = self.realtime_display\n    self.realtime_display = realtime\n\n    self.info_logger.log(f\"Starting packet capture and save to {filepath}\")\n    self.debug_logger.log(\n        f\"Using interface type: {interface_type}, realtime={realtime}\"\n    )\n\n    # Initialize interface and capture packets\n    interface_manager = Interface(log_dir=self.log_dir)\n    working_interface = interface_manager.get_interface_by_type(interface_type)\n\n    if not working_interface:\n        self.debug_logger.log(\n            f\"No interfaces of type {interface_type} found, using first active interface\"\n        )\n        all_interfaces = interface_manager.get_active_interfaces()\n        if not all_interfaces:\n            self.error_logger.log(\"No network interfaces found\")\n            raise InterfaceNotFoundError(\"No network interfaces found\")\n        interface_name = all_interfaces[0]\n    else:\n        interface_name = working_interface[0]\n\n    self.info_logger.log(f\"Using interface: {interface_name}\")\n    print(f\"Using interface: {interface_name}\")\n\n    # Create a new config with the selected interface\n    capture_config = SnifferConfig(\n        interface=interface_name,\n        log_dir=self.log_dir,\n        # Copy other relevant settings from the original config\n        packet_count=self.config.packet_count,\n        max_memory_packets=self.config.max_memory_packets,\n        log_level=self.config.log_level,\n        export_format=self.config.export_format,\n        export_dir=self.config.export_dir,\n        performance_parquet_path=self.config.performance_parquet_path,\n        enable_realtime_display=self.realtime_display,\n    )\n\n    # Create PacketCapture with the new configuration\n    capture = PacketCapture(config=capture_config)\n    self.info_logger.log(f\"Starting packet capture ({max_packets} packets)...\")\n    print(f\"Starting packet capture ({max_packets} packets)...\")\n\n    # Start real-time display if requested\n    if self.realtime_display:\n        self.debug_logger.log(\"Starting real-time display thread\")\n        self.start_realtime_display()\n\n    try:\n        # Pass the realtime flag to the capture method\n        capture.capture(max_packets=max_packets, realtime=self.realtime_display)\n    finally:\n        # Stop real-time display if it was started\n        if self.realtime_display:\n            self.debug_logger.log(\"Stopping real-time display thread\")\n            self.stop_realtime_display()\n\n    # Display captured packets\n    self.debug_logger.log(\"Displaying captured packets\")\n    print(\"\\nCaptured Packets:\")\n    capture.show_packets()\n\n    # Display performance statistics\n    self.debug_logger.log(\"Displaying performance statistics\")\n    print(\"\\nPerformance Statistics:\")\n    capture.show_stats()\n\n    # Convert to Polars DataFrame and add date/time columns\n    self.info_logger.log(\"Converting to Polars DataFrame\")\n    print(\"\\nConverting to Polars DataFrame...\")\n    df_pl = capture.to_polars_df()\n\n    try:\n        # Verify timestamp is a datetime type\n        self.debug_logger.log(\"Verifying timestamp data type\")\n        if df_pl.schema[\"timestamp\"] != pl.Datetime:\n            self.debug_logger.log(\"Converting timestamp to datetime type\")\n            df_pl = df_pl.with_columns(\n                [pl.col(\"timestamp\").cast(pl.Datetime).alias(\"timestamp\")]\n            )\n\n        # Add date and hour columns\n        self.debug_logger.log(\"Adding date and hour columns\")\n        df_pl = df_pl.with_columns(\n            [\n                pl.col(\"timestamp\").dt.date().alias(\"date\"),\n                pl.col(\"timestamp\").dt.hour().alias(\"hour\"),\n            ]\n        )\n\n        self.debug_logger.log(f\"DataFrame shape: {df_pl.shape}\")\n        print(f\"DataFrame shape: {df_pl.shape}\")\n        print(f\"DataFrame schema: {df_pl.schema}\")\n\n        # Check if filepath is provided\n        if not filepath:\n            self.error_logger.log(\"No filepath provided for saving the data file\")\n            raise ValueError(\"No filepath provided for saving the data file\")\n\n        # Determine export format from filepath or config\n        export_format = self.config.export_format\n        if \".\" in filepath:\n            file_extension = filepath.split(\".\")[-1].lower()\n            if file_extension in [\"parquet\", \"csv\"]:\n                export_format = file_extension\n\n        self.info_logger.log(\n            f\"Writing DataFrame to {filepath} in {export_format} format\"\n        )\n\n        if export_format.lower() == \"parquet\":\n            df_pl.write_parquet(\n                file=filepath,\n                compression=\"zstd\",  # Best for network data\n                row_group_size=50000,  # Good for time-series analysis\n                statistics=True,\n                use_pyarrow=True,\n            )\n        elif export_format.lower() == \"csv\":\n            df_pl.write_csv(\n                file=filepath,\n                has_header=True,\n            )\n        else:\n            self.error_logger.log(f\"Unsupported export format: {export_format}\")\n            raise ValueError(f\"Unsupported export format: {export_format}\")\n        self.info_logger.log(f\"Successfully wrote DataFrame to {filepath}\")\n        print(f\"Successfully wrote DataFrame to {filepath}\")\n\n    except ValueError as ve:\n        # End performance monitoring - error case\n        end_time = time.time()\n        elapsed_time = end_time - start_time\n        self.perf_metrics._log_metric(\n            {\n                \"timestamp\": datetime.now(),\n                \"type\": \"end_save_packets\",\n                \"label\": \"save_packets\",\n                \"value\": round(elapsed_time, 4),\n                \"filepath\": filepath,\n                \"error\": str(ve),\n                \"status\": \"error\",\n            }\n        )\n\n        error_msg = f\"Error converting DataFrame to Parquet: {str(ve)}\"\n        self.error_logger.log(error_msg)\n        raise DataConversionError(\n            source_format=\"DataFrame\",\n            target_format=\"Parquet\",\n            error_details=str(ve),\n        ) from ve\n    except Exception as e:\n        # End performance monitoring - error case\n        end_time = time.time()\n        elapsed_time = end_time - start_time\n        self.perf_metrics._log_metric(\n            {\n                \"timestamp\": datetime.now(),\n                \"type\": \"end_save_packets\",\n                \"label\": \"save_packets\",\n                \"value\": round(elapsed_time, 4),\n                \"filepath\": filepath,\n                \"error\": str(e),\n                \"status\": \"error\",\n            }\n        )\n\n        error_msg = f\"Error exporting data to {filepath}: {str(e)}\"\n        self.error_logger.log(error_msg)\n        raise DataExportError(\n            export_format=\"Parquet\", destination=filepath, error_details=str(e)\n        ) from e\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing.load_packets","title":"load_packets","text":"<pre><code>load_packets(filepath='')\n</code></pre> <p>Load packet data from a Parquet file.</p> <p>This method reads a Parquet file containing packet data and returns it as a Polars DataFrame. The DataFrame can then be used for analysis, visualization, or further processing.</p> <p>Performance metrics for this operation are automatically captured using the performance monitoring system.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The path to the Parquet file to load. If empty, a ValueError will be raised.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A Polars DataFrame containing the packet data.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no filepath is provided.</p> <code>FileNotFoundError</code> <p>If the specified file does not exist.</p> <code>Exception</code> <p>If there's an error reading the Parquet file.</p> Source code in <code>src/network_security_suite/sniffer/parquet_processing.py</code> <pre><code>@perf.monitor(\"load_packets\")\ndef load_packets(self, filepath: str = \"\") -&gt; pl.DataFrame:\n    \"\"\"\n    Load packet data from a Parquet file.\n\n    This method reads a Parquet file containing packet data and returns it as a\n    Polars DataFrame. The DataFrame can then be used for analysis, visualization,\n    or further processing.\n\n    Performance metrics for this operation are automatically captured using the\n    performance monitoring system.\n\n    Args:\n        filepath (str, optional): The path to the Parquet file to load.\n            If empty, a ValueError will be raised.\n\n    Returns:\n        pl.DataFrame: A Polars DataFrame containing the packet data.\n\n    Raises:\n        ValueError: If no filepath is provided.\n        FileNotFoundError: If the specified file does not exist.\n        Exception: If there's an error reading the Parquet file.\n    \"\"\"\n    self.info_logger.log(f\"Loading packet data from {filepath}\")\n\n    if not filepath:\n        self.error_logger.log(\"No filepath provided for loading the Parquet file\")\n        raise ValueError(\"No filepath provided for loading the Parquet file\")\n\n    try:\n        self.debug_logger.log(f\"Reading Parquet file: {filepath}\")\n        df_pl = pl.read_parquet(filepath)\n\n        self.info_logger.log(\n            f\"Successfully loaded DataFrame with shape: {df_pl.shape}\"\n        )\n        return df_pl\n    except FileNotFoundError as e:\n        self.error_logger.log(f\"File not found: {filepath}, Error: {e}\")\n        raise\n    except Exception as e:\n        error_msg = f\"Error importing data from {filepath}: {str(e)}\"\n        self.error_logger.log(error_msg)\n        raise DataImportError(\n            import_format=\"Parquet\", source=filepath, error_details=str(e)\n        ) from e\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing.show_dataframe_stats","title":"show_dataframe_stats","text":"<pre><code>show_dataframe_stats(df)\n</code></pre> <p>Display statistics about a DataFrame.</p> <p>This method prints various statistics about a DataFrame, including its shape, schema, and basic descriptive statistics for each column. It's useful for getting a quick overview of the data.</p> <p>Performance metrics for this operation are automatically captured using the performance monitoring system.</p> PARAMETER DESCRIPTION <code>df</code> <p>The DataFrame to analyze.</p> <p> TYPE: <code>DataFrame</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the DataFrame is empty.</p> Source code in <code>src/network_security_suite/sniffer/parquet_processing.py</code> <pre><code>@perf.monitor(\"show_dataframe_stats\")\ndef show_dataframe_stats(self, df: pl.DataFrame) -&gt; None:\n    \"\"\"\n    Display statistics about a DataFrame.\n\n    This method prints various statistics about a DataFrame, including its shape,\n    schema, and basic descriptive statistics for each column. It's useful for\n    getting a quick overview of the data.\n\n    Performance metrics for this operation are automatically captured using the\n    performance monitoring system.\n\n    Args:\n        df (pl.DataFrame): The DataFrame to analyze.\n\n    Raises:\n        ValueError: If the DataFrame is empty.\n    \"\"\"\n    self.info_logger.log(\"Generating DataFrame statistics\")\n\n    if df.is_empty():\n        self.error_logger.log(\"Cannot show statistics for empty DataFrame\")\n        raise ValueError(\"DataFrame is empty\")\n\n    self.debug_logger.log(f\"DataFrame shape: {df.shape}\")\n    print(\"\\n\" + \"=\" * 50)\n    print(\"DATAFRAME STATISTICS\")\n    print(\"=\" * 50)\n    print(f\"Shape: {df.shape}\")\n    print(f\"Number of rows: {df.height}\")\n    print(f\"Number of columns: {df.width}\")\n\n    self.debug_logger.log(\"Displaying DataFrame schema\")\n    print(\"\\nSchema:\")\n    for name, dtype in df.schema.items():\n        print(f\"  {name}: {dtype}\")\n\n    print(\"\\nColumn Statistics:\")\n    # Get basic statistics for each column\n    try:\n        self.debug_logger.log(\"Computing descriptive statistics\")\n        stats = df.describe()\n        print(stats)\n    except Exception as e:\n        error_msg = f\"Could not compute statistics: {e}\"\n        self.error_logger.log(error_msg)\n        raise DataProcessingException(error_msg) from e\n\n    # Show unique values for categorical columns (if not too many)\n    self.debug_logger.log(\"Analyzing categorical columns for unique values\")\n    print(\"\\nUnique Values for Selected Columns:\")\n    for col in df.columns:\n        try:\n            if df[col].dtype in [pl.Utf8, pl.Categorical]:\n                unique_values = df[col].unique()\n                if (\n                    len(unique_values) &lt;= 10\n                ):  # Only show if not too many unique values\n                    self.debug_logger.log(\n                        f\"Found {len(unique_values)} unique values for column {col}\"\n                    )\n                    print(f\"  {col}: {unique_values.to_list()}\")\n        except Exception as e:\n            self.debug_logger.log(f\"Error processing column {col}: {str(e)}\")\n            # Skip to the next column if there's an error processing this one\n            continue\n\n    self.info_logger.log(\"Completed DataFrame statistics display\")\n    print(\"=\" * 50)\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing.start_realtime_display","title":"start_realtime_display","text":"<pre><code>start_realtime_display()\n</code></pre> <p>Start the real-time display thread.</p> Source code in <code>src/network_security_suite/sniffer/parquet_processing.py</code> <pre><code>def start_realtime_display(self):\n    \"\"\"Start the real-time display thread.\"\"\"\n    if self.realtime_display and not self.display_running:\n        self.display_running = True\n        self.display_thread = Thread(target=self._realtime_display_loop)\n        self.display_thread.daemon = True\n        self.display_thread.start()\n        self.info_logger.log(\"Started real-time display thread\")\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing.stop_realtime_display","title":"stop_realtime_display","text":"<pre><code>stop_realtime_display()\n</code></pre> <p>Stop the real-time display thread.</p> Source code in <code>src/network_security_suite/sniffer/parquet_processing.py</code> <pre><code>def stop_realtime_display(self):\n    \"\"\"Stop the real-time display thread.\"\"\"\n    self.display_running = False\n    if self.display_thread:\n        self.display_thread.join(\n            timeout=2\n        )  # Wait up to 2 seconds for thread to finish\n        self.info_logger.log(\"Stopped real-time display thread\")\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#network_security_suite.sniffer.parquet_processing.ParquetProcessing.analyze_packet_data","title":"analyze_packet_data","text":"<pre><code>analyze_packet_data(df, group_by='protocol')\n</code></pre> <p>Analyze packet data by grouping and aggregating.</p> <p>This method provides more advanced analysis of packet data by grouping by a specified column and calculating various aggregations like count, mean packet size, and time ranges.</p> <p>Performance metrics for this operation are automatically captured using the performance monitoring system.</p> PARAMETER DESCRIPTION <code>df</code> <p>The DataFrame containing packet data.</p> <p> TYPE: <code>DataFrame</code> </p> <code>group_by</code> <p>Column to group by. Defaults to \"protocol\". Common options include \"protocol\", \"src_ip\", \"dst_ip\", \"src_port\", \"dst_port\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'protocol'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pl.DataFrame: A DataFrame with the analysis results.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the DataFrame is empty or doesn't contain the required columns.</p> <code>DataProcessingException</code> <p>If there's an error during analysis.</p> Source code in <code>src/network_security_suite/sniffer/parquet_processing.py</code> <pre><code>@perf.monitor(\"analyze_packet_data\")\ndef analyze_packet_data(\n    self, df: pl.DataFrame, group_by: str = \"protocol\"\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Analyze packet data by grouping and aggregating.\n\n    This method provides more advanced analysis of packet data by grouping\n    by a specified column and calculating various aggregations like count,\n    mean packet size, and time ranges.\n\n    Performance metrics for this operation are automatically captured using the\n    performance monitoring system.\n\n    Args:\n        df (pl.DataFrame): The DataFrame containing packet data.\n        group_by (str, optional): Column to group by. Defaults to \"protocol\".\n            Common options include \"protocol\", \"src_ip\", \"dst_ip\", \"src_port\", \"dst_port\".\n\n    Returns:\n        pl.DataFrame: A DataFrame with the analysis results.\n\n    Raises:\n        ValueError: If the DataFrame is empty or doesn't contain the required columns.\n        DataProcessingException: If there's an error during analysis.\n    \"\"\"\n    self.info_logger.log(f\"Analyzing packet data grouped by {group_by}\")\n\n    if df.is_empty():\n        self.error_logger.log(\"Cannot analyze empty DataFrame\")\n        raise ValueError(\"DataFrame is empty\")\n\n    if group_by not in df.columns:\n        self.error_logger.log(f\"Column {group_by} not found in DataFrame\")\n        raise ValueError(f\"Column {group_by} not found in DataFrame\")\n\n    try:\n        # Create analysis DataFrame with aggregations\n        self.debug_logger.log(\n            f\"Grouping by {group_by} and calculating aggregations\"\n        )\n\n        # Check if packet_size column exists\n        size_agg = []\n        if \"packet_size\" in df.columns:\n            size_agg = [\n                pl.col(\"packet_size\").mean().alias(f\"avg_{group_by}_packet_size\"),\n                pl.col(\"packet_size\").sum().alias(f\"total_{group_by}_bytes\"),\n                pl.col(\"packet_size\").min().alias(f\"min_{group_by}_packet_size\"),\n                pl.col(\"packet_size\").max().alias(f\"max_{group_by}_packet_size\"),\n            ]\n\n        # Check if timestamp column exists\n        time_agg = []\n        if \"timestamp\" in df.columns:\n            time_agg = [\n                pl.col(\"timestamp\").min().alias(f\"first_{group_by}_packet_time\"),\n                pl.col(\"timestamp\").max().alias(f\"last_{group_by}_packet_time\"),\n            ]\n\n        # Create the analysis DataFrame\n        analysis_df = df.group_by(group_by).agg(\n            [pl.count().alias(f\"{group_by}_packet_count\"), *size_agg, *time_agg]\n        )\n\n        # Sort by packet count in descending order\n        analysis_df = analysis_df.sort(f\"{group_by}_packet_count\", descending=True)\n\n        # Display the results\n        print(\"\\n\" + \"=\" * 50)\n        print(f\"PACKET ANALYSIS BY {group_by.upper()}\")\n        print(\"=\" * 50)\n        print(analysis_df)\n        print(\"=\" * 50)\n\n        self.info_logger.log(f\"Completed packet analysis by {group_by}\")\n        return analysis_df\n\n    except Exception as e:\n        error_msg = f\"Error analyzing packet data: {e}\"\n        self.error_logger.log(error_msg)\n        raise DataProcessingException(error_msg) from e\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#usage-examples","title":"Usage Examples","text":""},{"location":"sniffer/api/parquet-processing/#basic-usage","title":"Basic Usage","text":"<pre><code>from network_security_suite.sniffer.parquet_processing import ParquetProcessor\n\n# Process captured packets\nprocessor = ParquetProcessor(\"capture.parquet\")\n\n# Get summary\nsummary = processor.get_summary()\nprint(summary)\n\n# Filter by protocol\ntcp_packets = processor.filter_by_protocol(\"TCP\")\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#writing-packets","title":"Writing Packets","text":"<pre><code>from network_security_suite.sniffer.parquet_processing import write_packets_to_parquet\n\n# Write packets to Parquet\nwrite_packets_to_parquet(\n    packets=packet_list,\n    output_file=\"output.parquet\",\n    compression=\"snappy\"\n)\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#reading-packets","title":"Reading Packets","text":"<pre><code>from network_security_suite.sniffer.parquet_processing import read_packets_from_parquet\n\n# Read packets from Parquet\npackets_df = read_packets_from_parquet(\"capture.parquet\")\nprint(packets_df.head())\n</code></pre>"},{"location":"sniffer/api/parquet-processing/#see-also","title":"See Also","text":"<ul> <li>PacketCapture API</li> <li>Getting Started Guide</li> </ul>"},{"location":"sniffer/api/sniffer-config/","title":"SnifferConfig API Reference","text":"<p>Configuration management for the sniffer module.</p>"},{"location":"sniffer/api/sniffer-config/#module-reference","title":"Module Reference","text":""},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config","title":"sniffer_config","text":"<p>Sniffer Configuration Module</p> <p>This module provides the SnifferConfig class for managing all configuration aspects of the network sniffer components. It handles loading configurations from YAML files, saving configurations to YAML files, and provides default values for all settings.</p> <p>The configuration is organized into several categories: - Interface settings: Network interface selection and detection - Capture settings: Packet capture parameters and filtering - Logging configuration: Log levels, formats, and destinations - Export settings: Data export formats and locations - Performance settings: Performance monitoring and optimization - Security settings: Security validations and sanitization</p> Example"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config--create-a-default-configuration","title":"Create a default configuration","text":"<p>config = SnifferConfig()</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config--load-configuration-from-a-yaml-file","title":"Load configuration from a YAML file","text":"<p>config = SnifferConfig.from_yaml('path/to/config.yaml')</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config--save-configuration-to-a-yaml-file","title":"Save configuration to a YAML file","text":"<p>config.to_yaml('path/to/new_config.yaml')</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config--generate-a-default-configuration-file","title":"Generate a default configuration file","text":"<p>SnifferConfig.generate_default_config('path/to/default_config.yaml')</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config-classes","title":"Classes","text":""},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig","title":"SnifferConfig  <code>dataclass</code>","text":"<pre><code>SnifferConfig(interface='eth0', interface_detection_method='auto', preferred_interface_types=(lambda: ['ethernet', 'wireless'])(), filter_expression='', packet_count=0, timeout=0, promiscuous_mode=True, max_memory_packets=10000, max_processing_batch_size=100, num_threads=4, enable_realtime_display=False, log_level='INFO', log_to_file=True, log_dir='/home/batman/Documents/networkguard2/logs/logs', log_format='%(asctime)s [%(levelname)s] %(name)s: %(message)s', enable_console_logging=True, enable_file_logging=True, enable_security_logging=True, enable_packet_logging=True, enable_performance_logging=True, max_log_file_size=10485760, log_backup_count=5, export_format='parquet', export_dir='/home/batman/Documents/networkguard2/logs/parquet', enable_performance_monitoring=True, performance_log_interval=60, performance_parquet_path='/home/batman/Documents/networkguard2/logs/performance_metrics/perf_metrics.parquet', validate_interface_names=True, sanitize_filter_expressions=True, max_filter_length=200)\n</code></pre> <p>Configuration class for all network sniffer components.</p> <p>This class centralizes all configuration parameters for the network sniffer, providing a single point of configuration for interface selection, packet capture, logging, data export, performance monitoring, and security settings.</p> <p>The class is implemented as a dataclass with default values for all parameters, making it easy to create a working configuration with minimal setup. It also provides methods for loading configurations from YAML files and saving configurations to YAML files.</p> <p>When instantiated, the class ensures that all required directories exist, creating them if necessary.</p> <p>Attributes are organized into logical groups for easier management: - Interface settings - Capture settings - Logging configuration - Export settings - Performance settings - Security settings</p> Constructor Parameters <p>All parameters are optional and have sensible defaults.</p> Example"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--interface-settings","title":"Interface Settings:","text":"<p>interface (str): Name of the network interface to use (e.g., \"eth0\", \"wlan0\"). Default: \"eth0\"</p> <p>interface_detection_method (str): Method for detecting interfaces (\"auto\", \"manual\", \"preferred_type\"). Default: \"auto\"</p> <p>preferred_interface_types (List[str]): List of interface types in order of preference. Default: [\"ethernet\", \"wireless\"]</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--capture-settings","title":"Capture Settings:","text":"<p>filter_expression (str): BPF filter expression for filtering packets.                         Default: \"\" (no filtering) packet_count (int): Maximum number of packets to capture (0 = unlimited).                    Default: 0</p> <p>timeout (int): Maximum time in seconds to capture packets (0 = no timeout).               Default: 0 promiscuous_mode (bool): Whether to put the interface in promiscuous mode.                         Default: True max_memory_packets (int): Maximum number of packets to store in memory.                          Must be at least 100 and a multiple of 10.                          Default: 10000 max_processing_batch_size (int): Maximum number of packets to process in a single batch.                                 Default: 100 num_threads (int): Number of threads to use for packet processing.                   Default: 4 enable_realtime_display (bool): Whether to enable real-time display of captured packets.                               Default: False</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--logging-configuration","title":"Logging Configuration:","text":"<p>log_level (str): Logging level (\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\").                 Default: \"INFO\" log_to_file (bool): Whether to write log messages to files.                    Default: True log_dir (str): Directory where log files will be stored.               Default: \"/home/batman/Documents/networkguard2/logs/logs\" log_format (str): Format string for log messages.                  Default: \"%(asctime)s [%(levelname)s] %(name)s: %(message)s\" enable_console_logging (bool): Whether to enable logging to the console.                               Default: True enable_file_logging (bool): Whether to enable logging to files.                            Default: True enable_security_logging (bool): Whether to enable security-related logging.                                Default: True enable_packet_logging (bool): Whether to enable packet-level logging.                              Default: True enable_performance_logging (bool): Whether to enable performance metric logging.                                   Default: True max_log_file_size (int): Maximum size of a log file in bytes before rotation.                         Default: 10485760 (10MB) log_backup_count (int): Number of rotated log files to keep.                        Default: 5</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--export-settings","title":"Export Settings:","text":"<p>export_format (str): Format for exporting captured packet data (\"parquet\", \"csv\").                     Default: \"parquet\" export_dir (str): Directory where exported packet data files will be stored.                  Default: \"/home/batman/Documents/networkguard2/logs/parquet\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--performance-settings","title":"Performance Settings:","text":"<p>enable_performance_monitoring (bool): Whether to enable performance monitoring.                                      Default: True performance_log_interval (int): Interval in seconds between performance metric logging.                                Default: 60 performance_parquet_path (str): Path to the Parquet file for performance metrics.                                Default: \"/home/batman/Documents/networkguard2/logs/performance_metrics/perf_metrics.parquet\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--security-settings","title":"Security Settings:","text":"<p>validate_interface_names (bool): Whether to validate network interface names.                                 Default: True sanitize_filter_expressions (bool): Whether to sanitize BPF filter expressions.                                    Default: True max_filter_length (int): Maximum allowed length for BPF filter expressions.                         Default: 200</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--create-a-configuration-with-default-values","title":"Create a configuration with default values","text":"<p>config = SnifferConfig()</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--create-a-configuration-with-custom-values","title":"Create a configuration with custom values","text":"<p>config = SnifferConfig(     interface=\"wlan0\",     packet_count=1000,     log_level=\"DEBUG\" )</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig--use-the-configuration-with-a-packet-capture","title":"Use the configuration with a packet capture","text":"<p>capture = PacketCapture(config=config)</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig-attributes","title":"Attributes","text":""},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.interface","title":"interface  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interface = 'eth0'\n</code></pre> <p>Name of the network interface to use for packet capture.</p> <p>This is the name of the network interface as recognized by the operating system (e.g., 'eth0', 'wlan0', 'en0'). If interface_detection_method is set to 'manual', this value will be used directly. Otherwise, it may be overridden by the automatic interface detection.</p> <p>Default: \"eth0\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.interface_detection_method","title":"interface_detection_method  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interface_detection_method = 'auto'\n</code></pre> <p>Method to use for detecting the network interface.</p> <p>Valid values: - 'auto': Automatically select the best available interface - 'manual': Use the interface specified in the 'interface' attribute - 'preferred_type': Select an interface based on the types in 'preferred_interface_types'</p> <p>Default: \"auto\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.preferred_interface_types","title":"preferred_interface_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>preferred_interface_types = field(default_factory=lambda: ['ethernet', 'wireless'])\n</code></pre> <p>List of preferred interface types in order of preference.</p> <p>Used when interface_detection_method is 'preferred_type' to select an interface based on its type. The first matching interface type in the list will be selected.</p> <p>Common types include: - 'ethernet': Wired Ethernet interfaces - 'wireless': Wi-Fi interfaces - 'loopback': Loopback interfaces (for testing) - 'virtual': Virtual interfaces</p> <p>Default: [\"ethernet\", \"wireless\"]</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.filter_expression","title":"filter_expression  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter_expression = ''\n</code></pre> <p>Berkeley Packet Filter (BPF) expression for filtering captured packets.</p> <p>This expression follows the BPF syntax and allows filtering packets based on various criteria such as protocol, port, host, etc. For example: - \"tcp port 80\": Capture only TCP traffic on port 80 - \"host 192.168.1.1\": Capture only traffic to/from the specified host - \"icmp\": Capture only ICMP packets</p> <p>An empty string means no filtering (capture all packets).</p> <p>Default: \"\" (no filtering)</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.packet_count","title":"packet_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>packet_count = 0\n</code></pre> <p>Maximum number of packets to capture before stopping.</p> <p>If set to 0, packet capture will continue indefinitely until stopped manually or by timeout.</p> <p>Default: 0 (unlimited)</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout = 0\n</code></pre> <p>Maximum time in seconds to capture packets before stopping.</p> <p>If set to 0, packet capture will continue indefinitely until stopped manually or by reaching packet_count.</p> <p>Default: 0 (no timeout)</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.promiscuous_mode","title":"promiscuous_mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>promiscuous_mode = True\n</code></pre> <p>Whether to put the network interface in promiscuous mode.</p> <p>In promiscuous mode, the interface captures all packets on the network segment, not just those addressed to it. This is typically required for network analysis but may require elevated privileges.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.max_memory_packets","title":"max_memory_packets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_memory_packets = 10000\n</code></pre> <p>Maximum number of packets to store in memory.</p> <p>This limits the memory usage of the packet capture. Once this limit is reached, older packets may be discarded to make room for new ones, depending on the implementation.</p> <p>Must be at least 100 and a multiple of 10 for efficient processing.</p> <p>Default: 10000</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.max_processing_batch_size","title":"max_processing_batch_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_processing_batch_size = 100\n</code></pre> <p>Maximum number of packets to process in a single batch.</p> <p>This affects the performance and responsiveness of the packet processing. Larger batches may be more efficient but can cause longer processing delays.</p> <p>Default: 100</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.num_threads","title":"num_threads  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>num_threads = 4\n</code></pre> <p>Number of threads to use for packet processing.</p> <p>More threads can improve performance on multi-core systems but may increase overhead and complexity. The optimal value depends on the system's hardware and the specific workload.</p> <p>Default: 4</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.enable_realtime_display","title":"enable_realtime_display  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_realtime_display = False\n</code></pre> <p>Whether to enable real-time display of captured packets.</p> <p>If True, a real-time display of captured packets will be shown in the console, updating at regular intervals. This is useful for monitoring packet capture in real-time but may add some overhead.</p> <p>Default: False</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level = 'INFO'\n</code></pre> <p>Logging level for the application.</p> <p>Controls the verbosity of log messages. Valid values (in increasing order of verbosity): - \"CRITICAL\": Only critical errors that prevent the application from running - \"ERROR\": Errors that allow the application to continue but with reduced functionality - \"WARNING\": Warnings about potential issues or unexpected behavior - \"INFO\": General information about the application's operation - \"DEBUG\": Detailed information for debugging purposes</p> <p>Default: \"INFO\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.log_to_file","title":"log_to_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_to_file = True\n</code></pre> <p>Whether to write log messages to files.</p> <p>If True, log messages will be written to files in the directory specified by log_dir. If False, log messages will only be written to the console (if enabled).</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.log_dir","title":"log_dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_dir = '/home/batman/Documents/networkguard2/logs/logs'\n</code></pre> <p>Directory where log files will be stored.</p> <p>This directory will be created if it doesn't exist when the configuration is initialized.</p> <p>Default: \"/home/batman/Documents/networkguard2/logs/logs\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.log_format","title":"log_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_format = '%(asctime)s [%(levelname)s] %(name)s: %(message)s'\n</code></pre> <p>Format string for log messages.</p> <p>This follows the Python logging module's format string syntax. Common format specifiers: - %(asctime)s: Timestamp - %(levelname)s: Log level (INFO, DEBUG, etc.) - %(name)s: Logger name - %(message)s: Log message</p> <p>Default: \"%(asctime)s [%(levelname)s] %(name)s: %(message)s\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.enable_console_logging","title":"enable_console_logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_console_logging = True\n</code></pre> <p>Whether to enable logging to the console.</p> <p>If True, log messages will be printed to the console (stdout/stderr).</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.enable_file_logging","title":"enable_file_logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_file_logging = True\n</code></pre> <p>Whether to enable logging to files.</p> <p>This is separate from log_to_file and provides finer control over which logging systems are active.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.enable_security_logging","title":"enable_security_logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_security_logging = True\n</code></pre> <p>Whether to enable security-related logging.</p> <p>If True, security events such as authentication attempts, permission changes, and potential security violations will be logged.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.enable_packet_logging","title":"enable_packet_logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_packet_logging = True\n</code></pre> <p>Whether to enable packet-level logging.</p> <p>If True, details about captured packets will be logged. This can generate a large volume of log data with high packet rates.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.enable_performance_logging","title":"enable_performance_logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_performance_logging = True\n</code></pre> <p>Whether to enable performance metric logging.</p> <p>If True, performance metrics such as processing time, memory usage, and throughput will be logged.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.max_log_file_size","title":"max_log_file_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_log_file_size = 10485760\n</code></pre> <p>Maximum size of a log file in bytes before it is rotated.</p> <p>When a log file reaches this size, it will be renamed with a timestamp and a new log file will be created. This prevents log files from growing indefinitely.</p> <p>Default: 10485760 (10MB)</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.log_backup_count","title":"log_backup_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_backup_count = 5\n</code></pre> <p>Number of rotated log files to keep.</p> <p>When log files are rotated, this controls how many old log files are kept before the oldest ones are deleted.</p> <p>Default: 5</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.export_format","title":"export_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>export_format = 'parquet'\n</code></pre> <p>Format for exporting captured packet data.</p> <p>Valid values: - \"parquet\": Apache Parquet format (columnar storage, efficient for analytics) - \"csv\": Comma-separated values (more compatible but less efficient)</p> <p>Default: \"parquet\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.export_dir","title":"export_dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>export_dir = '/home/batman/Documents/networkguard2/logs/parquet'\n</code></pre> <p>Directory where exported packet data files will be stored.</p> <p>This directory will be created if it doesn't exist when the configuration is initialized.</p> <p>Default: \"/home/batman/Documents/networkguard2/logs/parquet\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.enable_performance_monitoring","title":"enable_performance_monitoring  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_performance_monitoring = True\n</code></pre> <p>Whether to enable performance monitoring.</p> <p>If True, the application will collect and log performance metrics such as CPU usage, memory usage, packet processing rates, etc.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.performance_log_interval","title":"performance_log_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performance_log_interval = 60\n</code></pre> <p>Interval in seconds between performance metric logging.</p> <p>Controls how frequently performance metrics are collected and logged. Lower values provide more detailed monitoring but increase overhead.</p> <p>Default: 60 (seconds)</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.performance_parquet_path","title":"performance_parquet_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performance_parquet_path = '/home/batman/Documents/networkguard2/logs/performance_metrics/perf_metrics.parquet'\n</code></pre> <p>Path to the Parquet file where performance metrics will be stored.</p> <p>Performance metrics are stored in Parquet format for efficient storage and analysis. The directory containing this file will be created if it doesn't exist.</p> <p>Default: \"/home/batman/Documents/networkguard2/logs/performance_metrics/perf_metrics.parquet\"</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.validate_interface_names","title":"validate_interface_names  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>validate_interface_names = True\n</code></pre> <p>Whether to validate network interface names.</p> <p>If True, interface names will be validated to ensure they match the pattern of valid interface names for the current operating system. This helps prevent command injection attacks.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.sanitize_filter_expressions","title":"sanitize_filter_expressions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sanitize_filter_expressions = True\n</code></pre> <p>Whether to sanitize BPF filter expressions.</p> <p>If True, filter expressions will be sanitized to remove potentially dangerous characters or patterns. This helps prevent injection attacks.</p> <p>Default: True</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.max_filter_length","title":"max_filter_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_filter_length = 200\n</code></pre> <p>Maximum allowed length for BPF filter expressions.</p> <p>This limits the complexity of filter expressions to prevent performance issues and potential denial-of-service attacks with extremely complex filters.</p> <p>Default: 200</p>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig-functions","title":"Functions","text":""},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(yaml_file)\n</code></pre> <p>Load configuration from a YAML file.</p> <p>This method reads a YAML configuration file and creates a SnifferConfig object with the values from the file. If the file doesn't exist or is empty, a default configuration is returned.</p> <p>The YAML file should have a nested structure with sections corresponding to the configuration categories:</p> <pre><code># Example YAML structure\ninterface:\n  name: \"eth0\"\n  detection_method: \"auto\"\n  preferred_types:\n    - \"ethernet\"\n    - \"wireless\"\n\ncapture:\n  filter_expression: \"tcp port 80\"\n  packet_count: 1000\n  # ...\n\nlogging:\n  level: \"DEBUG\"\n  # ...\n\n# ... other sections\n</code></pre> PARAMETER DESCRIPTION <code>yaml_file</code> <p>Path to the YAML configuration file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>SnifferConfig</code> <p>Configuration object with values from the YAML file.            If the file doesn't exist or is empty, returns a default configuration.</p> <p> TYPE: <code>SnifferConfig</code> </p> Example <pre><code># Load configuration from a file\nconfig = SnifferConfig.from_yaml('configs/sniffer_config.yaml')\n\n# Use the configuration\ncapture = PacketCapture(config=config)\n</code></pre> Source code in <code>src/network_security_suite/sniffer/sniffer_config.py</code> <pre><code>@classmethod\ndef from_yaml(cls, yaml_file: str) -&gt; \"SnifferConfig\":\n    \"\"\"\n    Load configuration from a YAML file.\n\n    This method reads a YAML configuration file and creates a SnifferConfig object\n    with the values from the file. If the file doesn't exist or is empty, a default\n    configuration is returned.\n\n    The YAML file should have a nested structure with sections corresponding to the\n    configuration categories:\n\n    ```yaml\n    # Example YAML structure\n    interface:\n      name: \"eth0\"\n      detection_method: \"auto\"\n      preferred_types:\n        - \"ethernet\"\n        - \"wireless\"\n\n    capture:\n      filter_expression: \"tcp port 80\"\n      packet_count: 1000\n      # ...\n\n    logging:\n      level: \"DEBUG\"\n      # ...\n\n    # ... other sections\n    ```\n\n    Args:\n        yaml_file: Path to the YAML configuration file\n\n    Returns:\n        SnifferConfig: Configuration object with values from the YAML file.\n                       If the file doesn't exist or is empty, returns a default configuration.\n\n    Example:\n        ```python\n        # Load configuration from a file\n        config = SnifferConfig.from_yaml('configs/sniffer_config.yaml')\n\n        # Use the configuration\n        capture = PacketCapture(config=config)\n        ```\n    \"\"\"\n    if not os.path.exists(yaml_file):\n        print(\n            f\"Warning: Configuration file {yaml_file} not found. Using default configuration.\"\n        )\n        return cls()\n\n    with open(yaml_file, \"r\") as f:\n        config_data = yaml.safe_load(f)\n\n    if not config_data:\n        return cls()\n\n    # Extract values from nested YAML structure\n    config_dict = {}\n\n    # Interface settings\n    if \"interface\" in config_data:\n        interface_config = config_data[\"interface\"]\n        if \"name\" in interface_config:\n            config_dict[\"interface\"] = interface_config[\"name\"]\n        if \"detection_method\" in interface_config:\n            config_dict[\"interface_detection_method\"] = interface_config[\n                \"detection_method\"\n            ]\n        if \"preferred_types\" in interface_config:\n            config_dict[\"preferred_interface_types\"] = interface_config[\n                \"preferred_types\"\n            ]\n\n    # Capture settings\n    if \"capture\" in config_data:\n        capture_config = config_data[\"capture\"]\n        if \"filter_expression\" in capture_config:\n            config_dict[\"filter_expression\"] = capture_config[\"filter_expression\"]\n        if \"packet_count\" in capture_config:\n            config_dict[\"packet_count\"] = capture_config[\"packet_count\"]\n        if \"timeout\" in capture_config:\n            config_dict[\"timeout\"] = capture_config[\"timeout\"]\n        if \"promiscuous_mode\" in capture_config:\n            config_dict[\"promiscuous_mode\"] = capture_config[\"promiscuous_mode\"]\n        if \"max_memory_packets\" in capture_config:\n            config_dict[\"max_memory_packets\"] = capture_config[\"max_memory_packets\"]\n        if \"max_processing_batch_size\" in capture_config:\n            config_dict[\"max_processing_batch_size\"] = capture_config[\n                \"max_processing_batch_size\"\n            ]\n        if \"num_threads\" in capture_config:\n            config_dict[\"num_threads\"] = capture_config[\"num_threads\"]\n        if \"enable_realtime_display\" in capture_config:\n            config_dict[\"enable_realtime_display\"] = capture_config[\n                \"enable_realtime_display\"\n            ]\n\n    # Logging configuration\n    if \"logging\" in config_data:\n        logging_config = config_data[\"logging\"]\n        if \"level\" in logging_config:\n            config_dict[\"log_level\"] = logging_config[\"level\"]\n        if \"log_to_file\" in logging_config:\n            config_dict[\"log_to_file\"] = logging_config[\"log_to_file\"]\n        if \"log_dir\" in logging_config:\n            config_dict[\"log_dir\"] = logging_config[\"log_dir\"]\n        if \"log_format\" in logging_config:\n            config_dict[\"log_format\"] = logging_config[\"log_format\"]\n        if \"enable_console_logging\" in logging_config:\n            config_dict[\"enable_console_logging\"] = logging_config[\n                \"enable_console_logging\"\n            ]\n        if \"enable_file_logging\" in logging_config:\n            config_dict[\"enable_file_logging\"] = logging_config[\n                \"enable_file_logging\"\n            ]\n        if \"enable_security_logging\" in logging_config:\n            config_dict[\"enable_security_logging\"] = logging_config[\n                \"enable_security_logging\"\n            ]\n        if \"enable_packet_logging\" in logging_config:\n            config_dict[\"enable_packet_logging\"] = logging_config[\n                \"enable_packet_logging\"\n            ]\n        if \"enable_performance_logging\" in logging_config:\n            config_dict[\"enable_performance_logging\"] = logging_config[\n                \"enable_performance_logging\"\n            ]\n        if \"max_log_file_size\" in logging_config:\n            config_dict[\"max_log_file_size\"] = logging_config[\"max_log_file_size\"]\n        if \"log_backup_count\" in logging_config:\n            config_dict[\"log_backup_count\"] = logging_config[\"log_backup_count\"]\n\n    # Export settings\n    if \"export\" in config_data:\n        export_config = config_data[\"export\"]\n        if \"format\" in export_config:\n            config_dict[\"export_format\"] = export_config[\"format\"]\n        if \"dir\" in export_config:\n            config_dict[\"export_dir\"] = export_config[\"dir\"]\n\n    # Performance settings\n    if \"performance\" in config_data:\n        performance_config = config_data[\"performance\"]\n        if \"enable_monitoring\" in performance_config:\n            config_dict[\"enable_performance_monitoring\"] = performance_config[\n                \"enable_monitoring\"\n            ]\n        if \"log_interval\" in performance_config:\n            config_dict[\"performance_log_interval\"] = performance_config[\n                \"log_interval\"\n            ]\n        if \"parquet_path\" in performance_config:\n            config_dict[\"performance_parquet_path\"] = performance_config[\n                \"parquet_path\"\n            ]\n\n    # Security settings\n    if \"security\" in config_data:\n        security_config = config_data[\"security\"]\n        if \"validate_interface_names\" in security_config:\n            config_dict[\"validate_interface_names\"] = security_config[\n                \"validate_interface_names\"\n            ]\n        if \"sanitize_filter_expressions\" in security_config:\n            config_dict[\"sanitize_filter_expressions\"] = security_config[\n                \"sanitize_filter_expressions\"\n            ]\n        if \"max_filter_length\" in security_config:\n            config_dict[\"max_filter_length\"] = security_config[\"max_filter_length\"]\n\n    # Create a new instance with the loaded values\n    config = cls(**config_dict)\n    return config\n</code></pre>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml(yaml_file)\n</code></pre> <p>Save configuration to a YAML file.</p> <p>This method saves the current configuration to a YAML file with a nested structure that matches the logical organization of the configuration attributes. The resulting YAML file can be loaded later using the from_yaml method.</p> <p>The method ensures that the directory containing the YAML file exists, creating it if necessary.</p> <p>The YAML file will have the following structure:</p> <pre><code>interface:\n  name: \"eth0\"\n  detection_method: \"auto\"\n  preferred_types:\n    - \"ethernet\"\n    - \"wireless\"\n\ncapture:\n  filter_expression: \"\"\n  packet_count: 0\n  # ... other capture settings\n\nlogging:\n  level: \"INFO\"\n  # ... other logging settings\n\n# ... other configuration sections\n</code></pre> PARAMETER DESCRIPTION <code>yaml_file</code> <p>Path to the YAML configuration file to be created or overwritten</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Example <pre><code># Create a configuration\nconfig = SnifferConfig(interface=\"wlan0\", packet_count=1000)\n\n# Save it to a file\nconfig.to_yaml('configs/my_config.yaml')\n</code></pre> Source code in <code>src/network_security_suite/sniffer/sniffer_config.py</code> <pre><code>def to_yaml(self, yaml_file: str) -&gt; None:\n    \"\"\"\n    Save configuration to a YAML file.\n\n    This method saves the current configuration to a YAML file with a nested structure\n    that matches the logical organization of the configuration attributes. The resulting\n    YAML file can be loaded later using the from_yaml method.\n\n    The method ensures that the directory containing the YAML file exists, creating it\n    if necessary.\n\n    The YAML file will have the following structure:\n\n    ```yaml\n    interface:\n      name: \"eth0\"\n      detection_method: \"auto\"\n      preferred_types:\n        - \"ethernet\"\n        - \"wireless\"\n\n    capture:\n      filter_expression: \"\"\n      packet_count: 0\n      # ... other capture settings\n\n    logging:\n      level: \"INFO\"\n      # ... other logging settings\n\n    # ... other configuration sections\n    ```\n\n    Args:\n        yaml_file: Path to the YAML configuration file to be created or overwritten\n\n    Returns:\n        None\n\n    Example:\n        ```python\n        # Create a configuration\n        config = SnifferConfig(interface=\"wlan0\", packet_count=1000)\n\n        # Save it to a file\n        config.to_yaml('configs/my_config.yaml')\n        ```\n    \"\"\"\n    # Convert to nested dictionary structure\n    config_dict = {\n        \"interface\": {\n            \"name\": self.interface,\n            \"detection_method\": self.interface_detection_method,\n            \"preferred_types\": self.preferred_interface_types,\n        },\n        \"capture\": {\n            \"filter_expression\": self.filter_expression,\n            \"packet_count\": self.packet_count,\n            \"timeout\": self.timeout,\n            \"promiscuous_mode\": self.promiscuous_mode,\n            \"max_memory_packets\": self.max_memory_packets,\n            \"max_processing_batch_size\": self.max_processing_batch_size,\n            \"num_threads\": self.num_threads,\n            \"enable_realtime_display\": self.enable_realtime_display,\n        },\n        \"logging\": {\n            \"level\": self.log_level,\n            \"log_to_file\": self.log_to_file,\n            \"log_dir\": self.log_dir,\n            \"log_format\": self.log_format,\n            \"enable_console_logging\": self.enable_console_logging,\n            \"enable_file_logging\": self.enable_file_logging,\n            \"enable_security_logging\": self.enable_security_logging,\n            \"enable_packet_logging\": self.enable_packet_logging,\n            \"enable_performance_logging\": self.enable_performance_logging,\n            \"max_log_file_size\": self.max_log_file_size,\n            \"log_backup_count\": self.log_backup_count,\n        },\n        \"export\": {\"format\": self.export_format, \"dir\": self.export_dir},\n        \"performance\": {\n            \"enable_monitoring\": self.enable_performance_monitoring,\n            \"log_interval\": self.performance_log_interval,\n            \"parquet_path\": self.performance_parquet_path,\n        },\n        \"security\": {\n            \"validate_interface_names\": self.validate_interface_names,\n            \"sanitize_filter_expressions\": self.sanitize_filter_expressions,\n            \"max_filter_length\": self.max_filter_length,\n        },\n    }\n\n    # Ensure directory exists\n    os.makedirs(os.path.dirname(yaml_file), exist_ok=True)\n\n    # Write to file\n    with open(yaml_file, \"w\") as f:\n        yaml.dump(config_dict, f, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"sniffer/api/sniffer-config/#network_security_suite.sniffer.sniffer_config.SnifferConfig.generate_default_config","title":"generate_default_config  <code>classmethod</code>","text":"<pre><code>generate_default_config(yaml_file)\n</code></pre> <p>Generate a default configuration file.</p> <p>This method creates a new SnifferConfig instance with default values and saves it to the specified YAML file. It's useful for creating initial configuration files that users can then modify according to their needs.</p> <p>The method ensures that the directory containing the YAML file exists, creating it if necessary.</p> PARAMETER DESCRIPTION <code>yaml_file</code> <p>Path to the YAML configuration file to be created</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Example <pre><code># Generate a default configuration file\nSnifferConfig.generate_default_config('configs/default_config.yaml')\n\n# Later, load and modify it\nconfig = SnifferConfig.from_yaml('configs/default_config.yaml')\nconfig.interface = \"wlan0\"\nconfig.to_yaml('configs/modified_config.yaml')\n</code></pre> Note <p>This method will overwrite the file if it already exists. Use with caution to avoid losing existing configurations.</p> Source code in <code>src/network_security_suite/sniffer/sniffer_config.py</code> <pre><code>@classmethod\ndef generate_default_config(cls, yaml_file: str) -&gt; None:\n    \"\"\"\n    Generate a default configuration file.\n\n    This method creates a new SnifferConfig instance with default values and\n    saves it to the specified YAML file. It's useful for creating initial\n    configuration files that users can then modify according to their needs.\n\n    The method ensures that the directory containing the YAML file exists,\n    creating it if necessary.\n\n    Args:\n        yaml_file: Path to the YAML configuration file to be created\n\n    Returns:\n        None\n\n    Example:\n        ```python\n        # Generate a default configuration file\n        SnifferConfig.generate_default_config('configs/default_config.yaml')\n\n        # Later, load and modify it\n        config = SnifferConfig.from_yaml('configs/default_config.yaml')\n        config.interface = \"wlan0\"\n        config.to_yaml('configs/modified_config.yaml')\n        ```\n\n    Note:\n        This method will overwrite the file if it already exists. Use with caution\n        to avoid losing existing configurations.\n    \"\"\"\n    config = cls()\n    config.to_yaml(yaml_file)\n</code></pre>"},{"location":"sniffer/api/sniffer-config/#usage-examples","title":"Usage Examples","text":""},{"location":"sniffer/api/sniffer-config/#load-configuration-from-yaml","title":"Load Configuration from YAML","text":"<pre><code>from network_security_suite.sniffer.sniffer_config import SnifferConfig\n\n# Load from YAML file\nconfig = SnifferConfig.from_yaml(\"config.yaml\")\n\n# Use configuration\nprint(f\"Interface: {config.interface}\")\nprint(f\"Packet count: {config.packet_count}\")\nprint(f\"Filter: {config.filter_str}\")\n</code></pre>"},{"location":"sniffer/api/sniffer-config/#create-configuration-programmatically","title":"Create Configuration Programmatically","text":"<pre><code>from network_security_suite.sniffer.sniffer_config import SnifferConfig\n\n# Create configuration\nconfig = SnifferConfig(\n    interface=\"eth0\",\n    packet_count=1000,\n    timeout=60,\n    filter_str=\"tcp port 80\"\n)\n\n# Save to YAML\nconfig.to_yaml(\"config.yaml\")\n</code></pre>"},{"location":"sniffer/api/sniffer-config/#validate-configuration","title":"Validate Configuration","text":"<pre><code>config = SnifferConfig.from_yaml(\"config.yaml\")\n\ntry:\n    config.validate()\n    print(\"Configuration is valid\")\nexcept ValueError as e:\n    print(f\"Invalid configuration: {e}\")\n</code></pre>"},{"location":"sniffer/api/sniffer-config/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide</li> <li>PacketCapture API</li> </ul>"},{"location":"sniffer/examples/advanced-filtering/","title":"Advanced Filtering Examples","text":"<p>This page provides examples of advanced packet filtering techniques.</p>"},{"location":"sniffer/examples/advanced-filtering/#multi-protocol-filtering","title":"Multi-Protocol Filtering","text":"<p>Capture HTTP, HTTPS, and DNS traffic:</p> <pre><code>from network_security_suite.sniffer import PacketCapture\n\ncapture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"(tcp port 80 or tcp port 443 or udp port 53)\"\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/advanced-filtering/#network-based-filtering","title":"Network-Based Filtering","text":"<p>Capture traffic to/from a specific subnet:</p> <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"src net 192.168.1.0/24 or dst net 192.168.1.0/24\"\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/advanced-filtering/#security-monitoring","title":"Security Monitoring","text":"<p>Detect potential port scans:</p> <pre><code># Capture SYN packets (connection attempts)\ncapture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack == 0\"\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/advanced-filtering/#large-packet-detection","title":"Large Packet Detection","text":"<p>Capture only large packets (potential data exfiltration):</p> <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"greater 1400 and not broadcast\"\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/advanced-filtering/#exclude-local-traffic","title":"Exclude Local Traffic","text":"<p>Capture only external traffic:</p> <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"not (src net 192.168.0.0/16 and dst net 192.168.0.0/16)\"\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/advanced-filtering/#see-also","title":"See Also","text":"<ul> <li>Basic Capture Examples</li> <li>Packet Filtering Guide</li> <li>Configuration Guide</li> </ul>"},{"location":"sniffer/examples/basic-capture/","title":"Basic Packet Capture Examples","text":"<p>This page provides practical examples for common packet capture scenarios.</p>"},{"location":"sniffer/examples/basic-capture/#simple-capture","title":"Simple Capture","text":"<p>Capture 100 packets from the default interface:</p> <pre><code>from network_security_suite.sniffer import PacketCapture\n\ncapture = PacketCapture(\n    interface=\"eth0\",\n    packet_count=100\n)\ncapture.start()\nprint(\"Captured 100 packets!\")\n</code></pre>"},{"location":"sniffer/examples/basic-capture/#capture-with-timeout","title":"Capture with Timeout","text":"<p>Capture for a specific duration:</p> <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    timeout=60  # 60 seconds\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/basic-capture/#capture-to-file","title":"Capture to File","text":"<p>Save captured packets to a Parquet file:</p> <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    packet_count=1000,\n    output_file=\"capture.parquet\"\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/basic-capture/#continuous-capture","title":"Continuous Capture","text":"<p>Capture continuously in the background:</p> <pre><code>import time\n\n# Start capture\ncapture = PacketCapture(interface=\"eth0\", packet_count=0)\ncapture.start_async()\n\n# Let it run\nprint(\"Capturing packets...\")\ntime.sleep(300)  # Run for 5 minutes\n\n# Stop capture\ncapture.stop()\nprint(f\"Captured {capture.packets_captured} packets\")\n</code></pre>"},{"location":"sniffer/examples/basic-capture/#filtered-capture","title":"Filtered Capture","text":"<p>Capture only HTTP traffic:</p> <pre><code>capture = PacketCapture(\n    interface=\"eth0\",\n    filter_str=\"tcp port 80\",\n    packet_count=100\n)\ncapture.start()\n</code></pre>"},{"location":"sniffer/examples/basic-capture/#see-also","title":"See Also","text":"<ul> <li>Advanced Filtering Examples</li> <li>Getting Started Guide</li> <li>Packet Filtering Guide</li> </ul>"},{"location":"utils/","title":"Utils Module","text":"<p>The Utils module provides shared utilities and helper functions used across the Network Security Suite.</p>"},{"location":"utils/#overview","title":"Overview","text":"<p>This module contains common utilities for logging, performance monitoring, configuration management, and other cross-cutting concerns.</p>"},{"location":"utils/#key-features","title":"Key Features","text":"<ul> <li>Advanced Logging: Comprehensive logging system with multiple handlers and formatters</li> <li>Performance Metrics: Track and monitor application performance</li> <li>Configuration Management: Tools for managing application configuration</li> <li>Reusable Utilities: Common functions used throughout the suite</li> </ul>"},{"location":"utils/#components","title":"Components","text":""},{"location":"utils/#logger","title":"Logger","text":"<p>Advanced logging system with support for: - Multiple log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL) - Multiple handlers (console, file, rotating file) - Custom formatters - Colored console output - Log aggregation</p> <p>See Logger API Reference for details.</p>"},{"location":"utils/#performance-metrics","title":"Performance Metrics","text":"<p>Performance monitoring and metrics collection: - Execution time tracking - Resource usage monitoring - Custom metrics - Performance profiling</p> <p>See Performance Metrics API Reference for details.</p>"},{"location":"utils/#config-builder","title":"Config Builder","text":"<p>Configuration management utilities: - YAML configuration loading - Environment variable support - Configuration validation - Default values</p> <p>See Config Builder API Reference for details.</p>"},{"location":"utils/#quick-start","title":"Quick Start","text":""},{"location":"utils/#using-the-logger","title":"Using the Logger","text":"<pre><code>from network_security_suite.utils import get_logger\n\n# Get a logger instance\nlogger = get_logger(__name__)\n\n# Log messages\nlogger.debug(\"Debug message\")\nlogger.info(\"Information message\")\nlogger.warning(\"Warning message\")\nlogger.error(\"Error message\")\nlogger.critical(\"Critical message\")\n</code></pre>"},{"location":"utils/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>from network_security_suite.utils import PerformanceMetrics\n\n# Track execution time\nmetrics = PerformanceMetrics()\n\nwith metrics.measure(\"operation\"):\n    # Your code here\n    process_data()\n\n# Get metrics\nprint(f\"Operation took: {metrics.get_time('operation')}s\")\n</code></pre>"},{"location":"utils/#configuration-management","title":"Configuration Management","text":"<pre><code>from network_security_suite.utils import ConfigBuilder\n\n# Load configuration\nconfig = ConfigBuilder.from_yaml(\"config.yaml\")\n\n# Access values\ndb_host = config.get(\"database.host\", default=\"localhost\")\ndb_port = config.get(\"database.port\", default=5432)\n</code></pre>"},{"location":"utils/#use-cases","title":"Use Cases","text":""},{"location":"utils/#centralized-logging","title":"Centralized Logging","text":"<p>Set up logging for the entire application:</p> <pre><code>from network_security_suite.utils import setup_logging\n\n# Configure logging\nsetup_logging(\n    level=\"INFO\",\n    log_file=\"app.log\",\n    console=True,\n    colored=True\n)\n\n# Use in your modules\nlogger = get_logger(__name__)\nlogger.info(\"Application started\")\n</code></pre>"},{"location":"utils/#performance-profiling","title":"Performance Profiling","text":"<p>Profile performance-critical sections:</p> <pre><code>from network_security_suite.utils import PerformanceMetrics\n\nmetrics = PerformanceMetrics()\n\n# Profile packet processing\nwith metrics.measure(\"packet_processing\"):\n    for packet in packets:\n        process_packet(packet)\n\n# Profile database operations\nwith metrics.measure(\"database_query\"):\n    results = db.query(...)\n\n# Get report\nreport = metrics.get_report()\nprint(report)\n</code></pre>"},{"location":"utils/#configuration-management_1","title":"Configuration Management","text":"<p>Manage application configuration:</p> <pre><code>from network_security_suite.utils import ConfigBuilder\n\n# Load configuration with environment overrides\nconfig = ConfigBuilder.from_yaml(\n    \"config.yaml\",\n    env_prefix=\"NETGUARD_\"\n)\n\n# Access configuration\ninterface = config.get(\"sniffer.interface\")\npacket_count = config.get(\"sniffer.packet_count\", default=1000)\n</code></pre>"},{"location":"utils/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Application] --&gt; B[Utils Module]\n    B --&gt; C[Logger]\n    B --&gt; D[Performance Metrics]\n    B --&gt; E[Config Builder]\n    C --&gt; F[Console Handler]\n    C --&gt; G[File Handler]\n    D --&gt; H[Time Tracking]\n    D --&gt; I[Resource Monitoring]\n    E --&gt; J[YAML Parser]\n    E --&gt; K[Env Variables]</code></pre>"},{"location":"utils/#best-practices","title":"Best Practices","text":""},{"location":"utils/#1-use-structured-logging","title":"1. Use Structured Logging","text":"<pre><code>logger = get_logger(__name__)\n\n# Good: Structured logging\nlogger.info(\"Packet captured\", extra={\n    \"src_ip\": \"192.168.1.100\",\n    \"dst_ip\": \"10.0.0.1\",\n    \"protocol\": \"TCP\"\n})\n\n# Less ideal: String formatting\nlogger.info(f\"Packet from 192.168.1.100 to 10.0.0.1 (TCP)\")\n</code></pre>"},{"location":"utils/#2-use-context-managers-for-metrics","title":"2. Use Context Managers for Metrics","text":"<pre><code># Good: Automatic timing\nwith metrics.measure(\"operation\"):\n    do_work()\n\n# Less ideal: Manual timing\nstart = time.time()\ndo_work()\nmetrics.record(\"operation\", time.time() - start)\n</code></pre>"},{"location":"utils/#3-centralize-configuration","title":"3. Centralize Configuration","text":"<pre><code># config.yaml\napp:\n  name: \"Network Security Suite\"\n  version: \"1.0.0\"\n\nsniffer:\n  interface: \"eth0\"\n  packet_count: 1000\n\nml:\n  model_path: \"./models\"\n  threshold: 0.8\n\n# Access anywhere\nconfig = ConfigBuilder.from_yaml(\"config.yaml\")\n</code></pre>"},{"location":"utils/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Logging: Use appropriate log levels in production</li> <li>Metrics: Be mindful of overhead when tracking many metrics</li> <li>Configuration: Load configuration once at startup</li> <li>Caching: Utilize caching for frequently accessed values</li> </ul>"},{"location":"utils/#next-steps","title":"Next Steps","text":"<ul> <li>Logging Guide: Detailed logging documentation</li> <li>Performance Metrics Guide: Performance monitoring guide</li> <li>Configuration Guide: Configuration management guide</li> <li>API Reference: Complete API documentation</li> </ul>"},{"location":"utils/configuration/","title":"Configuration Management Guide","text":"<p>Guide to configuration management in the Network Security Suite.</p>"},{"location":"utils/configuration/#overview","title":"Overview","text":"<p>The configuration system provides a flexible way to manage application settings using YAML files, environment variables, and programmatic configuration.</p>"},{"location":"utils/configuration/#basic-usage","title":"Basic Usage","text":""},{"location":"utils/configuration/#loading-configuration","title":"Loading Configuration","text":"<pre><code>from network_security_suite.utils import ConfigBuilder\n\n# Load from YAML file\nconfig = ConfigBuilder.from_yaml(\"config.yaml\")\n\n# Access values\ninterface = config.get(\"sniffer.interface\")\npacket_count = config.get(\"sniffer.packet_count\")\n</code></pre>"},{"location":"utils/configuration/#with-default-values","title":"With Default Values","text":"<pre><code># Get value with default\ninterface = config.get(\"sniffer.interface\", default=\"eth0\")\ntimeout = config.get(\"sniffer.timeout\", default=60)\n</code></pre>"},{"location":"utils/configuration/#environment-variables","title":"Environment Variables","text":"<pre><code># Load with environment variable support\nconfig = ConfigBuilder.from_yaml(\n    \"config.yaml\",\n    env_prefix=\"NETGUARD_\"\n)\n\n# Environment variables override YAML values\n# NETGUARD_SNIFFER_INTERFACE=wlan0 overrides config.yaml\n</code></pre>"},{"location":"utils/configuration/#configuration-file-format","title":"Configuration File Format","text":""},{"location":"utils/configuration/#basic-structure","title":"Basic Structure","text":"<pre><code># config.yaml\napp:\n  name: \"Network Security Suite\"\n  version: \"1.0.0\"\n  debug: false\n\nsniffer:\n  interface: \"eth0\"\n  packet_count: 1000\n  timeout: 60\n  filter: \"tcp port 80\"\n\n  output:\n    directory: \"./captures\"\n    format: \"parquet\"\n\n  logging:\n    level: \"INFO\"\n    file: \"./logs/sniffer.log\"\n\nml:\n  models_path: \"./models\"\n  threshold: 0.8\n\ndatabase:\n  host: \"localhost\"\n  port: 5432\n  name: \"netguard\"\n  user: \"admin\"\n</code></pre>"},{"location":"utils/configuration/#environment-specific-config","title":"Environment-Specific Config","text":"<pre><code># config.yaml\ndefaults: &amp;defaults\n  app:\n    name: \"Network Security Suite\"\n\n  database:\n    port: 5432\n\ndevelopment:\n  &lt;&lt;: *defaults\n  app:\n    debug: true\n  database:\n    host: \"localhost\"\n    name: \"netguard_dev\"\n\nproduction:\n  &lt;&lt;: *defaults\n  app:\n    debug: false\n  database:\n    host: \"db.example.com\"\n    name: \"netguard_prod\"\n</code></pre> <p>Load environment-specific config:</p> <pre><code>import os\n\nenv = os.getenv(\"ENV\", \"development\")\nconfig = ConfigBuilder.from_yaml(f\"config.yaml\", section=env)\n</code></pre>"},{"location":"utils/configuration/#advanced-features","title":"Advanced Features","text":""},{"location":"utils/configuration/#nested-configuration","title":"Nested Configuration","text":"<pre><code># Access nested values\ndb_host = config.get(\"database.host\")\nlog_file = config.get(\"sniffer.logging.file\")\n\n# Or use dict-style access\ndb_config = config.get(\"database\")\nhost = db_config[\"host\"]\nport = db_config[\"port\"]\n</code></pre>"},{"location":"utils/configuration/#validation","title":"Validation","text":"<pre><code>from network_security_suite.utils import ConfigBuilder\n\nclass AppConfig(ConfigBuilder):\n    def validate(self):\n        # Validate required fields\n        required = [\"sniffer.interface\", \"database.host\"]\n        for field in required:\n            if not self.get(field):\n                raise ValueError(f\"Missing required config: {field}\")\n\n        # Validate types\n        packet_count = self.get(\"sniffer.packet_count\")\n        if not isinstance(packet_count, int):\n            raise TypeError(\"packet_count must be integer\")\n\n        # Validate ranges\n        if packet_count &lt; 0:\n            raise ValueError(\"packet_count must be positive\")\n\nconfig = AppConfig.from_yaml(\"config.yaml\")\nconfig.validate()\n</code></pre>"},{"location":"utils/configuration/#dynamic-updates","title":"Dynamic Updates","text":"<pre><code># Update configuration at runtime\nconfig.set(\"sniffer.interface\", \"wlan0\")\nconfig.set(\"sniffer.packet_count\", 2000)\n\n# Save updated configuration\nconfig.to_yaml(\"config_updated.yaml\")\n</code></pre>"},{"location":"utils/configuration/#configuration-merging","title":"Configuration Merging","text":"<pre><code># Merge multiple configurations\nbase_config = ConfigBuilder.from_yaml(\"config.base.yaml\")\nenv_config = ConfigBuilder.from_yaml(\"config.prod.yaml\")\n\n# Merge (env_config overrides base_config)\nconfig = base_config.merge(env_config)\n</code></pre>"},{"location":"utils/configuration/#environment-variables_1","title":"Environment Variables","text":""},{"location":"utils/configuration/#variable-mapping","title":"Variable Mapping","text":"<pre><code># config.yaml\ndatabase:\n  host: \"localhost\"\n  port: 5432\n</code></pre> <p>Environment variables (with prefix <code>NETGUARD_</code>): <pre><code>export NETGUARD_DATABASE_HOST=db.example.com\nexport NETGUARD_DATABASE_PORT=3306\n</code></pre></p> <p>Load configuration: <pre><code>config = ConfigBuilder.from_yaml(\n    \"config.yaml\",\n    env_prefix=\"NETGUARD_\"\n)\n\n# Values from environment variables take precedence\nprint(config.get(\"database.host\"))  # \"db.example.com\"\n</code></pre></p>"},{"location":"utils/configuration/#type-conversion","title":"Type Conversion","text":"<pre><code># Automatic type conversion from environment variables\n# NETGUARD_SNIFFER_PACKET_COUNT=1000 (string)\npacket_count = config.get(\"sniffer.packet_count\")  # 1000 (int)\n\n# NETGUARD_APP_DEBUG=true (string)\ndebug = config.get(\"app.debug\")  # True (bool)\n</code></pre>"},{"location":"utils/configuration/#best-practices","title":"Best Practices","text":""},{"location":"utils/configuration/#1-separate-configs-by-environment","title":"1. Separate Configs by Environment","text":"<pre><code>config/\n\u251c\u2500\u2500 base.yaml           # Common configuration\n\u251c\u2500\u2500 development.yaml    # Development overrides\n\u251c\u2500\u2500 testing.yaml        # Testing configuration\n\u2514\u2500\u2500 production.yaml     # Production configuration\n</code></pre>"},{"location":"utils/configuration/#2-dont-commit-secrets","title":"2. Don't Commit Secrets","text":"<pre><code># config.yaml - Committed to git\ndatabase:\n  host: \"${DB_HOST}\"\n  port: 5432\n  name: \"netguard\"\n\n# secrets.yaml - NOT committed (in .gitignore)\ndatabase:\n  user: \"admin\"\n  password: \"secret123\"\n</code></pre>"},{"location":"utils/configuration/#3-use-type-hints","title":"3. Use Type Hints","text":"<pre><code>from typing import Dict, Any\n\ndef get_db_config(config: ConfigBuilder) -&gt; Dict[str, Any]:\n    return {\n        \"host\": config.get(\"database.host\"),\n        \"port\": config.get(\"database.port\", default=5432),\n        \"name\": config.get(\"database.name\"),\n    }\n</code></pre>"},{"location":"utils/configuration/#4-validate-early","title":"4. Validate Early","text":"<pre><code># At application startup\nconfig = ConfigBuilder.from_yaml(\"config.yaml\")\n\ntry:\n    config.validate()\nexcept ValueError as e:\n    logger.error(f\"Invalid configuration: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"utils/configuration/#examples","title":"Examples","text":""},{"location":"utils/configuration/#application-configuration","title":"Application Configuration","text":"<pre><code>from network_security_suite.utils import ConfigBuilder\n\nclass ApplicationConfig:\n    def __init__(self, config_file: str):\n        self.config = ConfigBuilder.from_yaml(\n            config_file,\n            env_prefix=\"NETGUARD_\"\n        )\n        self.validate()\n\n    def validate(self):\n        # Validate configuration\n        required = [\"sniffer.interface\", \"database.host\"]\n        for field in required:\n            if not self.config.get(field):\n                raise ValueError(f\"Missing: {field}\")\n\n    @property\n    def sniffer_config(self):\n        return self.config.get(\"sniffer\")\n\n    @property\n    def database_config(self):\n        return self.config.get(\"database\")\n\n# Use in application\napp_config = ApplicationConfig(\"config.yaml\")\nsniffer = PacketCapture(**app_config.sniffer_config)\n</code></pre>"},{"location":"utils/configuration/#feature-flags","title":"Feature Flags","text":"<pre><code># config.yaml\nfeatures:\n  ml_analysis: true\n  real_time_alerts: false\n  packet_logging: true\n</code></pre> <pre><code>config = ConfigBuilder.from_yaml(\"config.yaml\")\n\nif config.get(\"features.ml_analysis\"):\n    enable_ml_analysis()\n\nif config.get(\"features.real_time_alerts\"):\n    enable_alerts()\n</code></pre>"},{"location":"utils/configuration/#see-also","title":"See Also","text":"<ul> <li>Logging Guide</li> <li>Performance Metrics Guide</li> <li>Config Builder API Reference</li> </ul>"},{"location":"utils/logging/","title":"Logging Guide","text":"<p>Comprehensive guide to the logging system in the Network Security Suite.</p>"},{"location":"utils/logging/#overview","title":"Overview","text":"<p>The logging system provides flexible, configurable logging with support for multiple handlers, formatters, and log levels.</p>"},{"location":"utils/logging/#basic-usage","title":"Basic Usage","text":""},{"location":"utils/logging/#getting-a-logger","title":"Getting a Logger","text":"<pre><code>from network_security_suite.utils import get_logger\n\n# Get logger for current module\nlogger = get_logger(__name__)\n\n# Log messages\nlogger.debug(\"Debug information\")\nlogger.info(\"General information\")\nlogger.warning(\"Warning message\")\nlogger.error(\"Error occurred\")\nlogger.critical(\"Critical issue\")\n</code></pre>"},{"location":"utils/logging/#log-levels","title":"Log Levels","text":"Level Numeric Value When to Use DEBUG 10 Detailed diagnostic information INFO 20 General informational messages WARNING 30 Warning messages ERROR 40 Error messages CRITICAL 50 Critical errors"},{"location":"utils/logging/#configuration","title":"Configuration","text":""},{"location":"utils/logging/#setup-logging","title":"Setup Logging","text":"<pre><code>from network_security_suite.utils import setup_logging\n\n# Basic setup\nsetup_logging(level=\"INFO\")\n\n# With file output\nsetup_logging(\n    level=\"DEBUG\",\n    log_file=\"app.log\"\n)\n\n# With colored console output\nsetup_logging(\n    level=\"INFO\",\n    console=True,\n    colored=True\n)\n\n# Complete configuration\nsetup_logging(\n    level=\"DEBUG\",\n    log_file=\"app.log\",\n    console=True,\n    colored=True,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n</code></pre>"},{"location":"utils/logging/#yaml-configuration","title":"YAML Configuration","text":"<pre><code># logging.yaml\nlogging:\n  version: 1\n  disable_existing_loggers: false\n\n  formatters:\n    standard:\n      format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    detailed:\n      format: \"%(asctime)s - %(name)s - %(levelname)s - %(pathname)s:%(lineno)d - %(message)s\"\n\n  handlers:\n    console:\n      class: logging.StreamHandler\n      level: INFO\n      formatter: standard\n      stream: ext://sys.stdout\n\n    file:\n      class: logging.handlers.RotatingFileHandler\n      level: DEBUG\n      formatter: detailed\n      filename: app.log\n      maxBytes: 10485760  # 10MB\n      backupCount: 5\n\n  loggers:\n    network_security_suite:\n      level: DEBUG\n      handlers: [console, file]\n      propagate: false\n\n  root:\n    level: INFO\n    handlers: [console]\n</code></pre> <p>Load configuration:</p> <pre><code>import logging.config\nimport yaml\n\nwith open(\"logging.yaml\") as f:\n    config = yaml.safe_load(f)\n    logging.config.dictConfig(config)\n</code></pre>"},{"location":"utils/logging/#advanced-features","title":"Advanced Features","text":""},{"location":"utils/logging/#structured-logging","title":"Structured Logging","text":"<pre><code>logger = get_logger(__name__)\n\n# Add extra context\nlogger.info(\"Packet captured\", extra={\n    \"src_ip\": \"192.168.1.100\",\n    \"dst_ip\": \"10.0.0.1\",\n    \"protocol\": \"TCP\",\n    \"size\": 1500\n})\n</code></pre>"},{"location":"utils/logging/#custom-formatters","title":"Custom Formatters","text":"<pre><code>import logging\n\nclass CustomFormatter(logging.Formatter):\n    def format(self, record):\n        # Add custom formatting\n        record.custom_field = \"value\"\n        return super().format(record)\n\n# Use custom formatter\nhandler = logging.FileHandler(\"app.log\")\nhandler.setFormatter(CustomFormatter())\nlogger.addHandler(handler)\n</code></pre>"},{"location":"utils/logging/#rotating-file-handler","title":"Rotating File Handler","text":"<pre><code>from logging.handlers import RotatingFileHandler\n\n# Rotate by size\nhandler = RotatingFileHandler(\n    \"app.log\",\n    maxBytes=10485760,  # 10MB\n    backupCount=5\n)\nlogger.addHandler(handler)\n</code></pre>"},{"location":"utils/logging/#timed-rotating-handler","title":"Timed Rotating Handler","text":"<pre><code>from logging.handlers import TimedRotatingFileHandler\n\n# Rotate daily\nhandler = TimedRotatingFileHandler(\n    \"app.log\",\n    when=\"D\",  # Daily\n    interval=1,\n    backupCount=7  # Keep 7 days\n)\nlogger.addHandler(handler)\n</code></pre>"},{"location":"utils/logging/#best-practices","title":"Best Practices","text":""},{"location":"utils/logging/#1-use-appropriate-log-levels","title":"1. Use Appropriate Log Levels","text":"<pre><code># DEBUG: Detailed information for diagnosing problems\nlogger.debug(f\"Processing packet {packet_id}\")\n\n# INFO: General informational messages\nlogger.info(\"Application started successfully\")\n\n# WARNING: Indicate something unexpected happened\nlogger.warning(\"High packet drop rate detected\")\n\n# ERROR: A serious problem occurred\nlogger.error(\"Failed to connect to database\")\n\n# CRITICAL: A very serious error\nlogger.critical(\"System out of memory\")\n</code></pre>"},{"location":"utils/logging/#2-include-context","title":"2. Include Context","text":"<pre><code># Good: Include relevant context\nlogger.error(\"Failed to process packet\", extra={\n    \"packet_id\": packet_id,\n    \"error\": str(e),\n    \"timestamp\": timestamp\n})\n\n# Less ideal: Generic message\nlogger.error(\"Error occurred\")\n</code></pre>"},{"location":"utils/logging/#3-use-lazy-formatting","title":"3. Use Lazy Formatting","text":"<pre><code># Good: Lazy evaluation\nlogger.debug(\"Packet: %s\", packet)\n\n# Less efficient: Eager evaluation\nlogger.debug(f\"Packet: {packet}\")\n</code></pre>"},{"location":"utils/logging/#4-dont-log-sensitive-data","title":"4. Don't Log Sensitive Data","text":"<pre><code># Bad: Logging sensitive data\nlogger.info(f\"User password: {password}\")\n\n# Good: Redact sensitive data\nlogger.info(f\"User authenticated: {username}\")\n</code></pre>"},{"location":"utils/logging/#examples","title":"Examples","text":""},{"location":"utils/logging/#module-level-logger","title":"Module-Level Logger","text":"<pre><code># my_module.py\nfrom network_security_suite.utils import get_logger\n\nlogger = get_logger(__name__)\n\ndef process_data():\n    logger.info(\"Starting data processing\")\n    try:\n        # Process data\n        result = do_work()\n        logger.info(\"Data processed successfully\")\n        return result\n    except Exception as e:\n        logger.error(f\"Processing failed: {e}\")\n        raise\n</code></pre>"},{"location":"utils/logging/#performance-logging","title":"Performance Logging","text":"<pre><code>import time\n\nlogger = get_logger(__name__)\n\ndef time_operation(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        logger.debug(f\"Starting {func.__name__}\")\n\n        result = func(*args, **kwargs)\n\n        duration = time.time() - start\n        logger.info(f\"{func.__name__} completed in {duration:.2f}s\")\n\n        return result\n    return wrapper\n\n@time_operation\ndef process_packets(packets):\n    # Process packets\n    pass\n</code></pre>"},{"location":"utils/logging/#error-logging-with-traceback","title":"Error Logging with Traceback","text":"<pre><code>import traceback\n\nlogger = get_logger(__name__)\n\ntry:\n    risky_operation()\nexcept Exception as e:\n    logger.error(\n        f\"Operation failed: {e}\",\n        extra={\"traceback\": traceback.format_exc()}\n    )\n    # Or use logger.exception\n    logger.exception(\"Operation failed\")\n</code></pre>"},{"location":"utils/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"utils/logging/#logs-not-appearing","title":"Logs Not Appearing","text":"<p>Check log level configuration:</p> <pre><code>import logging\n\n# Set root logger level\nlogging.getLogger().setLevel(logging.DEBUG)\n\n# Set specific logger level\nlogging.getLogger(\"network_security_suite\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"utils/logging/#multiple-log-entries","title":"Multiple Log Entries","text":"<p>Disable propagation:</p> <pre><code>logger.propagate = False\n</code></pre>"},{"location":"utils/logging/#log-file-not-created","title":"Log File Not Created","text":"<p>Check file permissions and path:</p> <pre><code>import os\n\nlog_dir = \"logs\"\nos.makedirs(log_dir, exist_ok=True)\n\nlogger = setup_logging(log_file=f\"{log_dir}/app.log\")\n</code></pre>"},{"location":"utils/logging/#see-also","title":"See Also","text":"<ul> <li>Performance Metrics Guide</li> <li>Configuration Guide</li> <li>Logger API Reference</li> </ul>"},{"location":"utils/performance-metrics/","title":"Performance Metrics Guide","text":"<p>Guide to performance monitoring and metrics collection in the Network Security Suite.</p>"},{"location":"utils/performance-metrics/#overview","title":"Overview","text":"<p>The performance metrics system allows you to track execution times, resource usage, and custom metrics throughout your application.</p>"},{"location":"utils/performance-metrics/#basic-usage","title":"Basic Usage","text":""},{"location":"utils/performance-metrics/#tracking-execution-time","title":"Tracking Execution Time","text":"<pre><code>from network_security_suite.utils import PerformanceMetrics\n\nmetrics = PerformanceMetrics()\n\n# Using context manager\nwith metrics.measure(\"operation\"):\n    # Your code here\n    process_data()\n\n# Get the time\nduration = metrics.get_time(\"operation\")\nprint(f\"Operation took {duration:.2f}s\")\n</code></pre>"},{"location":"utils/performance-metrics/#multiple-operations","title":"Multiple Operations","text":"<pre><code>metrics = PerformanceMetrics()\n\n# Track multiple operations\nwith metrics.measure(\"database_query\"):\n    db.query(...)\n\nwith metrics.measure(\"data_processing\"):\n    process(data)\n\nwith metrics.measure(\"file_write\"):\n    write_to_file(data)\n\n# Get summary\nreport = metrics.get_report()\nprint(report)\n</code></pre>"},{"location":"utils/performance-metrics/#advanced-features","title":"Advanced Features","text":""},{"location":"utils/performance-metrics/#custom-metrics","title":"Custom Metrics","text":"<pre><code>from network_security_suite.utils import PerformanceMetrics\n\nmetrics = PerformanceMetrics()\n\n# Record custom metrics\nmetrics.record(\"packets_processed\", 1000)\nmetrics.record(\"bytes_transferred\", 500000)\nmetrics.record(\"errors_encountered\", 5)\n\n# Increment counters\nfor packet in packets:\n    metrics.increment(\"packet_count\")\n    if is_error(packet):\n        metrics.increment(\"error_count\")\n</code></pre>"},{"location":"utils/performance-metrics/#nested-measurements","title":"Nested Measurements","text":"<pre><code>metrics = PerformanceMetrics()\n\nwith metrics.measure(\"total_operation\"):\n    with metrics.measure(\"step1\"):\n        do_step1()\n\n    with metrics.measure(\"step2\"):\n        do_step2()\n\n    with metrics.measure(\"step3\"):\n        do_step3()\n\n# Get detailed breakdown\nprint(metrics.get_report(detailed=True))\n</code></pre>"},{"location":"utils/performance-metrics/#statistical-analysis","title":"Statistical Analysis","text":"<pre><code>metrics = PerformanceMetrics()\n\n# Run operation multiple times\nfor i in range(100):\n    with metrics.measure(\"operation\"):\n        process_data()\n\n# Get statistics\nstats = metrics.get_stats(\"operation\")\nprint(f\"Average: {stats['mean']:.2f}s\")\nprint(f\"Min: {stats['min']:.2f}s\")\nprint(f\"Max: {stats['max']:.2f}s\")\nprint(f\"Std Dev: {stats['std']:.2f}s\")\n</code></pre>"},{"location":"utils/performance-metrics/#use-cases","title":"Use Cases","text":""},{"location":"utils/performance-metrics/#api-endpoint-monitoring","title":"API Endpoint Monitoring","text":"<pre><code>from fastapi import FastAPI\nfrom network_security_suite.utils import PerformanceMetrics\n\napp = FastAPI()\nmetrics = PerformanceMetrics()\n\n@app.get(\"/api/data\")\nasync def get_data():\n    with metrics.measure(\"api_get_data\"):\n        data = fetch_data()\n        return data\n\n@app.get(\"/api/metrics\")\nasync def get_metrics():\n    return metrics.get_report()\n</code></pre>"},{"location":"utils/performance-metrics/#packet-processing-pipeline","title":"Packet Processing Pipeline","text":"<pre><code>metrics = PerformanceMetrics()\n\ndef process_packets(packets):\n    with metrics.measure(\"total_processing\"):\n        # Capture phase\n        with metrics.measure(\"capture\"):\n            captured = capture_packets()\n\n        # Parse phase\n        with metrics.measure(\"parse\"):\n            parsed = parse_packets(captured)\n\n        # Analysis phase\n        with metrics.measure(\"analysis\"):\n            results = analyze_packets(parsed)\n\n        # Storage phase\n        with metrics.measure(\"storage\"):\n            store_results(results)\n\n    # Log performance\n    logger.info(\"Performance:\", extra=metrics.get_report())\n</code></pre>"},{"location":"utils/performance-metrics/#resource-usage-monitoring","title":"Resource Usage Monitoring","text":"<pre><code>import psutil\nfrom network_security_suite.utils import PerformanceMetrics\n\nmetrics = PerformanceMetrics()\n\ndef monitor_resources():\n    # CPU usage\n    cpu_percent = psutil.cpu_percent(interval=1)\n    metrics.record(\"cpu_usage\", cpu_percent)\n\n    # Memory usage\n    memory = psutil.virtual_memory()\n    metrics.record(\"memory_usage\", memory.percent)\n    metrics.record(\"memory_available\", memory.available)\n\n    # Disk usage\n    disk = psutil.disk_usage('/')\n    metrics.record(\"disk_usage\", disk.percent)\n\n    return metrics.get_report()\n</code></pre>"},{"location":"utils/performance-metrics/#decorators","title":"Decorators","text":""},{"location":"utils/performance-metrics/#timing-decorator","title":"Timing Decorator","text":"<pre><code>from network_security_suite.utils import measure_time\n\n@measure_time\ndef expensive_operation():\n    # Your code\n    pass\n\n# Call function - timing is automatic\nresult = expensive_operation()\n</code></pre>"},{"location":"utils/performance-metrics/#custom-performance-decorator","title":"Custom Performance Decorator","text":"<pre><code>import functools\nfrom network_security_suite.utils import PerformanceMetrics\n\ndef track_performance(metric_name):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            metrics = PerformanceMetrics()\n            with metrics.measure(metric_name):\n                result = func(*args, **kwargs)\n            logger.info(f\"{metric_name}: {metrics.get_time(metric_name):.2f}s\")\n            return result\n        return wrapper\n    return decorator\n\n@track_performance(\"data_processing\")\ndef process_data(data):\n    # Process data\n    return result\n</code></pre>"},{"location":"utils/performance-metrics/#reporting","title":"Reporting","text":""},{"location":"utils/performance-metrics/#console-report","title":"Console Report","text":"<pre><code>metrics = PerformanceMetrics()\n\n# Run operations\nwith metrics.measure(\"op1\"):\n    do_op1()\n\nwith metrics.measure(\"op2\"):\n    do_op2()\n\n# Print report\nprint(metrics.get_report())\n</code></pre> <p>Output: <pre><code>Performance Report:\n------------------\nop1: 1.23s\nop2: 0.45s\nTotal: 1.68s\n</code></pre></p>"},{"location":"utils/performance-metrics/#json-report","title":"JSON Report","text":"<pre><code>import json\n\nreport = metrics.get_report(format=\"json\")\nprint(json.dumps(report, indent=2))\n</code></pre>"},{"location":"utils/performance-metrics/#detailed-report","title":"Detailed Report","text":"<pre><code>detailed = metrics.get_report(detailed=True)\n</code></pre> <p>Output includes: - Execution times - Call counts - Min/max/average - Standard deviation - Percentiles</p>"},{"location":"utils/performance-metrics/#best-practices","title":"Best Practices","text":""},{"location":"utils/performance-metrics/#1-use-context-managers","title":"1. Use Context Managers","text":"<pre><code># Good\nwith metrics.measure(\"operation\"):\n    do_work()\n\n# Avoid manual timing\nstart = time.time()\ndo_work()\nmetrics.record(\"operation\", time.time() - start)\n</code></pre>"},{"location":"utils/performance-metrics/#2-name-metrics-consistently","title":"2. Name Metrics Consistently","text":"<pre><code># Good: Consistent naming\nwith metrics.measure(\"db.query.users\"):\n    ...\n\nwith metrics.measure(\"db.query.packets\"):\n    ...\n\n# Avoid: Inconsistent naming\nwith metrics.measure(\"queryUsers\"):\n    ...\n\nwith metrics.measure(\"packet-query\"):\n    ...\n</code></pre>"},{"location":"utils/performance-metrics/#3-dont-over-instrument","title":"3. Don't Over-Instrument","text":"<pre><code># Good: Track important operations\nwith metrics.measure(\"packet_processing\"):\n    for packet in packets:\n        process(packet)\n\n# Avoid: Tracking every tiny operation\nfor packet in packets:\n    with metrics.measure(\"single_packet\"):  # Too granular\n        process(packet)\n</code></pre>"},{"location":"utils/performance-metrics/#4-clean-up-old-metrics","title":"4. Clean Up Old Metrics","text":"<pre><code># Clear metrics periodically\nif metrics.count() &gt; 1000:\n    metrics.clear()\n\n# Or use time-based cleanup\nif time.time() - metrics.start_time &gt; 3600:  # 1 hour\n    metrics.save_report()\n    metrics.clear()\n</code></pre>"},{"location":"utils/performance-metrics/#integration-with-monitoring-systems","title":"Integration with Monitoring Systems","text":""},{"location":"utils/performance-metrics/#prometheus","title":"Prometheus","text":"<pre><code>from prometheus_client import Summary\n\nREQUEST_TIME = Summary('request_processing_seconds', 'Time spent processing request')\n\n@REQUEST_TIME.time()\ndef process_request():\n    with metrics.measure(\"request\"):\n        # Process request\n        pass\n</code></pre>"},{"location":"utils/performance-metrics/#grafana","title":"Grafana","text":"<p>Export metrics for Grafana:</p> <pre><code>def export_metrics():\n    report = metrics.get_report(format=\"json\")\n    # Send to Grafana endpoint\n    requests.post(grafana_url, json=report)\n</code></pre>"},{"location":"utils/performance-metrics/#see-also","title":"See Also","text":"<ul> <li>Logging Guide</li> <li>Configuration Guide</li> <li>Performance Metrics API Reference</li> </ul>"},{"location":"utils/api/config-builder/","title":"Config Builder API Reference","text":"<p>Complete API reference for the configuration management utilities.</p>"},{"location":"utils/api/config-builder/#module-reference","title":"Module Reference","text":""},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder","title":"config_builder","text":"<p>Configuration Builder Module for Network Security Suite.</p> <p>This module provides a utility class for creating SnifferConfig instances in different ways (from YAML, from dict, default).</p>"},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder-classes","title":"Classes","text":""},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder.ConfigBuilder","title":"ConfigBuilder","text":"<p>A utility class for creating SnifferConfig instances in different ways.</p> <p>This class provides static methods for creating SnifferConfig instances from YAML files, dictionaries, or with default values.</p>"},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder.ConfigBuilder-functions","title":"Functions","text":""},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder.ConfigBuilder.from_yaml","title":"from_yaml  <code>staticmethod</code>","text":"<pre><code>from_yaml(yaml_path)\n</code></pre> <p>Create a SnifferConfig instance from a YAML file.</p> PARAMETER DESCRIPTION <code>yaml_path</code> <p>Path to the YAML configuration file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>SnifferConfig</code> <p>Configuration object with values from the YAML file</p> <p> TYPE: <code>SnifferConfig</code> </p> Source code in <code>src/network_security_suite/utils/config_builder.py</code> <pre><code>@staticmethod\ndef from_yaml(yaml_path: str) -&gt; SnifferConfig:\n    \"\"\"\n    Create a SnifferConfig instance from a YAML file.\n\n    Args:\n        yaml_path (str): Path to the YAML configuration file\n\n    Returns:\n        SnifferConfig: Configuration object with values from the YAML file\n    \"\"\"\n    return SnifferConfig.from_yaml(yaml_path)\n</code></pre>"},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder.ConfigBuilder.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(config_dict)\n</code></pre> <p>Create a SnifferConfig instance from a dictionary.</p> PARAMETER DESCRIPTION <code>config_dict</code> <p>Dictionary containing configuration values</p> <p> TYPE: <code>Dict</code> </p> RETURNS DESCRIPTION <code>SnifferConfig</code> <p>Configuration object with values from the dictionary</p> <p> TYPE: <code>SnifferConfig</code> </p> Source code in <code>src/network_security_suite/utils/config_builder.py</code> <pre><code>@staticmethod\ndef from_dict(config_dict: Dict) -&gt; SnifferConfig:\n    \"\"\"\n    Create a SnifferConfig instance from a dictionary.\n\n    Args:\n        config_dict (Dict): Dictionary containing configuration values\n\n    Returns:\n        SnifferConfig: Configuration object with values from the dictionary\n    \"\"\"\n    return SnifferConfig(**config_dict)\n</code></pre>"},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder.ConfigBuilder.default","title":"default  <code>staticmethod</code>","text":"<pre><code>default()\n</code></pre> <p>Create a SnifferConfig instance with default values.</p> RETURNS DESCRIPTION <code>SnifferConfig</code> <p>Configuration object with default values</p> <p> TYPE: <code>SnifferConfig</code> </p> Source code in <code>src/network_security_suite/utils/config_builder.py</code> <pre><code>@staticmethod\ndef default() -&gt; SnifferConfig:\n    \"\"\"\n    Create a SnifferConfig instance with default values.\n\n    Returns:\n        SnifferConfig: Configuration object with default values\n    \"\"\"\n    return SnifferConfig()\n</code></pre>"},{"location":"utils/api/config-builder/#network_security_suite.utils.config_builder.ConfigBuilder.minimal","title":"minimal  <code>staticmethod</code>","text":"<pre><code>minimal(interface=None, log_dir=None, export_dir=None)\n</code></pre> <p>Create a minimal SnifferConfig instance with only essential parameters.</p> PARAMETER DESCRIPTION <code>interface</code> <p>Interface name. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>log_dir</code> <p>Log directory. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>export_dir</code> <p>Export directory. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SnifferConfig</code> <p>Minimal configuration object</p> <p> TYPE: <code>SnifferConfig</code> </p> Source code in <code>src/network_security_suite/utils/config_builder.py</code> <pre><code>@staticmethod\ndef minimal(\n    interface: Optional[str] = None,\n    log_dir: Optional[str] = None,\n    export_dir: Optional[str] = None,\n) -&gt; SnifferConfig:\n    \"\"\"\n    Create a minimal SnifferConfig instance with only essential parameters.\n\n    Args:\n        interface (Optional[str], optional): Interface name. Defaults to None.\n        log_dir (Optional[str], optional): Log directory. Defaults to None.\n        export_dir (Optional[str], optional): Export directory. Defaults to None.\n\n    Returns:\n        SnifferConfig: Minimal configuration object\n    \"\"\"\n    config_dict = {}\n    if interface is not None:\n        config_dict[\"interface\"] = interface\n    if log_dir is not None:\n        config_dict[\"log_dir\"] = log_dir\n        config_dict[\"log_to_file\"] = True\n    if export_dir is not None:\n        config_dict[\"export_dir\"] = export_dir\n\n    return SnifferConfig(**config_dict)\n</code></pre>"},{"location":"utils/api/config-builder/#usage-examples","title":"Usage Examples","text":""},{"location":"utils/api/config-builder/#load-configuration","title":"Load Configuration","text":"<pre><code>from network_security_suite.utils import ConfigBuilder\n\n# From YAML file\nconfig = ConfigBuilder.from_yaml(\"config.yaml\")\n\n# Access values\nvalue = config.get(\"section.key\")\nvalue_with_default = config.get(\"section.key\", default=\"default_value\")\n</code></pre>"},{"location":"utils/api/config-builder/#environment-variables","title":"Environment Variables","text":"<pre><code># Load with environment variable support\nconfig = ConfigBuilder.from_yaml(\n    \"config.yaml\",\n    env_prefix=\"NETGUARD_\"\n)\n\n# NETGUARD_DATABASE_HOST environment variable\n# overrides database.host in config.yaml\nhost = config.get(\"database.host\")\n</code></pre>"},{"location":"utils/api/config-builder/#update-configuration","title":"Update Configuration","text":"<pre><code>config = ConfigBuilder.from_yaml(\"config.yaml\")\n\n# Update value\nconfig.set(\"sniffer.interface\", \"wlan0\")\n\n# Save to file\nconfig.to_yaml(\"config_updated.yaml\")\n</code></pre>"},{"location":"utils/api/config-builder/#merge-configurations","title":"Merge Configurations","text":"<pre><code>base = ConfigBuilder.from_yaml(\"base.yaml\")\noverride = ConfigBuilder.from_yaml(\"override.yaml\")\n\n# Merge (override takes precedence)\nconfig = base.merge(override)\n</code></pre>"},{"location":"utils/api/config-builder/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide</li> <li>Logger API</li> <li>Getting Started</li> </ul>"},{"location":"utils/api/logger/","title":"Logger API Reference","text":"<p>Complete API reference for the logging utilities.</p>"},{"location":"utils/api/logger/#module-reference","title":"Module Reference","text":""},{"location":"utils/api/logger/#network_security_suite.utils.logger","title":"logger","text":"<p>Logger utilities for the Network Security Suite.</p> <p>This module centralizes logging concerns across the project. It provides: - A HandlerConfig helper to consistently create file/rotating/timed handlers. - An abstract Logger base with sensible defaults and handler wiring. - Concrete loggers for distinct domains (NetworkSecurityLogger, PerformanceLogger).</p> Quick start <p>from network_security_suite.utils.logger import NetworkSecurityLogger sec_log = NetworkSecurityLogger(log_dir=\"./logs\") sec_log.log(\"Suspicious traffic detected from 10.0.0.5\") sec_log.debug(\"Rule X matched packet 12345\") sec_log.error(\"Failed to parse payload\")</p> <p>Notes: - By default, file-based handlers write under log_dir (defaults to /tmp/network_security_suite). - Formatters are lightweight by default to avoid duplicated timestamps where   upstream logging already adds them. - All methods are designed to be safe no-ops if misconfigured; override as   needed in your application.</p>"},{"location":"utils/api/logger/#network_security_suite.utils.logger-classes","title":"Classes","text":""},{"location":"utils/api/logger/#network_security_suite.utils.logger.HandlerConfig","title":"HandlerConfig  <code>dataclass</code>","text":"<pre><code>HandlerConfig(name, level, formatter, filepath=None, max_bytes=10485760, backup_count=5, log_dir=None)\n</code></pre> <p>HandlerConfig is a data class meant to configure and manage logging handlers.</p> <p>This class is used to set up various logging handle configurations, including rotating file handlers and timed rotating file handlers. It provides an initializer for setting file paths, ensuring directory existence, and dynamically creating handlers based on the provided name. This class is designed for flexible logging configurations in applications and supports optional log directory and max byte configuration for log files.</p> <p>It ensures the creation and readiness of log handlers that can be directly utilized in logging setups.</p> <p>:ivar name: Name indicating the type of log handler to use, such as     rotating_file or timed_rotating_file. :type name: str :ivar level: Logging level to be used for this handler (e.g., DEBUG, INFO). :type level: int :ivar formatter: Formatter to use for the log messages. :type formatter: Formatter :ivar filepath: Path to the log file, optionally including the filename. If not     provided, no file handler is created. :type filepath: Optional[str] :ivar max_bytes: Maximum size of the file in bytes for rotating file handlers.     Defaults to 10MB. :type max_bytes: int :ivar backup_count: Number of backup log files to keep when using a rotating     file handler. Defaults to 5. :type backup_count: int :ivar log_dir: Directory where logs are stored. If not provided, defaults to     the current directory. :type log_dir: Optional[str] :ivar file_handler: The created logging handler instance (if applicable). None     if no file handler is created. :type file_handler: Optional[Handler]</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    level: int,\n    formatter: Formatter,\n    filepath: Optional[str] = None,\n    max_bytes: int = 10485760,\n    backup_count: int = 5,\n    log_dir: Optional[str] = None,\n):\n    self.name = name\n    self.level = level\n    self.formatter = formatter\n    self.filepath = filepath\n    self.max_bytes = max_bytes\n    self.backup_count = backup_count\n    self.log_dir = log_dir\n    self.file_handler = None\n\n    # Create file handler if filepath is provided\n    if filepath:\n        # Use log_dir if provided, otherwise use current directory\n        if log_dir:\n            # Ensure log directory exists\n            os.makedirs(log_dir, exist_ok=True)\n            full_path = os.path.join(log_dir, filepath)\n        else:\n            full_path = filepath\n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(full_path), exist_ok=True)\n\n        # Create appropriate handler based on name\n        if name == \"rotating_file\":\n            self.file_handler = RotatingFileHandler(\n                full_path, maxBytes=max_bytes, backupCount=backup_count\n            )\n        elif name == \"timed_rotating_file\":\n            self.file_handler = TimedRotatingFileHandler(\n                full_path, when=\"midnight\", interval=1, backupCount=backup_count\n            )\n        else:\n            self.file_handler = logging.FileHandler(full_path)\n\n        self.file_handler.setLevel(level)\n        self.file_handler.setFormatter(formatter)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.HandlerConfig-functions","title":"Functions","text":""},{"location":"utils/api/logger/#network_security_suite.utils.logger.HandlerConfig.has_format","title":"has_format","text":"<pre><code>has_format()\n</code></pre> <p>Return True if this handler configuration has a formatter assigned.</p> <p>This is useful when normalizing handler setup inside Logger.set_handlers, where a default formatter may be applied if none is configured.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if a formatter is set, otherwise False.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def has_format(self) -&gt; bool:\n    \"\"\"\n    Return True if this handler configuration has a formatter assigned.\n\n    This is useful when normalizing handler setup inside Logger.set_handlers,\n    where a default formatter may be applied if none is configured.\n\n    Returns:\n        bool: True if a formatter is set, otherwise False.\n    \"\"\"\n    return self.formatter is not None\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.HandlerTypes","title":"HandlerTypes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Typed dictionary for defining optional handler configurations.</p> <p>This class is used for specifying various handler configurations that may be part of a logging or event system. Each handler type is optional and can be specified as needed. Typical usage includes providing specific configurations for logging handlers such as file handlers, console handlers, or handlers for specific log levels like error, debug, and warning.</p> <p>:ivar console_handler: Optional configuration for a console handler. :type console_handler: Optional[HandlerConfig] :ivar security_handler: Optional configuration for a security handler. :type security_handler: Optional[HandlerConfig] :ivar packet_handler: Optional configuration for a packet handler. :type packet_handler: Optional[HandlerConfig] :ivar file_handler: Optional configuration for a file handler. :type file_handler: Optional[HandlerConfig] :ivar rotating_file_handler: Optional configuration for a rotating file handler. :type rotating_file_handler: Optional[HandlerConfig] :ivar timed_rotating_file_handler: Optional configuration for a timed rotating file handler. :type timed_rotating_file_handler: Optional[HandlerConfig] :ivar smtp_handler: Optional configuration for an SMTP handler. :type smtp_handler: Optional[HandlerConfig] :ivar http_handler: Optional configuration for an HTTP handler. :type http_handler: Optional[HandlerConfig] :ivar queue_handler: Optional configuration for a queue handler. :type queue_handler: Optional[HandlerConfig] :ivar error_handler: Optional configuration for an error handler. :type error_handler: Optional[HandlerConfig] :ivar debug_handler: Optional configuration for a debug handler. :type debug_handler: Optional[HandlerConfig] :ivar critical_handler: Optional configuration for a critical handler. :type critical_handler: Optional[HandlerConfig] :ivar warning_handler: Optional configuration for a warning handler. :type warning_handler: Optional[HandlerConfig] :ivar info_handler: Optional configuration for an info handler. :type info_handler: Optional[HandlerConfig]</p>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.Logger","title":"Logger","text":"<pre><code>Logger(log_format=None, handlers=None, log_dir=None)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Logger class providing a base structure for log management and customization.</p> <p>This class is designed as an abstract base class (ABC) for creating custom loggers with specific behavior. It initializes default logging configurations, allows for the addition of custom handlers, and enables saving logs to files. Derived classes are expected to implement the abstract methods for logging and saving logs.</p> <p>:ivar logger: The logging instance for managing log messages. :type logger: logging.Logger :ivar format: Logging format used for formatting log messages. :type format: logging.Formatter :ivar handlers: Collection of handler configurations for log management. :type handlers: Optional[HandlerTypes] :ivar log_dir: Path to the directory where logs can be saved. :type log_dir: Optional[str]</p> <p>Initialize the base logger with format, handlers, and log directory.</p> PARAMETER DESCRIPTION <code>log_format</code> <p>Custom formatter to use for messages. If None, defaults to \"%(asctime)s [%(levelname)s] %(message)s\".</p> <p> TYPE: <code>Optional[Formatter]</code> DEFAULT: <code>None</code> </p> <code>handlers</code> <p>Mapping of handler names to HandlerConfig instances. If None, a minimal console handler is created.</p> <p> TYPE: <code>Optional[HandlerTypes]</code> DEFAULT: <code>None</code> </p> <code>log_dir</code> <p>Base directory where file handlers should write logs. Defaults to \"/tmp/network_security_suite\" if not provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def __init__(\n    self,\n    log_format: Optional[Formatter] = None,\n    handlers: Optional[HandlerTypes] = None,\n    log_dir: Optional[str] = None,\n):\n    \"\"\"\n    Initialize the base logger with format, handlers, and log directory.\n\n    Args:\n        log_format (Optional[logging.Formatter]): Custom formatter to use for\n            messages. If None, defaults to \"%(asctime)s [%(levelname)s] %(message)s\".\n        handlers (Optional[HandlerTypes]): Mapping of handler names to\n            HandlerConfig instances. If None, a minimal console handler is created.\n        log_dir (Optional[str]): Base directory where file handlers should\n            write logs. Defaults to \"/tmp/network_security_suite\" if not provided.\n    \"\"\"\n    self.log_dir = log_dir or \"/tmp/network_security_suite\"\n\n    self.logger = logging.getLogger(self.__class__.__name__)\n    self.logger.setLevel(logging.INFO)\n\n    # Setup default format\n    format_string = \"%(asctime)s [%(levelname)s] %(message)s\"\n    self.format = log_format or logging.Formatter(format_string)\n\n    # Setup handlers\n    self.handlers = handlers or self._create_default_handlers()\n    self.set_handlers()\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.Logger-functions","title":"Functions","text":""},{"location":"utils/api/logger/#network_security_suite.utils.logger.Logger.log","title":"log  <code>abstractmethod</code>","text":"<pre><code>log(message)\n</code></pre> <p>Emit a log message.</p> <p>Subclasses decide the log level and any additional formatting. For example, NetworkSecurityLogger.log() uses WARNING while PerformanceLogger.log() uses INFO.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to be logged.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>@abstractmethod\ndef log(self, message: str):\n    \"\"\"\n    Emit a log message.\n\n    Subclasses decide the log level and any additional formatting. For\n    example, NetworkSecurityLogger.log() uses WARNING while\n    PerformanceLogger.log() uses INFO.\n\n    Args:\n        message (str): The message to be logged.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.Logger.save_logs","title":"save_logs  <code>abstractmethod</code>","text":"<pre><code>save_logs(path)\n</code></pre> <p>Persist current logs to a target destination.</p> <p>Subclasses can implement exporting, archiving, or uploading of log records. Many use-cases are already covered by file handlers, so this method is optional to implement unless custom behavior is needed.</p> PARAMETER DESCRIPTION <code>path</code> <p>Destination path (file or directory) for the persisted logs.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>@abstractmethod\ndef save_logs(self, path: str):\n    \"\"\"\n    Persist current logs to a target destination.\n\n    Subclasses can implement exporting, archiving, or uploading of log\n    records. Many use-cases are already covered by file handlers, so this\n    method is optional to implement unless custom behavior is needed.\n\n    Args:\n        path (str): Destination path (file or directory) for the persisted logs.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.Logger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.NetworkSecurityLogger","title":"NetworkSecurityLogger","text":"<pre><code>NetworkSecurityLogger(log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>Provides specialized logging for network security-related messages.</p> <p>This class extends a base Logger to handle and format logging specifically for security-related data. It supports logging at different levels such as warning, debug, and error, while also allowing the saving of logs to file. The log messages can be output to the console and/or a specific security log file, based on the handler configuration.</p> <p>:ivar logger: The logger instance used to write logs. :type logger: logging.Logger</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def __init__(self, log_dir: Optional[str] = None):\n    handlers: HandlerTypes = {\n        \"console_handler\": HandlerConfig(\n            \"console\", logging.INFO, Formatter(\"%(asctime)s [SECURITY] %(message)s\")\n        ),\n        \"security_handler\": HandlerConfig(\n            \"security\",\n            logging.WARNING,\n            Formatter(\"%(asctime)s [SECURITY] %(message)s\"),\n            filepath=\"security.log\",\n            log_dir=log_dir,\n        ),\n    }\n    super().__init__(handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.NetworkSecurityLogger-functions","title":"Functions","text":""},{"location":"utils/api/logger/#network_security_suite.utils.logger.NetworkSecurityLogger.log","title":"log","text":"<pre><code>log(message)\n</code></pre> <p>Log a security-related message at WARNING level.</p> PARAMETER DESCRIPTION <code>message</code> <p>The text to log. Should be concise and redact any sensitive data before calling.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def log(self, message: str) -&gt; None:\n    \"\"\"\n    Log a security-related message at WARNING level.\n\n    Args:\n        message (str): The text to log. Should be concise and redact any\n            sensitive data before calling.\n    \"\"\"\n    self.logger.warning(message)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.NetworkSecurityLogger.debug","title":"debug","text":"<pre><code>debug(message)\n</code></pre> <p>Log a security debug message.</p> <p>Only emitted if the logger level allows DEBUG.</p> PARAMETER DESCRIPTION <code>message</code> <p>Debug details useful for troubleshooting.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def debug(self, message: str) -&gt; None:\n    \"\"\"\n    Log a security debug message.\n\n    Only emitted if the logger level allows DEBUG.\n\n    Args:\n        message (str): Debug details useful for troubleshooting.\n    \"\"\"\n    self.logger.debug(message)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.NetworkSecurityLogger.error","title":"error","text":"<pre><code>error(message)\n</code></pre> <p>Log a security error message at ERROR level.</p> PARAMETER DESCRIPTION <code>message</code> <p>Description of the error condition.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def error(self, message: str) -&gt; None:\n    \"\"\"\n    Log a security error message at ERROR level.\n\n    Args:\n        message (str): Description of the error condition.\n    \"\"\"\n    self.logger.error(message)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.NetworkSecurityLogger.save_logs","title":"save_logs","text":"<pre><code>save_logs(path)\n</code></pre> <p>Persist accumulated security logs to the specified path.</p> <p>Note: In most deployments handlers already write to files (e.g., security.log). Override this in integrators if you need to export, rotate, or upload logs elsewhere.</p> PARAMETER DESCRIPTION <code>path</code> <p>Destination file or directory for saving/exporting logs.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def save_logs(self, path: str):\n    \"\"\"\n    Persist accumulated security logs to the specified path.\n\n    Note: In most deployments handlers already write to files (e.g.,\n    security.log). Override this in integrators if you need to export,\n    rotate, or upload logs elsewhere.\n\n    Args:\n        path (str): Destination file or directory for saving/exporting logs.\n    \"\"\"\n    # Implementation intentionally left as a no-op for now\n    pass\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.NetworkSecurityLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.PerformanceLogger","title":"PerformanceLogger","text":"<pre><code>PerformanceLogger(log_dir=None)\n</code></pre> <p>               Bases: <code>Logger</code></p> <p>A logger for performance monitoring tasks.</p> <p>The PerformanceLogger class is designed to handle and manage performance-related logging efficiently. It extends the base Logger functionality, introducing specific handlers and configurations tailored for performance monitoring. It allows logging both to the console and to a dedicated performance log file in an easy and structured way.</p> <p>:ivar handlers: A dictionary containing configurations for the console and performance     handlers. These handlers define where and how the performance logs are outputted. :type handlers: HandlerTypes</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def __init__(self, log_dir: Optional[str] = None):\n    handlers: HandlerTypes = {\n        \"console_handler\": HandlerConfig(\n            \"console\", logging.INFO, Formatter(\"%(asctime)s [PERF] %(message)s\")\n        ),\n        \"performance_handler\": HandlerConfig(\n            \"performance\",\n            logging.INFO,\n            Formatter(\"%(asctime)s [PERF] %(message)s\"),\n            filepath=\"performance.log\",\n            log_dir=log_dir,\n        ),\n    }\n    super().__init__(handlers=handlers, log_dir=log_dir)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.PerformanceLogger-functions","title":"Functions","text":""},{"location":"utils/api/logger/#network_security_suite.utils.logger.PerformanceLogger.log","title":"log","text":"<pre><code>log(message)\n</code></pre> <p>Log a performance-related message at INFO level.</p> <p>Typical messages include timing, throughput, resource usage, or other metrics summaries.</p> PARAMETER DESCRIPTION <code>message</code> <p>Human-readable performance information.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def log(self, message: str) -&gt; None:\n    \"\"\"\n    Log a performance-related message at INFO level.\n\n    Typical messages include timing, throughput, resource usage, or other\n    metrics summaries.\n\n    Args:\n        message (str): Human-readable performance information.\n    \"\"\"\n    self.logger.info(message)\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.PerformanceLogger.save_logs","title":"save_logs","text":"<pre><code>save_logs(path)\n</code></pre> <p>Persist performance logs to the specified path.</p> <p>In many setups, handlers already stream to performance.log. Override to export or transform metrics (e.g., upload to time-series DB).</p> PARAMETER DESCRIPTION <code>path</code> <p>Destination file or directory for saving/exporting logs.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def save_logs(self, path: str):\n    \"\"\"\n    Persist performance logs to the specified path.\n\n    In many setups, handlers already stream to performance.log. Override to\n    export or transform metrics (e.g., upload to time-series DB).\n\n    Args:\n        path (str): Destination file or directory for saving/exporting logs.\n    \"\"\"\n    # Implementation intentionally left as a no-op for now\n    pass\n</code></pre>"},{"location":"utils/api/logger/#network_security_suite.utils.logger.PerformanceLogger.set_handlers","title":"set_handlers","text":"<pre><code>set_handlers()\n</code></pre> <p>Build and attach logging handlers defined in self.handlers.</p> <p>This method iterates through HandlerConfig entries and ensures each handler is correctly bound to this logger instance, honoring the configured log_dir. It will recreate file-based handlers with the resolved log_dir to guarantee log files end up under the intended directory.</p> <p>Behavior: - If a HandlerConfig already created a file handler and a log_dir is set,   the file handler is safely closed and recreated with the updated path. - If a handler has no formatter, the logger's default formatter is   applied. - Any available file_handler on the config is added to the logger.</p> <p>Note: The HandlerConfig object is used as a convenience container. The actual logging.Handler attached to the logger is handler.file_handler.</p> Source code in <code>src/network_security_suite/utils/logger.py</code> <pre><code>def set_handlers(self):\n    \"\"\"\n    Build and attach logging handlers defined in self.handlers.\n\n    This method iterates through HandlerConfig entries and ensures each\n    handler is correctly bound to this logger instance, honoring the\n    configured log_dir. It will recreate file-based handlers with the\n    resolved log_dir to guarantee log files end up under the intended\n    directory.\n\n    Behavior:\n    - If a HandlerConfig already created a file handler and a log_dir is set,\n      the file handler is safely closed and recreated with the updated path.\n    - If a handler has no formatter, the logger's default formatter is\n      applied.\n    - Any available file_handler on the config is added to the logger.\n\n    Note:\n    The HandlerConfig object is used as a convenience container. The actual\n    logging.Handler attached to the logger is handler.file_handler.\n    \"\"\"\n    for handler in self.handlers.values():\n        if handler:\n            # Set the log_dir for the handler if it's a HandlerConfig instance\n            if isinstance(handler, HandlerConfig) and self.log_dir:\n                # Store original values\n                original_filepath = handler.filepath\n                original_formatter = handler.formatter\n                original_name = handler.name\n                original_level = handler.level\n                original_max_bytes = handler.max_bytes\n                original_backup_count = handler.backup_count\n\n                # Close existing file handler if it exists\n                if handler.file_handler:\n                    handler.file_handler.close()\n                    handler.file_handler = None\n\n                # Recreate the handler with the log_dir\n                if original_filepath:\n                    handler.__init__(\n                        original_name,\n                        original_level,\n                        original_formatter,\n                        original_filepath,\n                        original_max_bytes,\n                        original_backup_count,\n                        self.log_dir,\n                    )\n\n            # Set formatter if not already set\n            if not handler.has_format():\n                handler.setFormatter(self.format)\n                if handler.file_handler:\n                    handler.file_handler.setFormatter(self.format)\n\n            # Add the file_handler to the logger if it exists\n            if hasattr(handler, \"file_handler\") and handler.file_handler:\n                self.logger.addHandler(handler.file_handler)\n</code></pre>"},{"location":"utils/api/logger/#usage-examples","title":"Usage Examples","text":""},{"location":"utils/api/logger/#basic-logger","title":"Basic Logger","text":"<pre><code>from network_security_suite.utils import get_logger\n\nlogger = get_logger(__name__)\nlogger.info(\"Application started\")\nlogger.warning(\"High memory usage detected\")\nlogger.error(\"Failed to connect to database\")\n</code></pre>"},{"location":"utils/api/logger/#setup-logging","title":"Setup Logging","text":"<pre><code>from network_security_suite.utils import setup_logging\n\n# Configure logging for entire application\nsetup_logging(\n    level=\"DEBUG\",\n    log_file=\"app.log\",\n    console=True,\n    colored=True\n)\n</code></pre>"},{"location":"utils/api/logger/#custom-configuration","title":"Custom Configuration","text":"<pre><code>from network_security_suite.utils.logger import Logger\n\nlogger = Logger(\n    name=\"my_app\",\n    level=\"INFO\",\n    handlers=[\"console\", \"file\"],\n    log_file=\"my_app.log\"\n)\n\nlogger.info(\"Custom logger initialized\")\n</code></pre>"},{"location":"utils/api/logger/#see-also","title":"See Also","text":"<ul> <li>Logging Guide</li> <li>Configuration Guide</li> <li>Performance Metrics API</li> </ul>"},{"location":"utils/api/performance-metrics/","title":"Performance Metrics API Reference","text":"<p>Complete API reference for the performance metrics utilities.</p>"},{"location":"utils/api/performance-metrics/#module-reference","title":"Module Reference","text":""},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics","title":"performance_metrics","text":""},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics-classes","title":"Classes","text":""},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics","title":"PerformanceMetrics","text":"<pre><code>PerformanceMetrics(enabled=True, log_to_file=True, log_dir='logs/performance_metrics', parquet_path=None)\n</code></pre> <p>Performance monitoring system with FastAPI-style decorators.</p> Usage <p>perf = PerformanceMetrics()</p> <p>@perf.timeit() def my_function():     pass</p> <p>@perf.memory() def memory_intensive():     pass</p> <p>@perf.monitor(\"custom_label\") def complete_monitoring():     pass</p> <p>Initialize the PerformanceMetrics instance.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether performance monitoring is enabled</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>log_to_file</code> <p>Whether to save logs to files</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>log_dir</code> <p>Directory for log files</p> <p> TYPE: <code>str</code> DEFAULT: <code>'logs/performance_metrics'</code> </p> <code>parquet_path</code> <p>Path for parquet metrics file</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def __init__(\n    self,\n    enabled: bool = True,\n    log_to_file: bool = True,\n    log_dir: str = \"logs/performance_metrics\",\n    parquet_path: Optional[str] = None,\n):\n    \"\"\"\n    Initialize the PerformanceMetrics instance.\n\n    Args:\n        enabled: Whether performance monitoring is enabled\n        log_to_file: Whether to save logs to files\n        log_dir: Directory for log files\n        parquet_path: Path for parquet metrics file\n    \"\"\"\n    self.enabled = enabled\n    self.log_to_file = log_to_file\n    self.log_dir = log_dir\n    self.parquet_path = parquet_path or f\"{log_dir}/perf_metrics.parquet\"\n    # Use a basic logging.Logger instance instead of PerformanceLogger to avoid circular imports\n    if log_to_file:\n        # Create logger\n        self.logger = logging.getLogger(\"performance_metrics\")\n        self.logger.setLevel(logging.DEBUG)\n\n        # Create directory if it doesn't exist\n        os.makedirs(log_dir, exist_ok=True)\n\n        # Create file handler\n        log_file = os.path.join(log_dir, \"performance.log\")\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setLevel(logging.DEBUG)\n\n        # Create formatter\n        formatter = logging.Formatter(\"%(asctime)s [PERFORMANCE] %(message)s\")\n        file_handler.setFormatter(formatter)\n\n        # Add handler to logger\n        self.logger.addHandler(file_handler)\n    else:\n        self.logger = None\n    self._system_monitoring_active = False\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics-functions","title":"Functions","text":""},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics.timeit","title":"timeit","text":"<pre><code>timeit(label=None)\n</code></pre> <p>Decorator to measure execution time.</p> PARAMETER DESCRIPTION <code>label</code> <p>Optional custom label for the metric</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Usage <p>@perf.timeit() def my_function():     pass</p> <p>@perf.timeit(\"database_query\") def query_db():     pass</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def timeit(self, label: Optional[str] = None):\n    \"\"\"\n    Decorator to measure execution time.\n\n    Args:\n        label: Optional custom label for the metric\n\n    Usage:\n        @perf.timeit()\n        def my_function():\n            pass\n\n        @perf.timeit(\"database_query\")\n        def query_db():\n            pass\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if not self.enabled:\n                return func(*args, **kwargs)\n\n            start_time = time.perf_counter()\n            result = func(*args, **kwargs)\n            elapsed_time = (time.perf_counter() - start_time) * 1000\n\n            metric_data = {\n                \"timestamp\": datetime.now(),\n                \"type\": \"timing\",\n                \"label\": label or func.__name__,\n                \"value_ms\": round(elapsed_time, 4),\n            }\n            self._log_metric(metric_data)\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics.memory","title":"memory","text":"<pre><code>memory(label=None)\n</code></pre> <p>Decorator to measure memory usage.</p> PARAMETER DESCRIPTION <code>label</code> <p>Optional custom label for the metric</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Usage <p>@perf.memory() def memory_intensive():     pass</p> <p>@perf.memory(\"large_processing\") def process_data():     pass</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def memory(self, label: Optional[str] = None):\n    \"\"\"\n    Decorator to measure memory usage.\n\n    Args:\n        label: Optional custom label for the metric\n\n    Usage:\n        @perf.memory()\n        def memory_intensive():\n            pass\n\n        @perf.memory(\"large_processing\")\n        def process_data():\n            pass\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if not self.enabled:\n                return func(*args, **kwargs)\n\n            tracemalloc.start()\n            result = func(*args, **kwargs)\n            current, peak = tracemalloc.get_traced_memory()\n            tracemalloc.stop()\n\n            metric_data = {\n                \"timestamp\": datetime.now(),\n                \"type\": \"memory\",\n                \"label\": label or func.__name__,\n                \"mem_current_kb\": current // 1024,\n                \"mem_peak_kb\": peak // 1024,\n            }\n            self._log_metric(metric_data)\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics.monitor","title":"monitor","text":"<pre><code>monitor(label=None)\n</code></pre> <p>Decorator to measure both timing and memory usage.</p> PARAMETER DESCRIPTION <code>label</code> <p>Optional custom label for the metric</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Usage <p>@perf.monitor() def complex_function():     pass</p> <p>@perf.monitor(\"packet_processing\") def process_packet():     pass</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def monitor(self, label: Optional[str] = None):\n    \"\"\"\n    Decorator to measure both timing and memory usage.\n\n    Args:\n        label: Optional custom label for the metric\n\n    Usage:\n        @perf.monitor()\n        def complex_function():\n            pass\n\n        @perf.monitor(\"packet_processing\")\n        def process_packet():\n            pass\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if not self.enabled:\n                return func(*args, **kwargs)\n\n            tracemalloc.start()\n            start_time = time.perf_counter()\n\n            result = func(*args, **kwargs)\n\n            elapsed_time = (time.perf_counter() - start_time) * 1000\n            current, peak = tracemalloc.get_traced_memory()\n            tracemalloc.stop()\n\n            metric_data = {\n                \"timestamp\": datetime.now(),\n                \"type\": \"complete\",\n                \"label\": label or func.__name__,\n                \"timing_ms\": round(elapsed_time, 4),\n                \"mem_current_kb\": current // 1024,\n                \"mem_peak_kb\": peak // 1024,\n            }\n            self._log_metric(metric_data)\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics.system_monitor","title":"system_monitor","text":"<pre><code>system_monitor(interval=5)\n</code></pre> <p>Start continuous system monitoring.</p> PARAMETER DESCRIPTION <code>interval</code> <p>Time in seconds between measurements</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Usage <p>perf.system_monitor(interval=10)</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def system_monitor(self, interval: int = 5):\n    \"\"\"\n    Start continuous system monitoring.\n\n    Args:\n        interval: Time in seconds between measurements\n\n    Usage:\n        perf.system_monitor(interval=10)\n    \"\"\"\n    if self._system_monitoring_active:\n        return\n\n    def monitor():\n        self._system_monitoring_active = True\n        while self.enabled and self._system_monitoring_active:\n            metric_data = {\n                \"timestamp\": datetime.now(),\n                \"type\": \"system\",\n                \"label\": \"system_monitor\",\n                \"cpu_percent\": psutil.cpu_percent(),\n                \"mem_percent\": psutil.virtual_memory().percent,\n            }\n            self._log_metric(metric_data)\n            time.sleep(interval)\n\n    if self.enabled:\n        thread = threading.Thread(target=monitor, daemon=True)\n        thread.start()\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics.stop_system_monitor","title":"stop_system_monitor","text":"<pre><code>stop_system_monitor()\n</code></pre> <p>Stop system monitoring.</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def stop_system_monitor(self):\n    \"\"\"Stop system monitoring.\"\"\"\n    self._system_monitoring_active = False\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics.enable","title":"enable","text":"<pre><code>enable()\n</code></pre> <p>Enable performance monitoring.</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def enable(self):\n    \"\"\"Enable performance monitoring.\"\"\"\n    self.enabled = True\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetrics.disable","title":"disable","text":"<pre><code>disable()\n</code></pre> <p>Disable performance monitoring.</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def disable(self):\n    \"\"\"Disable performance monitoring.\"\"\"\n    self.enabled = False\n</code></pre>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.PerformanceMetricsProxy","title":"PerformanceMetricsProxy","text":"<p>A proxy class that forwards calls to the singleton PerformanceMetrics instance.</p>"},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics-functions","title":"Functions","text":""},{"location":"utils/api/performance-metrics/#network_security_suite.utils.performance_metrics.get_perf_instance","title":"get_perf_instance","text":"<pre><code>get_perf_instance()\n</code></pre> <p>Get the singleton PerformanceMetrics instance.</p> Source code in <code>src/network_security_suite/utils/performance_metrics.py</code> <pre><code>def get_perf_instance():\n    \"\"\"Get the singleton PerformanceMetrics instance.\"\"\"\n    global _perf_instance\n    if _perf_instance is None:\n        _perf_instance = PerformanceMetrics(log_to_file=False)\n    return _perf_instance\n</code></pre>"},{"location":"utils/api/performance-metrics/#usage-examples","title":"Usage Examples","text":""},{"location":"utils/api/performance-metrics/#basic-usage","title":"Basic Usage","text":"<pre><code>from network_security_suite.utils import PerformanceMetrics\n\nmetrics = PerformanceMetrics()\n\n# Measure execution time\nwith metrics.measure(\"operation\"):\n    do_work()\n\n# Get time\nduration = metrics.get_time(\"operation\")\nprint(f\"Duration: {duration:.2f}s\")\n</code></pre>"},{"location":"utils/api/performance-metrics/#multiple-measurements","title":"Multiple Measurements","text":"<pre><code>metrics = PerformanceMetrics()\n\nfor i in range(100):\n    with metrics.measure(\"operation\"):\n        process_data()\n\n# Get statistics\nstats = metrics.get_stats(\"operation\")\nprint(f\"Average: {stats['mean']:.2f}s\")\nprint(f\"Min: {stats['min']:.2f}s\")\nprint(f\"Max: {stats['max']:.2f}s\")\n</code></pre>"},{"location":"utils/api/performance-metrics/#custom-metrics","title":"Custom Metrics","text":"<pre><code>metrics = PerformanceMetrics()\n\n# Record custom values\nmetrics.record(\"packets_processed\", 1000)\nmetrics.record(\"errors\", 5)\n\n# Increment counters\nmetrics.increment(\"request_count\")\n\n# Get report\nreport = metrics.get_report()\n</code></pre>"},{"location":"utils/api/performance-metrics/#see-also","title":"See Also","text":"<ul> <li>Performance Metrics Guide</li> <li>Logger API</li> <li>Configuration Guide</li> </ul>"}]}